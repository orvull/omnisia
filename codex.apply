 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/arc-doc/src/lib.rs b/arc-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..ff3eddcfed12c24530cc65ce66d03464a50b9952
--- /dev/null
+++ b/arc-doc/src/lib.rs
@@ -0,0 +1,199 @@
+//! Arc<T> mini-docs + runnable examples in one file
+//!
+//! What is Arc<T>?
+//! - Thread-safe reference-counted smart pointer (Atomic Rc).
+//! - Enables multiple owners of the same heap value across threads.
+//! - Cloning is cheap (increments atomic strong refcount).
+//! - Send/Sync depends on T (Arc adds thread-safety for the pointer, not the inner T).
+//!
+//! Common combos:
+//! - Arc<T> alone -> shared immutable ownership across threads
+//! - Arc<Mutex<T>> / Arc<RwLock<T>> -> shared + mutable across threads
+//! - Arc<Atomic*> -> lock-free shared counters/flags
+//! - Arc<Something> + Weak<Something> -> shared graphs/trees without cycles
+
+use std::sync::{Arc, Mutex, RwLock};
+use std::sync::atomic::{AtomicUsize, Ordering};
+use std::rc::Rc; // only used in doc contrast
+use std::thread;
+use std::time::Duration;
+use std::sync::Weak;
+
+pub fn example_basic() {
+    println!("== Example 1: Basic Arc usage across threads ==");
+    let msg = Arc::new(String::from("hello, world"));
+
+    let mut handles = vec![];
+    for i in 0..3 {
+        let m = Arc::clone(&msg); // cheap, atomic refcount increment
+        handles.push(thread::spawn(move || {
+            println!("[thread {i}] {}", m);
+        }));
+    }
+    for h in handles { h.join().unwrap(); }
+
+    println!("strong_count(msg) = {}", Arc::strong_count(&msg));
+}
+
+pub fn example_mutation_with_mutex() {
+    println!("\n== Example 2: Shared + mutable with Arc<Mutex<T>> ==");
+    let data: Arc<Mutex<Vec<i32>>> = Arc::new(Mutex::new(vec![]));
+
+    let mut handles = vec![];
+    for i in 1..=4 {
+        let d = Arc::clone(&data);
+        handles.push(thread::spawn(move || {
+            let mut guard = d.lock().unwrap(); // exclusive lock
+            guard.push(i);
+            // guard dropped here
+        }));
+    }
+    for h in handles { h.join().unwrap(); }
+
+    println!("data = {:?}", *data.lock().unwrap()); // [1,2,3,4] in some order
+}
+
+pub fn example_rwlock_readers_writers() {
+    println!("\n== Example 3: Many readers / one writer with Arc<RwLock<T>> ==");
+    let num = Arc::new(RwLock::new(0_u64));
+
+    // writer
+    {
+        let mut w = num.write().unwrap();
+        *w += 10;
+    }
+
+    // multiple readers in parallel
+    let mut handles = vec![];
+    for i in 0..3 {
+        let n = Arc::clone(&num);
+        handles.push(thread::spawn(move || {
+            let r = n.read().unwrap();
+            println!("[reader {i}] value = {}", *r);
+        }));
+    }
+    for h in handles { h.join().unwrap(); }
+
+    // another write
+    {
+        let mut w = num.write().unwrap();
+        *w += 1;
+    }
+    println!("final value = {}", *num.read().unwrap());
+}
+
+pub fn example_atomic_counter() {
+    println!("\n== Example 4: Lock-free counter with Arc<AtomicUsize> ==");
+    let counter = Arc::new(AtomicUsize::new(0));
+    let mut handles = vec![];
+
+    for _ in 0..8 {
+        let c = Arc::clone(&counter);
+        handles.push(thread::spawn(move || {
+            for _ in 0..1000 {
+                c.fetch_add(1, Ordering::Relaxed);
+            }
+        }));
+    }
+    for h in handles { h.join().unwrap(); }
+
+    println!("count = {}", counter.load(Ordering::Relaxed)); // 8000
+}
+
+pub fn example_try_unwrap() {
+    println!("\n== Example 5: Arc::try_unwrap to move out when uniquely owned ==");
+    let a = Arc::new(String::from("unique"));
+    match Arc::try_unwrap(a) {
+        Ok(s) => println!("moved out: {s}"), // refcount == 1 -> success
+        Err(_) => println!("still shared"),
+    }
+
+    let a = Arc::new(String::from("shared"));
+    let a2 = Arc::clone(&a);
+    match Arc::try_unwrap(a) {
+        Ok(_) => println!("unexpected"),
+        Err(arc_back) => {
+            println!("cannot unwrap: strong_count = {}", Arc::strong_count(&arc_back));
+            drop(a2); // drop the sibling so refcount goes to 1 (not shown further)
+        }
+    }
+}
+
+#[derive(Debug)]
+struct GNode {
+    name: String,
+    children: Mutex<Vec<Arc<GNode>>>, // strong edges to children
+    parent: Mutex<Weak<GNode>>,       // weak edge to parent to avoid cycles
+}
+
+pub fn example_weak_to_avoid_cycles() {
+    println!("\n== Example 6: Avoid cycles with Arc<Weak<T>> ==");
+    let root = Arc::new(GNode {
+        name: "root".into(),
+        children: Mutex::new(vec![]),
+        parent: Mutex::new(Weak::new()),
+    });
+
+    let child = Arc::new(GNode {
+        name: "child".into(),
+        children: Mutex::new(vec![]),
+        parent: Mutex::new(Weak::new()),
+    });
+
+    // root -> child (strong)
+    root.children.lock().unwrap().push(child.clone());
+    // child -> root (weak)
+    *child.parent.lock().unwrap() = Arc::downgrade(&root);
+
+    println!("root strong_count = {}", Arc::strong_count(&root));   // at least 1
+    println!("child strong_count = {}", Arc::strong_count(&child)); // at least 1
+
+    // upgrade weak link while root is alive
+    if let Some(parent) = child.parent.lock().unwrap().upgrade() {
+        println!("child's parent = {}", parent.name);
+    }
+
+    // After dropping root, child's weak parent won't keep it alive:
+    drop(root);
+    // Give the OS a moment so println! order is nice in some environments
+    thread::sleep(Duration::from_millis(10));
+
+    if child.parent.lock().unwrap().upgrade().is_none() {
+        println!("child's parent has been dropped (weak link is None)");
+    }
+}
+
+
+/*
+Docs-style notes:
+
+Arc<T> — Thread-safe shared ownership (atomic refcount)
+- Arc::new(value)       -> Arc<T>
+- Arc::clone(&arc)      -> increments STRONG atomic refcount
+- Arc::strong_count(&)  -> number of strong references
+- Arc::downgrade(&arc)  -> Weak<T> (weak refs don't keep value alive)
+- Weak::upgrade(&weak)  -> Option<Arc<T>> (Some if value still alive)
+- Arc::try_unwrap(arc)  -> Result<T, Arc<T>> (move out when unique)
+
+Mutation patterns:
+- Arc<T> alone gives shared immutable access.
+- For mutation across threads: Arc<Mutex<T>> or Arc<RwLock<T>>.
+  - Mutex: one writer at a time (exclusive).
+  - RwLock: many readers OR one writer.
+- For counters/flags: Arc<Atomic*> (lock-free).
+
+Threading:
+- Arc<T> is Send + Sync if T: Send + Sync (Arc doesn't auto-make T thread-safe).
+- Use Mutex/RwLock/Atomics to protect interior mutation in multi-threaded code.
+
+Contrast:
+- Rc<T>: single-threaded refcount (non-atomic), !Send, !Sync.
+- Arc<T>: multi-threaded refcount (atomic), Send/Sync if T is.
+- Box<T>: single owner, no refcount; immediate drop on owner drop.
+
+Pitfalls:
+- Avoid holding locks longer than needed to prevent contention/deadlocks.
+- Be careful with RwLock writer starvation (implementation-dependent).
+- Weak<T> is essential to break cycles in graph-like structures.
+
+*/
diff --git a/arc-doc/src/main.rs b/arc-doc/src/main.rs
index 04943dd7bca5584a47c321a3a4c295bc1c6929ae..be1ac6f86e1948693069147860689ccc1ba3b21d 100644
--- a/arc-doc/src/main.rs
+++ b/arc-doc/src/main.rs
@@ -1,207 +1,17 @@
-//! Arc<T> mini-docs + runnable examples in one file
-//!
-//! What is Arc<T>?
-//! - Thread-safe reference-counted smart pointer (Atomic Rc).
-//! - Enables multiple owners of the same heap value across threads.
-//! - Cloning is cheap (increments atomic strong refcount).
-//! - Send/Sync depends on T (Arc adds thread-safety for the pointer, not the inner T).
-//!
-//! Common combos:
-//! - Arc<T> alone -> shared immutable ownership across threads
-//! - Arc<Mutex<T>> / Arc<RwLock<T>> -> shared + mutable across threads
-//! - Arc<Atomic*> -> lock-free shared counters/flags
-//! - Arc<Something> + Weak<Something> -> shared graphs/trees without cycles
-
-use std::sync::{Arc, Mutex, RwLock};
-use std::sync::atomic::{AtomicUsize, Ordering};
-use std::rc::Rc; // only used in doc contrast
-use std::thread;
-use std::time::Duration;
-use std::sync::Weak;
-
-fn example_basic() {
-    println!("== Example 1: Basic Arc usage across threads ==");
-    let msg = Arc::new(String::from("hello, world"));
-
-    let mut handles = vec![];
-    for i in 0..3 {
-        let m = Arc::clone(&msg); // cheap, atomic refcount increment
-        handles.push(thread::spawn(move || {
-            println!("[thread {i}] {}", m);
-        }));
-    }
-    for h in handles { h.join().unwrap(); }
-
-    println!("strong_count(msg) = {}", Arc::strong_count(&msg));
-}
-
-fn example_mutation_with_mutex() {
-    println!("\n== Example 2: Shared + mutable with Arc<Mutex<T>> ==");
-    let data: Arc<Mutex<Vec<i32>>> = Arc::new(Mutex::new(vec![]));
-
-    let mut handles = vec![];
-    for i in 1..=4 {
-        let d = Arc::clone(&data);
-        handles.push(thread::spawn(move || {
-            let mut guard = d.lock().unwrap(); // exclusive lock
-            guard.push(i);
-            // guard dropped here
-        }));
-    }
-    for h in handles { h.join().unwrap(); }
-
-    println!("data = {:?}", *data.lock().unwrap()); // [1,2,3,4] in some order
-}
-
-fn example_rwlock_readers_writers() {
-    println!("\n== Example 3: Many readers / one writer with Arc<RwLock<T>> ==");
-    let num = Arc::new(RwLock::new(0_u64));
-
-    // writer
-    {
-        let mut w = num.write().unwrap();
-        *w += 10;
-    }
-
-    // multiple readers in parallel
-    let mut handles = vec![];
-    for i in 0..3 {
-        let n = Arc::clone(&num);
-        handles.push(thread::spawn(move || {
-            let r = n.read().unwrap();
-            println!("[reader {i}] value = {}", *r);
-        }));
-    }
-    for h in handles { h.join().unwrap(); }
-
-    // another write
-    {
-        let mut w = num.write().unwrap();
-        *w += 1;
-    }
-    println!("final value = {}", *num.read().unwrap());
-}
-
-fn example_atomic_counter() {
-    println!("\n== Example 4: Lock-free counter with Arc<AtomicUsize> ==");
-    let counter = Arc::new(AtomicUsize::new(0));
-    let mut handles = vec![];
-
-    for _ in 0..8 {
-        let c = Arc::clone(&counter);
-        handles.push(thread::spawn(move || {
-            for _ in 0..1000 {
-                c.fetch_add(1, Ordering::Relaxed);
-            }
-        }));
-    }
-    for h in handles { h.join().unwrap(); }
-
-    println!("count = {}", counter.load(Ordering::Relaxed)); // 8000
-}
-
-fn example_try_unwrap() {
-    println!("\n== Example 5: Arc::try_unwrap to move out when uniquely owned ==");
-    let a = Arc::new(String::from("unique"));
-    match Arc::try_unwrap(a) {
-        Ok(s) => println!("moved out: {s}"), // refcount == 1 -> success
-        Err(_) => println!("still shared"),
-    }
-
-    let a = Arc::new(String::from("shared"));
-    let a2 = Arc::clone(&a);
-    match Arc::try_unwrap(a) {
-        Ok(_) => println!("unexpected"),
-        Err(arc_back) => {
-            println!("cannot unwrap: strong_count = {}", Arc::strong_count(&arc_back));
-            drop(a2); // drop the sibling so refcount goes to 1 (not shown further)
-        }
-    }
-}
-
-#[derive(Debug)]
-struct GNode {
-    name: String,
-    children: Mutex<Vec<Arc<GNode>>>, // strong edges to children
-    parent: Mutex<Weak<GNode>>,       // weak edge to parent to avoid cycles
-}
-
-fn example_weak_to_avoid_cycles() {
-    println!("\n== Example 6: Avoid cycles with Arc<Weak<T>> ==");
-    let root = Arc::new(GNode {
-        name: "root".into(),
-        children: Mutex::new(vec![]),
-        parent: Mutex::new(Weak::new()),
-    });
-
-    let child = Arc::new(GNode {
-        name: "child".into(),
-        children: Mutex::new(vec![]),
-        parent: Mutex::new(Weak::new()),
-    });
-
-    // root -> child (strong)
-    root.children.lock().unwrap().push(child.clone());
-    // child -> root (weak)
-    *child.parent.lock().unwrap() = Arc::downgrade(&root);
-
-    println!("root strong_count = {}", Arc::strong_count(&root));   // at least 1
-    println!("child strong_count = {}", Arc::strong_count(&child)); // at least 1
-
-    // upgrade weak link while root is alive
-    if let Some(parent) = child.parent.lock().unwrap().upgrade() {
-        println!("child's parent = {}", parent.name);
-    }
-
-    // After dropping root, child's weak parent won't keep it alive:
-    drop(root);
-    // Give the OS a moment so println! order is nice in some environments
-    thread::sleep(Duration::from_millis(10));
-
-    if child.parent.lock().unwrap().upgrade().is_none() {
-        println!("child's parent has been dropped (weak link is None)");
-    }
-}
+use arc_doc::{
+    example_atomic_counter,
+    example_basic,
+    example_mutation_with_mutex,
+    example_rwlock_readers_writers,
+    example_try_unwrap,
+    example_weak_to_avoid_cycles,
+};
 
 fn main() {
     example_basic();
     example_mutation_with_mutex();
     example_rwlock_readers_writers();
     example_atomic_counter();
     example_try_unwrap();
     example_weak_to_avoid_cycles();
 }
-
-/*
-Docs-style notes:
-
-Arc<T> — Thread-safe shared ownership (atomic refcount)
-- Arc::new(value)       -> Arc<T>
-- Arc::clone(&arc)      -> increments STRONG atomic refcount
-- Arc::strong_count(&)  -> number of strong references
-- Arc::downgrade(&arc)  -> Weak<T> (weak refs don't keep value alive)
-- Weak::upgrade(&weak)  -> Option<Arc<T>> (Some if value still alive)
-- Arc::try_unwrap(arc)  -> Result<T, Arc<T>> (move out when unique)
-
-Mutation patterns:
-- Arc<T> alone gives shared immutable access.
-- For mutation across threads: Arc<Mutex<T>> or Arc<RwLock<T>>.
-  - Mutex: one writer at a time (exclusive).
-  - RwLock: many readers OR one writer.
-- For counters/flags: Arc<Atomic*> (lock-free).
-
-Threading:
-- Arc<T> is Send + Sync if T: Send + Sync (Arc doesn't auto-make T thread-safe).
-- Use Mutex/RwLock/Atomics to protect interior mutation in multi-threaded code.
-
-Contrast:
-- Rc<T>: single-threaded refcount (non-atomic), !Send, !Sync.
-- Arc<T>: multi-threaded refcount (atomic), Send/Sync if T is.
-- Box<T>: single owner, no refcount; immediate drop on owner drop.
-
-Pitfalls:
-- Avoid holding locks longer than needed to prevent contention/deadlocks.
-- Be careful with RwLock writer starvation (implementation-dependent).
-- Weak<T> is essential to break cycles in graph-like structures.
-
-*/
diff --git a/async-doc/Cargo.toml b/async-doc/Cargo.toml
index 7981b1db0e41ad4ac52eab8ad04b898ce20c5429..e4e3c37f5aed6bcd19a445581b25a47bce0e01c6 100644
--- a/async-doc/Cargo.toml
+++ b/async-doc/Cargo.toml
@@ -1,6 +1,8 @@
 [package]
 name = "async-doc"
 version = "0.1.0"
 edition = "2024"
 
 [dependencies]
+futures = "0.3"
+tokio = { version = "1", features = ["full"] }
diff --git a/async-doc/src/lib.rs b/async-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..cae1eca0ed9bb9e481586348eedb4bbc7f02ae14
--- /dev/null
+++ b/async-doc/src/lib.rs
@@ -0,0 +1,288 @@
+//! Async in Rust with Tokio — mini-docs + runnable examples
+//!
+//! TL;DR
+//! - `async fn` returns a Future; `.await` drives it to completion on a runtime.
+//! - You need an executor (e.g., Tokio) to poll futures.
+//! - Don’t block the async thread: use `tokio::time`, `tokio::sync`, `spawn_blocking`.
+//! - Prefer `tokio::sync::Mutex/RwLock` in async code (std::sync::Mutex blocks the thread).
+//!
+//! This file demonstrates:
+//!  1) async/await basics
+//!  2) spawning tasks, join handles, JoinSet, cancellation
+//!  3) channels (mpsc / oneshot), async Mutex/RwLock/Notify/Semaphore
+//!  4) timeouts, `select!`, cancellation points
+//!  5) streams
+//!  6) blocking work offloaded safely
+//!  7) brief internals & API cheat sheet (at bottom)
+
+use futures::{stream, StreamExt};
+use tokio::{
+    sync::{mpsc, oneshot, Mutex, RwLock, Notify, Semaphore},
+    task::JoinSet,
+    time::{self, Duration},
+};
+
+/* ─────────────────────────── 1) Basics ─────────────────────────── */
+
+pub async fn ex_basic() {
+    println!("== 1) async/await basics ==");
+    async fn add_after(a: i32, b: i32, ms: u64) -> i32 {
+        time::sleep(Duration::from_millis(ms)).await;
+        a + b
+    }
+
+    let x = add_after(1, 2, 20).await; // await suspends here, yields to runtime
+    println!("1+2 after delay = {x}");
+}
+
+/* ───────────────────── 2) Spawn tasks & join ───────────────────── */
+
+pub async fn ex_spawn_and_join() {
+    println!("\n== 2) spawning tasks & joining ==");
+    // Tasks run concurrently on Tokio worker threads
+    let h1 = tokio::spawn(async {
+        time::sleep(Duration::from_millis(10)).await;
+        "task-1 done"
+    });
+    let h2 = tokio::spawn(async {
+        time::sleep(Duration::from_millis(5)).await;
+        "task-2 done"
+    });
+
+    // Await both (order independent)
+    let (r1, r2) = tokio::join!(h1, h2);
+    println!("{}, {}", r1.unwrap(), r2.unwrap());
+}
+
+/* ─────────────── 3) JoinSet and cancellation patterns ───────────── */
+
+pub async fn ex_joinset_and_cancel() {
+    println!("\n== 3) JoinSet & cancellation ==");
+    let mut set = JoinSet::new();
+    for i in 0..3 {
+        set.spawn(async move {
+            time::sleep(Duration::from_millis(10 * (i + 1))).await;
+            format!("job {i} done")
+        });
+    }
+
+    // Cancel one task (e.g., based on condition)
+    if let Some(handle) = set.join_next().await {
+        println!("first finished: {}", handle.unwrap());
+        // drop remaining by clearing the set:
+        set.abort_all();
+    }
+
+    // Draining aborted joins (optional)
+    while let Some(res) = set.join_next().await {
+        match res {
+            Ok(msg) => println!("finished later: {msg}"),
+            Err(e) if e.is_cancelled() => println!("a task was cancelled"),
+            Err(e) => println!("task error: {e}"),
+        }
+    }
+}
+
+/* ───────────── 4) Channels (mpsc / oneshot) ───────────── */
+
+pub async fn ex_channels() {
+    println!("\n== 4) channels (mpsc & oneshot) ==");
+
+    // mpsc: multiple producers, single consumer
+    let (tx, mut rx) = mpsc::channel::<String>(16);
+    for i in 0..3 {
+        let txi = tx.clone();
+        tokio::spawn(async move {
+            txi.send(format!("msg #{i}")).await.ok();
+        });
+    }
+    drop(tx); // close channel—receiver ends when all senders dropped
+
+    while let Some(msg) = rx.recv().await {
+        println!("mpsc got: {msg}");
+    }
+
+    // oneshot: one value, one receiver
+    let (txo, rxo) = oneshot::channel::<u32>();
+    tokio::spawn(async move {
+        time::sleep(Duration::from_millis(10)).await;
+        let _ = txo.send(42);
+    });
+    println!("oneshot => {}", rxo.await.unwrap());
+}
+
+/* ──────── 5) Async locks (Mutex/RwLock), Notify, Semaphore ──────── */
+
+pub async fn ex_locks_notify_semaphore() {
+    println!("\n== 5) async locks, notify, semaphore ==");
+    // Async Mutex (non-blocking while pending)
+    let counter = Mutex::new(0u64);
+    let mut tasks = vec![];
+    for _ in 0..4 {
+        let c = &counter;
+        tasks.push(tokio::spawn(async move {
+            for _ in 0..1000 {
+                *c.lock().await += 1;
+            }
+        }));
+    }
+    for t in tasks { t.await.unwrap(); }
+    println!("counter (Mutex) = {}", *counter.lock().await);
+
+    // Async RwLock
+    let data = RwLock::new(String::from("init"));
+    {
+        let mut w = data.write().await;
+        *w = "updated".into();
+    }
+    let (r1, r2, r3) = tokio::join!(
+        async { data.read().await.clone() },
+        async { data.read().await.clone() },
+        async { data.read().await.clone() },
+    );
+    println!("RwLock reads: {r1:?}, {r2:?}, {r3:?}");
+
+    // Notify: simple wakeup primitive
+    let notify = Notify::new();
+    let notified = notify.notified();
+    let n2 = notify.clone();
+    tokio::spawn(async move {
+        time::sleep(Duration::from_millis(15)).await;
+        n2.notify_one();
+    });
+    notified.await; // wait for notification
+    println!("notified!");
+
+    // Semaphore: rate limiting / resource permits
+    let sem = Semaphore::new(2); // two concurrent permits
+    let mut handles = vec![];
+    for i in 0..5 {
+        let s = sem.clone();
+        handles.push(tokio::spawn(async move {
+            let _permit = s.acquire().await.unwrap();
+            println!("task {i} entered");
+            time::sleep(Duration::from_millis(10)).await;
+            println!("task {i} leaving");
+        }));
+    }
+    for h in handles { h.await.unwrap(); }
+}
+
+/* ─────────────── 6) Timeouts, select!, cancellation ─────────────── */
+
+pub async fn ex_timeouts_and_select() {
+    use tokio::select;
+    println!("\n== 6) timeout & select! ==");
+
+    // timeout
+    let res = tokio::time::timeout(Duration::from_millis(10), work_slow(20)).await;
+    println!("timeout result: {:?}", res.map_err(|_| "timed out"));
+
+    // select! over multiple branches
+    let fast = work_slow(5);
+    let slow = work_slow(30);
+    select! {
+        v = fast => println!("fast finished first: {v}"),
+        v = slow => println!("slow finished first: {v}"),
+        _ = time::sleep(Duration::from_millis(1_000)) => println!("fallback timeout"),
+    }
+
+    // Cancellation: dropping a future cancels it
+    let handle = tokio::spawn(work_slow(1000)); // long task
+    time::sleep(Duration::from_millis(5)).await;
+    handle.abort(); // cooperative cancel
+    match handle.await {
+        Err(e) if e.is_cancelled() => println!("task cancelled"),
+        other => println!("task finished: {:?}", other),
+    }
+}
+
+async fn work_slow(ms: u64) -> &'static str {
+    time::sleep(Duration::from_millis(ms)).await;
+    "ok"
+}
+
+/* ───────────────────────── 7) Streams ───────────────────────── */
+
+pub async fn ex_streams() {
+    println!("\n== 7) streams (async sequences) ==");
+    // A tiny stream of numbers with async processing
+    let s = stream::iter(1..=5).then(|n| async move {
+        time::sleep(Duration::from_millis(5)).await;
+        n * n
+    });
+
+    let out: Vec<_> = s.collect().await;
+    println!("squares via stream = {:?}", out);
+}
+
+/* ─────────────── 8) Offloading blocking work safely ─────────────── */
+
+pub async fn ex_blocking_work() {
+    println!("\n== 8) spawn_blocking for CPU-bound or blocking IO ==");
+    // Heavy/blocking computations must not run on async worker threads.
+    let sum = tokio::task::spawn_blocking(|| {
+        // pretend heavy CPU loop
+        (0..2_000_000).fold(0u64, |a, b| a.wrapping_add(b))
+    }).await.unwrap();
+    println!("blocking sum = {sum}");
+}
+
+/* ────────────────────────── Docs-style notes ──────────────────────────
+
+WHAT ASYNC IS
+- `async fn foo() -> T` returns `impl Future<Output = T>`.
+- `.await` yields control to the runtime until the Future is ready.
+- Futures are polled cooperatively; no preemption. Long computations must yield (e.g., via `.await`).
+
+RUNTIME
+- The standard library provides Futures but NOT an executor. Use a runtime (Tokio, async-std, etc.).
+- Tokio features: multithreaded scheduler, timers, IO, sync primitives, task utilities.
+
+DO & DON’T
+- ✅ Use `tokio::time::sleep`, channels, async `Mutex/RwLock`, `Notify`, `Semaphore`.
+- ✅ Use `spawn_blocking` for CPU-bound or blocking syscalls (file compression, synchronous DB client).
+- ❌ Don’t hold a std::sync::Mutex or a long-lived borrow across `.await` (can deadlock/starve).
+- ❌ Don’t block with `std::thread::sleep` in async code.
+
+LOCKS IN ASYNC
+- Use `tokio::sync::Mutex/RwLock`: `lock().await` returns a guard; keep lock scope small; drop before `.await`ing other things.
+- For simple counters/flags use atomics on a shared `Arc<Atomic*>` (works fine inside async).
+
+CONCURRENCY PRIMITIVES (Tokio)
+- Tasks: `tokio::spawn`, `JoinSet`, `JoinHandle::abort`.
+- Time: `tokio::time::{sleep, timeout, interval}`.
+- Select: `tokio::select!` to await whichever future completes first.
+- Channels: `mpsc` (multi-producer), `oneshot` (single value).
+- Sync: `Mutex`, `RwLock`, `Notify` (wakeup), `Semaphore` (permits).
+
+CANCELLATION
+- Dropping a future or calling `JoinHandle::abort()` cancels the task.
+- Cancellation is cooperative: code should `.await` periodically to be cancellable.
+
+STREAMS
+- A stream is “async Iterator”. Common ops via `futures::stream`: `map/then/buffer_unordered/collect`.
+- Many IO types in Tokio implement Stream (e.g., lines from a socket via `Framed` in tokio-util).
+
+INTEROP & TRAITS
+- Trait methods can’t be `async` in stable without help; use `async-trait` crate or GATs-based patterns.
+- `Send` across `.await`: values held over an `.await` inside a `Send` future must be `Send`.
+
+API CHEAT SHEET
+- Spawn:          `tokio::spawn(async move { ... }) -> JoinHandle<T>`
+- JoinSet:        run many tasks, `set.spawn(...)`, `set.join_next().await`, `set.abort_all()`
+- Timeout:        `tokio::time::timeout(dur, fut).await`
+- Select:         `tokio::select! { a = fut1 => ..., _ = fut2 => ..., }`
+- Channels:       `let (tx, rx) = mpsc::channel::<T>(cap); tx.send(v).await; rx.recv().await;`
+- Oneshoot:       `let (tx, rx) = oneshot::channel(); tx.send(v)?; rx.await?;`
+- Locks:          `let mut g = mutex.lock().await;`
+- Notify:         `notify.notified().await; notify.notify_one();`
+- Semaphore:      `let permit = sem.acquire().await?;` (drops to release)
+- Blocking:       `tokio::task::spawn_blocking(|| heavy())`
+
+INTERNALS (mental model)
+- `async fn` is transformed to a state machine that implements `Future`.
+- Each `.await` is a suspension point; the executor polls the future when it can make progress.
+- Tokio uses a work-stealing scheduler; IO/timers wake tasks via reactor events.
+
+*/
diff --git a/async-doc/src/main.rs b/async-doc/src/main.rs
index 92b5dc571cfad28fe5519cb2bc45b7a75a37c700..02f2baabc56b4799c65b073b37074697eef87a41 100644
--- a/async-doc/src/main.rs
+++ b/async-doc/src/main.rs
@@ -1,300 +1,22 @@
-//! Async in Rust with Tokio — mini-docs + runnable examples
-//!
-//! TL;DR
-//! - `async fn` returns a Future; `.await` drives it to completion on a runtime.
-//! - You need an executor (e.g., Tokio) to poll futures.
-//! - Don’t block the async thread: use `tokio::time`, `tokio::sync`, `spawn_blocking`.
-//! - Prefer `tokio::sync::Mutex/RwLock` in async code (std::sync::Mutex blocks the thread).
-//!
-//! This file demonstrates:
-//!  1) async/await basics
-//!  2) spawning tasks, join handles, JoinSet, cancellation
-//!  3) channels (mpsc / oneshot), async Mutex/RwLock/Notify/Semaphore
-//!  4) timeouts, `select!`, cancellation points
-//!  5) streams
-//!  6) blocking work offloaded safely
-//!  7) brief internals & API cheat sheet (at bottom)
-
-use futures::{stream, StreamExt};
-use tokio::{
-    sync::{mpsc, oneshot, Mutex, RwLock, Notify, Semaphore},
-    task::{JoinSet},
-    time::{self, Duration},
+use async_doc::{
+    ex_basic,
+    ex_spawn_and_join,
+    ex_joinset_and_cancel,
+    ex_channels,
+    ex_locks_notify_semaphore,
+    ex_timeouts_and_select,
+    ex_streams,
+    ex_blocking_work,
 };
 
 #[tokio::main]
 async fn main() {
     ex_basic().await;
     ex_spawn_and_join().await;
     ex_joinset_and_cancel().await;
     ex_channels().await;
     ex_locks_notify_semaphore().await;
     ex_timeouts_and_select().await;
     ex_streams().await;
     ex_blocking_work().await;
 }
-
-/* ─────────────────────────── 1) Basics ─────────────────────────── */
-
-async fn ex_basic() {
-    println!("== 1) async/await basics ==");
-    async fn add_after(a: i32, b: i32, ms: u64) -> i32 {
-        time::sleep(Duration::from_millis(ms)).await;
-        a + b
-    }
-
-    let x = add_after(1, 2, 20).await; // await suspends here, yields to runtime
-    println!("1+2 after delay = {x}");
-}
-
-/* ───────────────────── 2) Spawn tasks & join ───────────────────── */
-
-async fn ex_spawn_and_join() {
-    println!("\n== 2) spawning tasks & joining ==");
-    // Tasks run concurrently on Tokio worker threads
-    let h1 = tokio::spawn(async {
-        time::sleep(Duration::from_millis(10)).await;
-        "task-1 done"
-    });
-    let h2 = tokio::spawn(async {
-        time::sleep(Duration::from_millis(5)).await;
-        "task-2 done"
-    });
-
-    // Await both (order independent)
-    let (r1, r2) = tokio::join!(h1, h2);
-    println!("{}, {}", r1.unwrap(), r2.unwrap());
-}
-
-/* ─────────────── 3) JoinSet and cancellation patterns ───────────── */
-
-async fn ex_joinset_and_cancel() {
-    println!("\n== 3) JoinSet & cancellation ==");
-    let mut set = JoinSet::new();
-    for i in 0..3 {
-        set.spawn(async move {
-            time::sleep(Duration::from_millis(10 * (i + 1))).await;
-            format!("job {i} done")
-        });
-    }
-
-    // Cancel one task (e.g., based on condition)
-    if let Some(handle) = set.join_next().await {
-        println!("first finished: {}", handle.unwrap());
-        // drop remaining by clearing the set:
-        set.abort_all();
-    }
-
-    // Draining aborted joins (optional)
-    while let Some(res) = set.join_next().await {
-        match res {
-            Ok(msg) => println!("finished later: {msg}"),
-            Err(e) if e.is_cancelled() => println!("a task was cancelled"),
-            Err(e) => println!("task error: {e}"),
-        }
-    }
-}
-
-/* ───────────── 4) Channels (mpsc / oneshot) ───────────── */
-
-async fn ex_channels() {
-    println!("\n== 4) channels (mpsc & oneshot) ==");
-
-    // mpsc: multiple producers, single consumer
-    let (tx, mut rx) = mpsc::channel::<String>(16);
-    for i in 0..3 {
-        let txi = tx.clone();
-        tokio::spawn(async move {
-            txi.send(format!("msg #{i}")).await.ok();
-        });
-    }
-    drop(tx); // close channel—receiver ends when all senders dropped
-
-    while let Some(msg) = rx.recv().await {
-        println!("mpsc got: {msg}");
-    }
-
-    // oneshot: one value, one receiver
-    let (txo, rxo) = oneshot::channel::<u32>();
-    tokio::spawn(async move {
-        time::sleep(Duration::from_millis(10)).await;
-        let _ = txo.send(42);
-    });
-    println!("oneshot => {}", rxo.await.unwrap());
-}
-
-/* ──────── 5) Async locks (Mutex/RwLock), Notify, Semaphore ──────── */
-
-async fn ex_locks_notify_semaphore() {
-    println!("\n== 5) async locks, notify, semaphore ==");
-    // Async Mutex (non-blocking while pending)
-    let counter = Mutex::new(0u64);
-    let mut tasks = vec![];
-    for _ in 0..4 {
-        let c = &counter;
-        tasks.push(tokio::spawn(async move {
-            for _ in 0..1000 {
-                *c.lock().await += 1;
-            }
-        }));
-    }
-    for t in tasks { t.await.unwrap(); }
-    println!("counter (Mutex) = {}", *counter.lock().await);
-
-    // Async RwLock
-    let data = RwLock::new(String::from("init"));
-    {
-        let mut w = data.write().await;
-        *w = "updated".into();
-    }
-    let (r1, r2, r3) = tokio::join!(
-        async { data.read().await.clone() },
-        async { data.read().await.clone() },
-        async { data.read().await.clone() },
-    );
-    println!("RwLock reads: {r1:?}, {r2:?}, {r3:?}");
-
-    // Notify: simple wakeup primitive
-    let notify = Notify::new();
-    let notified = notify.notified();
-    let n2 = notify.clone();
-    tokio::spawn(async move {
-        time::sleep(Duration::from_millis(15)).await;
-        n2.notify_one();
-    });
-    notified.await; // wait for notification
-    println!("notified!");
-
-    // Semaphore: rate limiting / resource permits
-    let sem = Semaphore::new(2); // two concurrent permits
-    let mut handles = vec![];
-    for i in 0..5 {
-        let s = sem.clone();
-        handles.push(tokio::spawn(async move {
-            let _permit = s.acquire().await.unwrap();
-            println!("task {i} entered");
-            time::sleep(Duration::from_millis(10)).await;
-            println!("task {i} leaving");
-        }));
-    }
-    for h in handles { h.await.unwrap(); }
-}
-
-/* ─────────────── 6) Timeouts, select!, cancellation ─────────────── */
-
-async fn ex_timeouts_and_select() {
-    use tokio::select;
-    println!("\n== 6) timeout & select! ==");
-
-    // timeout
-    let res = tokio::time::timeout(Duration::from_millis(10), work_slow(20)).await;
-    println!("timeout result: {:?}", res.map_err(|_| "timed out"));
-
-    // select! over multiple branches
-    let fast = work_slow(5);
-    let slow = work_slow(30);
-    select! {
-        v = fast => println!("fast finished first: {v}"),
-        v = slow => println!("slow finished first: {v}"),
-        _ = time::sleep(Duration::from_millis(1_000)) => println!("fallback timeout"),
-    }
-
-    // Cancellation: dropping a future cancels it
-    let handle = tokio::spawn(work_slow(1000)); // long task
-    time::sleep(Duration::from_millis(5)).await;
-    handle.abort(); // cooperative cancel
-    match handle.await {
-        Err(e) if e.is_cancelled() => println!("task cancelled"),
-        other => println!("task finished: {:?}", other),
-    }
-}
-
-async fn work_slow(ms: u64) -> &'static str {
-    time::sleep(Duration::from_millis(ms)).await;
-    "ok"
-}
-
-/* ───────────────────────── 7) Streams ───────────────────────── */
-
-async fn ex_streams() {
-    println!("\n== 7) streams (async sequences) ==");
-    // A tiny stream of numbers with async processing
-    let s = stream::iter(1..=5).then(|n| async move {
-        time::sleep(Duration::from_millis(5)).await;
-        n * n
-    });
-
-    let out: Vec<_> = s.collect().await;
-    println!("squares via stream = {:?}", out);
-}
-
-/* ─────────────── 8) Offloading blocking work safely ─────────────── */
-
-async fn ex_blocking_work() {
-    println!("\n== 8) spawn_blocking for CPU-bound or blocking IO ==");
-    // Heavy/blocking computations must not run on async worker threads.
-    let sum = tokio::task::spawn_blocking(|| {
-        // pretend heavy CPU loop
-        (0..2_000_000).fold(0u64, |a, b| a.wrapping_add(b))
-    }).await.unwrap();
-    println!("blocking sum = {sum}");
-}
-
-/* ────────────────────────── Docs-style notes ──────────────────────────
-
-WHAT ASYNC IS
-- `async fn foo() -> T` returns `impl Future<Output = T>`.
-- `.await` yields control to the runtime until the Future is ready.
-- Futures are polled cooperatively; no preemption. Long computations must yield (e.g., via `.await`).
-
-RUNTIME
-- The standard library provides Futures but NOT an executor. Use a runtime (Tokio, async-std, etc.).
-- Tokio features: multithreaded scheduler, timers, IO, sync primitives, task utilities.
-
-DO & DON’T
-- ✅ Use `tokio::time::sleep`, channels, async `Mutex/RwLock`, `Notify`, `Semaphore`.
-- ✅ Use `spawn_blocking` for CPU-bound or blocking syscalls (file compression, synchronous DB client).
-- ❌ Don’t hold a std::sync::Mutex or a long-lived borrow across `.await` (can deadlock/starve).
-- ❌ Don’t block with `std::thread::sleep` in async code.
-
-LOCKS IN ASYNC
-- Use `tokio::sync::Mutex/RwLock`: `lock().await` returns a guard; keep lock scope small; drop before `.await`ing other things.
-- For simple counters/flags use atomics on a shared `Arc<Atomic*>` (works fine inside async).
-
-CONCURRENCY PRIMITIVES (Tokio)
-- Tasks: `tokio::spawn`, `JoinSet`, `JoinHandle::abort`.
-- Time: `tokio::time::{sleep, timeout, interval}`.
-- Select: `tokio::select!` to await whichever future completes first.
-- Channels: `mpsc` (multi-producer), `oneshot` (single value).
-- Sync: `Mutex`, `RwLock`, `Notify` (wakeup), `Semaphore` (permits).
-
-CANCELLATION
-- Dropping a future or calling `JoinHandle::abort()` cancels the task.
-- Cancellation is cooperative: code should `.await` periodically to be cancellable.
-
-STREAMS
-- A stream is “async Iterator”. Common ops via `futures::stream`: `map/then/buffer_unordered/collect`.
-- Many IO types in Tokio implement Stream (e.g., lines from a socket via `Framed` in tokio-util).
-
-INTEROP & TRAITS
-- Trait methods can’t be `async` in stable without help; use `async-trait` crate or GATs-based patterns.
-- `Send` across `.await`: values held over an `.await` inside a `Send` future must be `Send`.
-
-API CHEAT SHEET
-- Spawn:          `tokio::spawn(async move { ... }) -> JoinHandle<T>`
-- JoinSet:        run many tasks, `set.spawn(...)`, `set.join_next().await`, `set.abort_all()`
-- Timeout:        `tokio::time::timeout(dur, fut).await`
-- Select:         `tokio::select! { a = fut1 => ..., _ = fut2 => ..., }`
-- Channels:       `let (tx, rx) = mpsc::channel::<T>(cap); tx.send(v).await; rx.recv().await;`
-- Oneshoot:       `let (tx, rx) = oneshot::channel(); tx.send(v)?; rx.await?;`
-- Locks:          `let mut g = mutex.lock().await;`
-- Notify:         `notify.notified().await; notify.notify_one();`
-- Semaphore:      `let permit = sem.acquire().await?;` (drops to release)
-- Blocking:       `tokio::task::spawn_blocking(|| heavy())`
-
-INTERNALS (mental model)
-- `async fn` is transformed to a state machine that implements `Future`.
-- Each `.await` is a suspension point; the executor polls the future when it can make progress.
-- Tokio uses a work-stealing scheduler; IO/timers wake tasks via reactor events.
-
-*/```
diff --git a/atomic-docs/src/lib.rs b/atomic-docs/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..bfe56924e9fa9ce79af505cb867feb14969fba5c
--- /dev/null
+++ b/atomic-docs/src/lib.rs
@@ -0,0 +1,268 @@
+//! Atomics in Rust — std::sync::atomic::Atomic* + crossbeam::atomic::AtomicCell<T>
+//!
+//! TL;DR
+//! - Atomics let threads coordinate **without locks** by reading/writing plain machine words atomically.
+//! - The standard library offers fixed atomic types: AtomicBool, AtomicUsize, AtomicI64, …, AtomicPtr<T>.
+//! - `AtomicCell<T>` (from `crossbeam`) is a convenient wrapper that works for any `T: Copy` (and some Option<NonNull<_>>).
+//! - Memory order matters: use Relaxed for counters, Acquire/Release for handoffs, SeqCst for simplicity (slower).
+//!
+//! This file demonstrates:
+//!  1) Atomic counters with Relaxed
+//!  2) Flags with Acquire/Release
+//!  3) `compare_exchange` patterns (one-time init / CAS loop)
+//!  4) AtomicPtr and fences
+//!  5) AtomicCell<T> ergonomics (load/store/swap/update)
+//!  6) Cheatsheet + pitfalls (in comments)
+
+use std::{
+    ptr::NonNull,
+    sync::{
+        atomic::{
+            fence, AtomicBool, AtomicPtr, AtomicU64, AtomicUsize, Ordering::{self, *}
+        },
+        Arc,
+    },
+    thread,
+    time::Duration,
+};
+
+// Crossbeam's AtomicCell:
+use crossbeam::atomic::AtomicCell;
+
+/* ───────────────────────── 1) Counter (Relaxed) ─────────────────────────
+Relaxed operations are fine when you only need a number to be correct,
+not to publish data associated with that number.
+*/
+pub fn ex_relaxed_counter() {
+    println!("== 1) Relaxed counter ==");
+    let hits = Arc::new(AtomicUsize::new(0));
+    let mut handles = vec![];
+    for _ in 0..8 {
+        let h = hits.clone();
+        handles.push(thread::spawn(move || {
+            for _ in 0..100_000 {
+                h.fetch_add(1, Relaxed);
+            }
+        }));
+    }
+    for h in handles { h.join().unwrap(); }
+    println!("hits = {}", hits.load(Relaxed)); // 800_000
+}
+
+/* ───────────── 2) Flag handoff (Release writer → Acquire reader) ─────────────
+Use a Release store to "publish" data written before it; Acquire load by reader
+to "see" that data. This creates a happens-before edge.
+*/
+pub fn ex_acquire_release_flag() {
+    println!("\n== 2) Acquire/Release flag (publish data) ==");
+    static READY: AtomicBool = AtomicBool::new(false);
+    static VALUE: AtomicU64  = AtomicU64::new(0);
+
+    let w = thread::spawn(|| {
+        VALUE.store(42, Relaxed);      // write data first
+        READY.store(true, Release);    // publish with Release
+    });
+
+    let r = thread::spawn(|| {
+        // Spin until we observe the flag with Acquire
+        while !READY.load(Acquire) { std::hint::spin_loop(); }
+        // Because of Acquire, we must observe VALUE=42 here
+        let v = VALUE.load(Relaxed);
+        println!("observed VALUE = {}", v);
+    });
+
+    w.join().unwrap();
+    r.join().unwrap();
+}
+
+/* ─────────────── 3) CAS patterns: one-time init & CAS loop ───────────────
+- compare_exchange(old, new, success_order, failure_order) attempts to set atom from old→new.
+- On success returns Ok(old); on failure returns Err(current).
+*/
+pub fn ex_compare_exchange() {
+    println!("\n== 3) compare_exchange patterns ==");
+    // One-time init (idempotent set from 0 → some id)
+    let id = AtomicUsize::new(0);
+    let my_id = 7;
+    let _ = id.compare_exchange(0, my_id, AcqRel, Acquire).ok();
+    println!("id after one-time init = {}", id.load(Acquire));
+
+    // CAS loop: increment even-only (toy example)
+    let x = AtomicUsize::new(10);
+    loop {
+        let cur = x.load(Relaxed);
+        if cur % 2 == 1 {
+            println!("x is odd; not changing");
+            break;
+        }
+        // propose next even+2
+        match x.compare_exchange_weak(cur, cur + 2, AcqRel, Acquire) {
+            Ok(_) => { println!("x -> {}", x.load(Relaxed)); break; }
+            Err(_) => { std::hint::spin_loop(); } // retry
+        }
+    }
+}
+
+/* ─────────────── 4) AtomicPtr + fences (advanced publish) ───────────────
+Sometimes you publish *pointers*. Use Release on the publishing store and
+Acquire on the consuming load. `fence(Release)` / `fence(Acquire)` can be
+used to separate the atomic op from adjacent ordinary memory accesses.
+*/
+pub fn ex_atomic_ptr_and_fence() {
+    println!("\n== 4) AtomicPtr & fences ==");
+    #[derive(Debug)]
+    struct Payload { a: u32, b: u32 }
+
+    static PTR: AtomicPtr<Payload> = AtomicPtr::new(std::ptr::null_mut());
+
+    // Producer thread: allocate and publish
+    let t = thread::spawn(|| {
+        let b = Box::new(Payload { a: 1, b: 2 });
+        let raw = Box::into_raw(b);
+        // Ensure prior writes to *raw are visible before we publish the pointer:
+        fence(Release);
+        PTR.store(raw, Release);
+    });
+
+    // Consumer: wait until pointer is non-null, then read it
+    let r = thread::spawn(|| {
+        let mut p;
+        loop {
+            p = PTR.load(Acquire);
+            if !p.is_null() { break; }
+            std::hint::spin_loop();
+        }
+        // Acquire (and the Release fence) ensure we see initialized fields.
+        let val = unsafe { &*p };
+        println!("read via ptr: {:?}", val);
+        // Clean-up: reclaim the Box (single consumer in this toy demo)
+        unsafe { drop(Box::from_raw(p)); }
+        PTR.store(std::ptr::null_mut(), Release);
+    });
+
+    t.join().unwrap();
+    r.join().unwrap();
+}
+
+/* ─────────────────── 5) AtomicCell<T> ergonomics (crossbeam) ───────────────────
+AtomicCell<T> provides load/store/swap/fetch_update for any `T: Copy` (and some niche
+non-Copy via specialized impls). It’s often simpler than juggling specific Atomic* types.
+*/
+pub fn ex_atomic_cell_basics() {
+    println!("\n== 5) AtomicCell<T> basics ==");
+    let cell = AtomicCell::new(10u32);
+    println!("load = {}", cell.load());
+    cell.store(20);
+    println!("after store = {}", cell.load());
+    let old = cell.swap(30);
+    println!("swap: old={}, new={}", old, cell.load());
+
+    // fetch_update: CAS with a closure (retry loop inside)
+    let res = cell.fetch_update(Relaxed, Relaxed, |cur| {
+        if cur < 100 { Some(cur + 1) } else { None }
+    });
+    println!("fetch_update -> {:?}, now={}", res, cell.load());
+
+    // Works for other Copy types, including pointers:
+    let mut v = 5i32;
+    let p = NonNull::new(&mut v as *mut i32).unwrap();
+    let pcell = AtomicCell::new(Some(p));
+    let got = pcell.load();
+    if let Some(nn) = got { unsafe { *nn.as_ptr() += 1; } }
+    println!("v after AtomicCell<NonNull> = {}", v);
+}
+
+/* ─────────────── 5b) Arc<AtomicCell<T>> across threads ───────────────
+AtomicCell methods take &self and do atomic ops internally, so sharing with Arc is easy.
+*/
+pub fn ex_atomic_cell_threads() {
+    println!("\n== 5b) AtomicCell<T> across threads ==");
+    let sum = Arc::new(AtomicCell::new(0u64));
+    let mut handles = vec![];
+    for _ in 0..4 {
+        let s = sum.clone();
+        handles.push(thread::spawn(move || {
+            for _ in 0..250_000 {
+                // emulate fetch_add via update loop
+                s.fetch_add(1); // (AtomicCell has fetch_add for numeric T)
+            }
+        }));
+    }
+    for h in handles { h.join().unwrap(); }
+    println!("sum = {}", sum.load());
+}
+
+/* Convenience: provide a small extension when the crate version has numeric ops.
+   Recent crossbeam exposes fetch_add/fetch_sub for numeric T; if your version
+   lacks it, you can emulate with fetch_update. */
+trait FetchAdd {
+    fn fetch_add(&self, x: u64) -> u64;
+}
+impl FetchAdd for AtomicCell<u64> {
+    fn fetch_add(&self, x: u64) -> u64 {
+        self.fetch_update(Relaxed, Relaxed, |cur| Some(cur.wrapping_add(x)))
+            .unwrap_or_else(|cur| cur)
+    }
+}
+
+
+/* ───────────────────────────── Docs-style notes ─────────────────────────────
+
+STANDARD ATOMICS
+- Types: AtomicBool, AtomicI*/U*, AtomicPtr<T>, etc. Size matches the underlying type.
+- Basic ops: load(Ordering), store(val, Ordering), swap(val, Ordering),
+             fetch_add/sub/and/or/xor, compare_exchange / compare_exchange_weak.
+
+ORDERINGS (from weakest to strongest)
+- Relaxed: atomicity only. No cross-thread visibility guarantees beyond the op itself.
+  Use for counters/IDs where you don’t read other data guarded by the atomic.
+- Acquire (loads): after an Acquire load **succeeds**, subsequent reads in this thread
+  see writes that were **before** a matching Release store in the other thread.
+- Release (stores): publishes prior writes before the store becomes visible.
+- AcqRel: both sides of a RMW op (e.g., CAS).
+- SeqCst: total global ordering on all SeqCst ops. Easiest but may be slower.
+
+RULES OF THUMB
+- **Counter only** → Relaxed.
+- **Flag + data handoff** → writer uses Release store; reader uses Acquire load.
+- **CAS loop** → success: AcqRel, failure: Acquire (common pattern).
+- **Unsure** → start with SeqCst for correctness, then relax if really needed.
+
+FENCES
+- `fence(Ordering)` adds a memory barrier **without** touching an atomic location.
+  Rarely needed; use when you must separate ordinary memory accesses from the atomic op.
+
+ATOMICPTR
+- Use Release store to publish a fully-initialized object; readers use Acquire load.
+- Manage ownership carefully (who frees the allocation?).
+
+ATOMICCELL<T> (crossbeam)
+- Works for any `T: Copy` (+ a few special cases). API: new, load, store, swap,
+  fetch_update, take, into_inner, etc. Some versions include numeric fetch_add/sub.
+- Internally chooses the best representation (locks if needed for wider types/targets).
+- Easier ergonomics than raw `Atomic*` for small Copy payloads (u64, bool, NonNull, etc).
+- Still obeys memory orderings — the methods accept `Ordering` or specify relaxed defaults.
+
+PITFALLS
+- **Relaxed is not a publish**: if you write data then set a flag with Relaxed, another
+  thread might see the flag but not the data.
+- **Holding references**: Don’t read a pointer atomically and then use it after another
+  thread might have freed it. Pair atomics with ownership protocols (hazard pointers,
+  epochs, RCU) or make sure only one party frees.
+- **ABA problem**: CAS can be fooled if a value changes A→B→A. Use tagged pointers or
+  sequence counters when necessary.
+- **Spin without backoff**: use `std::hint::spin_loop()` in tight CAS loops, or prefer channels/locks when appropriate.
+
+WHEN TO USE ATOMICS VS LOCKS
+- Atomics: simple flags/counters, low-contention single-word state, high-performance data structures by experts.
+- Locks: complex invariants or multi-field state; safer and often fast enough.
+
+CHEAT SHEET
+- Counter (fast):            `fetch_add(1, Relaxed)`
+- Publish data:              `data.store(..., Relaxed); flag.store(true, Release)`
+- Observe published data:    `while !flag.load(Acquire) {}`; then read `data`
+- One-time init (CAS):       `cas(0, new, AcqRel, Acquire)`
+- AtomicCell number bump:    `cell.fetch_update(Relaxed, Relaxed, |x| Some(x+1))`
+- Pointer publish:           `fence(Release); AP.store(ptr, Release)`
+
+*/ 
diff --git a/atomic-docs/src/main.rs b/atomic-docs/src/main.rs
index c6ee920f5f9ecdeba69179c96f59cae7f715f930..0f70aa1d11f595aab09c9ce6651d26b1ca0b73ad 100644
--- a/atomic-docs/src/main.rs
+++ b/atomic-docs/src/main.rs
@@ -1,278 +1,19 @@
-//! Atomics in Rust — std::sync::atomic::Atomic* + crossbeam::atomic::AtomicCell<T>
-//!
-//! TL;DR
-//! - Atomics let threads coordinate **without locks** by reading/writing plain machine words atomically.
-//! - The standard library offers fixed atomic types: AtomicBool, AtomicUsize, AtomicI64, …, AtomicPtr<T>.
-//! - `AtomicCell<T>` (from `crossbeam`) is a convenient wrapper that works for any `T: Copy` (and some Option<NonNull<_>>).
-//! - Memory order matters: use Relaxed for counters, Acquire/Release for handoffs, SeqCst for simplicity (slower).
-//!
-//! This file demonstrates:
-//!  1) Atomic counters with Relaxed
-//!  2) Flags with Acquire/Release
-//!  3) `compare_exchange` patterns (one-time init / CAS loop)
-//!  4) AtomicPtr and fences
-//!  5) AtomicCell<T> ergonomics (load/store/swap/update)
-//!  6) Cheatsheet + pitfalls (in comments)
-
-use std::{
-    ptr::NonNull,
-    sync::{
-        atomic::{
-            fence, AtomicBool, AtomicPtr, AtomicU64, AtomicUsize, Ordering::{self, *}
-        },
-        Arc,
-    },
-    thread,
-    time::Duration,
+use atomic_docs::{
+    ex_acquire_release_flag,
+    ex_atomic_cell_basics,
+    ex_atomic_cell_threads,
+    ex_atomic_ptr_and_fence,
+    ex_compare_exchange,
+    ex_relaxed_counter,
 };
 
-// Crossbeam's AtomicCell:
-use crossbeam::atomic::AtomicCell;
-
-/* ───────────────────────── 1) Counter (Relaxed) ─────────────────────────
-Relaxed operations are fine when you only need a number to be correct,
-not to publish data associated with that number.
-*/
-fn ex_relaxed_counter() {
-    println!("== 1) Relaxed counter ==");
-    let hits = Arc::new(AtomicUsize::new(0));
-    let mut handles = vec![];
-    for _ in 0..8 {
-        let h = hits.clone();
-        handles.push(thread::spawn(move || {
-            for _ in 0..100_000 {
-                h.fetch_add(1, Relaxed);
-            }
-        }));
-    }
-    for h in handles { h.join().unwrap(); }
-    println!("hits = {}", hits.load(Relaxed)); // 800_000
-}
-
-/* ───────────── 2) Flag handoff (Release writer → Acquire reader) ─────────────
-Use a Release store to "publish" data written before it; Acquire load by reader
-to "see" that data. This creates a happens-before edge.
-*/
-fn ex_acquire_release_flag() {
-    println!("\n== 2) Acquire/Release flag (publish data) ==");
-    static READY: AtomicBool = AtomicBool::new(false);
-    static VALUE: AtomicU64  = AtomicU64::new(0);
-
-    let w = thread::spawn(|| {
-        VALUE.store(42, Relaxed);      // write data first
-        READY.store(true, Release);    // publish with Release
-    });
-
-    let r = thread::spawn(|| {
-        // Spin until we observe the flag with Acquire
-        while !READY.load(Acquire) { std::hint::spin_loop(); }
-        // Because of Acquire, we must observe VALUE=42 here
-        let v = VALUE.load(Relaxed);
-        println!("observed VALUE = {}", v);
-    });
-
-    w.join().unwrap();
-    r.join().unwrap();
-}
-
-/* ─────────────── 3) CAS patterns: one-time init & CAS loop ───────────────
-- compare_exchange(old, new, success_order, failure_order) attempts to set atom from old→new.
-- On success returns Ok(old); on failure returns Err(current).
-*/
-fn ex_compare_exchange() {
-    println!("\n== 3) compare_exchange patterns ==");
-    // One-time init (idempotent set from 0 → some id)
-    let id = AtomicUsize::new(0);
-    let my_id = 7;
-    let _ = id.compare_exchange(0, my_id, AcqRel, Acquire).ok();
-    println!("id after one-time init = {}", id.load(Acquire));
-
-    // CAS loop: increment even-only (toy example)
-    let x = AtomicUsize::new(10);
-    loop {
-        let cur = x.load(Relaxed);
-        if cur % 2 == 1 {
-            println!("x is odd; not changing");
-            break;
-        }
-        // propose next even+2
-        match x.compare_exchange_weak(cur, cur + 2, AcqRel, Acquire) {
-            Ok(_) => { println!("x -> {}", x.load(Relaxed)); break; }
-            Err(_) => { std::hint::spin_loop(); } // retry
-        }
-    }
-}
-
-/* ─────────────── 4) AtomicPtr + fences (advanced publish) ───────────────
-Sometimes you publish *pointers*. Use Release on the publishing store and
-Acquire on the consuming load. `fence(Release)` / `fence(Acquire)` can be
-used to separate the atomic op from adjacent ordinary memory accesses.
-*/
-fn ex_atomic_ptr_and_fence() {
-    println!("\n== 4) AtomicPtr & fences ==");
-    #[derive(Debug)]
-    struct Payload { a: u32, b: u32 }
-
-    static PTR: AtomicPtr<Payload> = AtomicPtr::new(std::ptr::null_mut());
-
-    // Producer thread: allocate and publish
-    let t = thread::spawn(|| {
-        let b = Box::new(Payload { a: 1, b: 2 });
-        let raw = Box::into_raw(b);
-        // Ensure prior writes to *raw are visible before we publish the pointer:
-        fence(Release);
-        PTR.store(raw, Release);
-    });
-
-    // Consumer: wait until pointer is non-null, then read it
-    let r = thread::spawn(|| {
-        let mut p;
-        loop {
-            p = PTR.load(Acquire);
-            if !p.is_null() { break; }
-            std::hint::spin_loop();
-        }
-        // Acquire (and the Release fence) ensure we see initialized fields.
-        let val = unsafe { &*p };
-        println!("read via ptr: {:?}", val);
-        // Clean-up: reclaim the Box (single consumer in this toy demo)
-        unsafe { drop(Box::from_raw(p)); }
-        PTR.store(std::ptr::null_mut(), Release);
-    });
-
-    t.join().unwrap();
-    r.join().unwrap();
-}
-
-/* ─────────────────── 5) AtomicCell<T> ergonomics (crossbeam) ───────────────────
-AtomicCell<T> provides load/store/swap/fetch_update for any `T: Copy` (and some niche
-non-Copy via specialized impls). It’s often simpler than juggling specific Atomic* types.
-*/
-fn ex_atomic_cell_basics() {
-    println!("\n== 5) AtomicCell<T> basics ==");
-    let cell = AtomicCell::new(10u32);
-    println!("load = {}", cell.load());
-    cell.store(20);
-    println!("after store = {}", cell.load());
-    let old = cell.swap(30);
-    println!("swap: old={}, new={}", old, cell.load());
-
-    // fetch_update: CAS with a closure (retry loop inside)
-    let res = cell.fetch_update(Relaxed, Relaxed, |cur| {
-        if cur < 100 { Some(cur + 1) } else { None }
-    });
-    println!("fetch_update -> {:?}, now={}", res, cell.load());
-
-    // Works for other Copy types, including pointers:
-    let mut v = 5i32;
-    let p = NonNull::new(&mut v as *mut i32).unwrap();
-    let pcell = AtomicCell::new(Some(p));
-    let got = pcell.load();
-    if let Some(nn) = got { unsafe { *nn.as_ptr() += 1; } }
-    println!("v after AtomicCell<NonNull> = {}", v);
-}
-
-/* ─────────────── 5b) Arc<AtomicCell<T>> across threads ───────────────
-AtomicCell methods take &self and do atomic ops internally, so sharing with Arc is easy.
-*/
-fn ex_atomic_cell_threads() {
-    println!("\n== 5b) AtomicCell<T> across threads ==");
-    let sum = Arc::new(AtomicCell::new(0u64));
-    let mut handles = vec![];
-    for _ in 0..4 {
-        let s = sum.clone();
-        handles.push(thread::spawn(move || {
-            for _ in 0..250_000 {
-                // emulate fetch_add via update loop
-                s.fetch_add(1); // (AtomicCell has fetch_add for numeric T)
-            }
-        }));
-    }
-    for h in handles { h.join().unwrap(); }
-    println!("sum = {}", sum.load());
-}
-
-/* Convenience: provide a small extension when the crate version has numeric ops.
-   Recent crossbeam exposes fetch_add/fetch_sub for numeric T; if your version
-   lacks it, you can emulate with fetch_update. */
-trait FetchAdd {
-    fn fetch_add(&self, x: u64) -> u64;
-}
-impl FetchAdd for AtomicCell<u64> {
-    fn fetch_add(&self, x: u64) -> u64 {
-        self.fetch_update(Relaxed, Relaxed, |cur| Some(cur.wrapping_add(x)))
-            .unwrap_or_else(|cur| cur)
-    }
-}
-
 fn main() {
     ex_relaxed_counter();
     ex_acquire_release_flag();
     ex_compare_exchange();
     ex_atomic_ptr_and_fence();
     ex_atomic_cell_basics();
     ex_atomic_cell_threads();
 
     println!("\n== Cheatsheet (see comments below) ==");
 }
-
-/* ───────────────────────────── Docs-style notes ─────────────────────────────
-
-STANDARD ATOMICS
-- Types: AtomicBool, AtomicI*/U*, AtomicPtr<T>, etc. Size matches the underlying type.
-- Basic ops: load(Ordering), store(val, Ordering), swap(val, Ordering),
-             fetch_add/sub/and/or/xor, compare_exchange / compare_exchange_weak.
-
-ORDERINGS (from weakest to strongest)
-- Relaxed: atomicity only. No cross-thread visibility guarantees beyond the op itself.
-  Use for counters/IDs where you don’t read other data guarded by the atomic.
-- Acquire (loads): after an Acquire load **succeeds**, subsequent reads in this thread
-  see writes that were **before** a matching Release store in the other thread.
-- Release (stores): publishes prior writes before the store becomes visible.
-- AcqRel: both sides of a RMW op (e.g., CAS).
-- SeqCst: total global ordering on all SeqCst ops. Easiest but may be slower.
-
-RULES OF THUMB
-- **Counter only** → Relaxed.
-- **Flag + data handoff** → writer uses Release store; reader uses Acquire load.
-- **CAS loop** → success: AcqRel, failure: Acquire (common pattern).
-- **Unsure** → start with SeqCst for correctness, then relax if really needed.
-
-FENCES
-- `fence(Ordering)` adds a memory barrier **without** touching an atomic location.
-  Rarely needed; use when you must separate ordinary memory accesses from the atomic op.
-
-ATOMICPTR
-- Use Release store to publish a fully-initialized object; readers use Acquire load.
-- Manage ownership carefully (who frees the allocation?).
-
-ATOMICCELL<T> (crossbeam)
-- Works for any `T: Copy` (+ a few special cases). API: new, load, store, swap,
-  fetch_update, take, into_inner, etc. Some versions include numeric fetch_add/sub.
-- Internally chooses the best representation (locks if needed for wider types/targets).
-- Easier ergonomics than raw `Atomic*` for small Copy payloads (u64, bool, NonNull, etc).
-- Still obeys memory orderings — the methods accept `Ordering` or specify relaxed defaults.
-
-PITFALLS
-- **Relaxed is not a publish**: if you write data then set a flag with Relaxed, another
-  thread might see the flag but not the data.
-- **Holding references**: Don’t read a pointer atomically and then use it after another
-  thread might have freed it. Pair atomics with ownership protocols (hazard pointers,
-  epochs, RCU) or make sure only one party frees.
-- **ABA problem**: CAS can be fooled if a value changes A→B→A. Use tagged pointers or
-  sequence counters when necessary.
-- **Spin without backoff**: use `std::hint::spin_loop()` in tight CAS loops, or prefer channels/locks when appropriate.
-
-WHEN TO USE ATOMICS VS LOCKS
-- Atomics: simple flags/counters, low-contention single-word state, high-performance data structures by experts.
-- Locks: complex invariants or multi-field state; safer and often fast enough.
-
-CHEAT SHEET
-- Counter (fast):            `fetch_add(1, Relaxed)`
-- Publish data:              `data.store(..., Relaxed); flag.store(true, Release)`
-- Observe published data:    `while !flag.load(Acquire) {}`; then read `data`
-- One-time init (CAS):       `cas(0, new, AcqRel, Acquire)`
-- AtomicCell number bump:    `cell.fetch_update(Relaxed, Relaxed, |x| Some(x+1))`
-- Pointer publish:           `fence(Release); AP.store(ptr, Release)`
-
-*/ 
diff --git a/box-doc/src/lib.rs b/box-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..e17ff52424139c92dc94472c102b44455118abc5
--- /dev/null
+++ b/box-doc/src/lib.rs
@@ -0,0 +1,91 @@
+//! Simple docs + examples for Box<T>
+
+use std::fmt::Debug;
+
+//
+// Example 1: Owning a simple value
+//
+pub fn example_basic() {
+    let b = Box::new(42); // allocate i32 on the heap
+
+    println!("value = {}", b);      // auto-deref
+    println!("deref  = {}", *b);    // manual deref, moves if not Copy
+}
+
+//
+// Example 2: Recursive data type
+//
+enum List {
+    Node(i32, Box<List>), // recursive type only possible with Box
+    Nil,
+}
+
+pub fn example_recursive() {
+    let list = List::Node(1, Box::new(List::Node(2, Box::new(List::Nil))));
+    match list {
+        List::Node(v, _) => println!("first node = {}", v),
+        List::Nil => println!("empty"),
+    }
+}
+
+//
+// Example 3: Trait objects
+//
+trait Animal {
+    fn speak(&self);
+}
+
+struct Dog;
+impl Animal for Dog {
+    fn speak(&self) { println!("Woof!"); }
+}
+
+struct Cat;
+impl Animal for Cat {
+    fn speak(&self) { println!("Meow!"); }
+}
+
+pub fn example_trait_objects() {
+    let animals: Vec<Box<dyn Animal>> = vec![Box::new(Dog), Box::new(Cat)];
+    for a in animals {
+        a.speak(); // dynamic dispatch
+    }
+}
+
+//
+// Example 4: Borrow without moving
+//
+pub fn example_borrow() {
+    let b = Box::new(String::from("hello"));
+
+    let r: &String = b.as_ref(); // borrow immutably, don’t move out
+    println!("borrow = {}", r);
+
+    // still can use b afterwards
+    println!("again   = {}", b);
+}
+
+//
+// Docs-style comparison (for humans)
+//
+/*
+| `Box<T>`                           | Use case                                      |
+| ---------------------------------- | --------------------------------------------- |
+| Single ownership                   | Exactly one owner of the heap value           |
+| Heap allocation                    | Moves large/recursive data off stack          |
+| Auto cleanup                       | Freed when box is dropped                     |
+| Move on deref (`*b`)               | Moves (unless `Copy`), consumes box           |
+| Borrow (`&*b`, `as_ref`, `as_mut`) | Safe way to inspect/modify without moving     |
+| Thread safety                      | Same as `T` (box doesn’t add sync/atomic)     |
+*/
+
+//
+// Internal view (simplified):
+//
+// pub struct Box<T: ?Sized> {
+//     ptr: Unique<T>, // raw heap pointer with ownership
+// }
+//
+// Drop impl for Box<T> calls drop on value, then deallocates heap memory.
+//
+
diff --git a/box-doc/src/main.rs b/box-doc/src/main.rs
index 95597ccad8b18a0e7fdbad6e71232344fc135720..836f2d6fa46388dcf68a844a01a8d6c39eeab9ea 100644
--- a/box-doc/src/main.rs
+++ b/box-doc/src/main.rs
@@ -1,104 +1,20 @@
-//! Simple docs + examples for Box<T>
-
-use std::fmt::Debug;
-
-//
-// Example 1: Owning a simple value
-//
-fn example_basic() {
-    let b = Box::new(42); // allocate i32 on the heap
-
-    println!("value = {}", b);      // auto-deref
-    println!("deref  = {}", *b);    // manual deref, moves if not Copy
-}
-
-//
-// Example 2: Recursive data type
-//
-enum List {
-    Node(i32, Box<List>), // recursive type only possible with Box
-    Nil,
-}
-
-fn example_recursive() {
-    let list = List::Node(1, Box::new(List::Node(2, Box::new(List::Nil))));
-    match list {
-        List::Node(v, _) => println!("first node = {}", v),
-        List::Nil => println!("empty"),
-    }
-}
-
-//
-// Example 3: Trait objects
-//
-trait Animal {
-    fn speak(&self);
-}
-
-struct Dog;
-impl Animal for Dog {
-    fn speak(&self) { println!("Woof!"); }
-}
-
-struct Cat;
-impl Animal for Cat {
-    fn speak(&self) { println!("Meow!"); }
-}
-
-fn example_trait_objects() {
-    let animals: Vec<Box<dyn Animal>> = vec![Box::new(Dog), Box::new(Cat)];
-    for a in animals {
-        a.speak(); // dynamic dispatch
-    }
-}
-
-//
-// Example 4: Borrow without moving
-//
-fn example_borrow() {
-    let b = Box::new(String::from("hello"));
-
-    let r: &String = b.as_ref(); // borrow immutably, don’t move out
-    println!("borrow = {}", r);
-
-    // still can use b afterwards
-    println!("again   = {}", b);
-}
-
-//
-// Docs-style comparison (for humans)
-//
-/*
-| `Box<T>`                           | Use case                                      |
-| ---------------------------------- | --------------------------------------------- |
-| Single ownership                   | Exactly one owner of the heap value           |
-| Heap allocation                    | Moves large/recursive data off stack          |
-| Auto cleanup                       | Freed when box is dropped                     |
-| Move on deref (`*b`)               | Moves (unless `Copy`), consumes box           |
-| Borrow (`&*b`, `as_ref`, `as_mut`) | Safe way to inspect/modify without moving     |
-| Thread safety                      | Same as `T` (box doesn’t add sync/atomic)     |
-*/
-
-//
-// Internal view (simplified):
-//
-// pub struct Box<T: ?Sized> {
-//     ptr: Unique<T>, // raw heap pointer with ownership
-// }
-//
-// Drop impl for Box<T> calls drop on value, then deallocates heap memory.
-//
+use box_doc::{
+    example_basic,
+    example_recursive,
+    example_trait_objects,
+    example_borrow,
+};
 
 fn main() {
     println!("--- Example 1: Basic ---");
     example_basic();
 
     println!("\n--- Example 2: Recursive ---");
     example_recursive();
 
     println!("\n--- Example 3: Trait objects ---");
     example_trait_objects();
 
     println!("\n--- Example 4: Borrow ---");
     example_borrow();
 }
diff --git a/cell-refcell-doc/src/lib.rs b/cell-refcell-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b7a9e71607caa68983287711db89201002613f0d
--- /dev/null
+++ b/cell-refcell-doc/src/lib.rs
@@ -0,0 +1,97 @@
+use std::cell::{RefCell, Cell};
+
+struct CellCounter {
+    count: Cell<u32>, // interior mutability
+}
+
+impl CellCounter {
+    fn tick(&self) {
+        self.count.set(self.count.get() + 1); // mutate through &self
+    }
+
+    fn get(&self) -> u32 {
+        self.count.get()
+    }
+}
+
+
+struct RefCellCounter {
+    history: RefCell<Vec<u32>>, // interior mutability for a collection
+}
+
+impl RefCellCounter {
+    fn tick(&self) {
+        let mut vec = self.history.borrow_mut(); // runtime-checked mutable borrow
+        let new_val = vec.last().unwrap_or(&0) + 1;
+        vec.push(new_val);
+    }
+
+    fn last(&self) -> u32 {
+        let vec = self.history.borrow(); // runtime-checked immutable borrow
+        *vec.last().unwrap_or(&0)
+    }
+
+    fn all(&self) -> Vec<u32> {
+        self.history.borrow().clone() // clone so we can return
+    }
+}
+pub fn cell_example() {
+    let c = CellCounter { count: Cell::new(0) };
+    c.tick();
+    c.tick();
+    println!("count = {}", c.get());
+}
+
+pub fn refcell_example() {
+    let c = RefCellCounter {
+        history: RefCell::new(vec![]),
+    };
+    c.tick();
+    c.tick();
+    c.tick();
+    println!("Last = {}", c.last());
+    println!("All  = {:?}", c.all());
+}
+
+/* 
+
+| `Cell<T>`                          | `RefCell<T>`                               |
+| ---------------------------------- | ------------------------------------------ |
+| Only for `Copy` or moveable values | Works for any type (like `Vec`, `HashMap`) |
+| Get/Set value only (no refs)       | Borrow refs (`&T` / `&mut T`) at runtime   |
+| Zero overhead, very fast           | Slight runtime cost, may panic if misused  |
+
+
+pub struct Cell<T> {
+    value: UnsafeCell<T>, // wrapper that disables borrow checker
+}
+UnsafeCell<T> is the only legal way in Rust to do “interior mutability” at the compiler level.
+
+Cell::get/set just copies values in and out directly (requires Copy unless you move).
+
+pub struct RefCell<T> {
+    borrow: Cell<BorrowFlag>, // small counter/flag
+    value: UnsafeCell<T>,     // the wrapped value
+}
+
+type BorrowFlag = isize; // in stdlib it’s usually an isize
+// 0     => not borrowed
+// >0    => number of active immutable borrows
+// -1    => mutably borrowed
+
+borrow() increments the counter.
+
+borrow_mut() checks counter == 0, then sets it to -1.
+
+drop of Ref/RefMut decrements/reset the counter.
+
+If rules violated → panic.
+
+So:
+
+Cell<T> = just UnsafeCell<T>, no borrow tracking.
+
+RefCell<T> = UnsafeCell<T> + a borrow counter.
+
+Their runtime borrow-checking is not atomic → two threads could borrow at the same time, breaking safety.
+*/
\ No newline at end of file
diff --git a/cell-refcell-doc/src/main.rs b/cell-refcell-doc/src/main.rs
index 65d02772486009b9b1921a7fe92a5475aad16d52..2cf7fb895994eb7f8762a8f26d3bce570a0f73de 100644
--- a/cell-refcell-doc/src/main.rs
+++ b/cell-refcell-doc/src/main.rs
@@ -1,101 +1,6 @@
-use std::cell::{RefCell, Cell};
-
-struct CellCounter {
-    count: Cell<u32>, // interior mutability
-}
-
-impl CellCounter {
-    fn tick(&self) {
-        self.count.set(self.count.get() + 1); // mutate through &self
-    }
-
-    fn get(&self) -> u32 {
-        self.count.get()
-    }
-}
-
-
-struct RefCellCounter {
-    history: RefCell<Vec<u32>>, // interior mutability for a collection
-}
-
-impl RefCellCounter {
-    fn tick(&self) {
-        let mut vec = self.history.borrow_mut(); // runtime-checked mutable borrow
-        let new_val = vec.last().unwrap_or(&0) + 1;
-        vec.push(new_val);
-    }
-
-    fn last(&self) -> u32 {
-        let vec = self.history.borrow(); // runtime-checked immutable borrow
-        *vec.last().unwrap_or(&0)
-    }
-
-    fn all(&self) -> Vec<u32> {
-        self.history.borrow().clone() // clone so we can return
-    }
-}
+use cell_refcell_doc::{cell_example, refcell_example};
 
 fn main() {
-    let c = CellCounter { count: Cell::new(0) };
-
-    c.tick();
-    c.tick();
-    
-
-    println!("count = {}", c.get()); // 2
-
-    let c = RefCellCounter {
-        history: RefCell::new(vec![]),
-    };
-
-    c.tick();
-    c.tick();
-    c.tick();
-
-    println!("Last = {}", c.last());       // 3
-    println!("All  = {:?}", c.all());      // [1, 2, 3]
+    cell_example();
+    refcell_example();
 }
-
-/* 
-
-| `Cell<T>`                          | `RefCell<T>`                               |
-| ---------------------------------- | ------------------------------------------ |
-| Only for `Copy` or moveable values | Works for any type (like `Vec`, `HashMap`) |
-| Get/Set value only (no refs)       | Borrow refs (`&T` / `&mut T`) at runtime   |
-| Zero overhead, very fast           | Slight runtime cost, may panic if misused  |
-
-
-pub struct Cell<T> {
-    value: UnsafeCell<T>, // wrapper that disables borrow checker
-}
-UnsafeCell<T> is the only legal way in Rust to do “interior mutability” at the compiler level.
-
-Cell::get/set just copies values in and out directly (requires Copy unless you move).
-
-pub struct RefCell<T> {
-    borrow: Cell<BorrowFlag>, // small counter/flag
-    value: UnsafeCell<T>,     // the wrapped value
-}
-
-type BorrowFlag = isize; // in stdlib it’s usually an isize
-// 0     => not borrowed
-// >0    => number of active immutable borrows
-// -1    => mutably borrowed
-
-borrow() increments the counter.
-
-borrow_mut() checks counter == 0, then sets it to -1.
-
-drop of Ref/RefMut decrements/reset the counter.
-
-If rules violated → panic.
-
-So:
-
-Cell<T> = just UnsafeCell<T>, no borrow tracking.
-
-RefCell<T> = UnsafeCell<T> + a borrow counter.
-
-Their runtime borrow-checking is not atomic → two threads could borrow at the same time, breaking safety.
-*/
\ No newline at end of file
diff --git a/closures-doc/src/lib.rs b/closures-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..020687041593100f4c19c57b7a23c5bb57dd4685
--- /dev/null
+++ b/closures-doc/src/lib.rs
@@ -0,0 +1,154 @@
+//! Closures in Rust: extended docs + examples
+//!
+//! Internally, closures are basically structs that hold captured variables
+//! and implement one (or more) of the traits: Fn, FnMut, FnOnce.
+
+pub fn example_basic() {
+    println!("== Example 1: Basic closure ==");
+    let add_one = |x: i32| x + 1;
+    println!("3 + 1 = {}", add_one(3));
+
+    // Rough internal equivalent:
+    struct AddOne;
+    impl AddOne {
+        fn call(&self, x: i32) -> i32 { x + 1 }
+    }
+    let add_one_struct = AddOne;
+    println!("3 + 1 (struct) = {}", add_one_struct.call(3));
+}
+
+pub fn example_capture_by_ref() {
+    println!("\n== Example 2: Capture by reference (&T) ==");
+    let x = 10;
+    let print_x = || println!("x = {}", x);
+    print_x();
+    print_x();
+
+    // Rough internal equivalent:
+    struct PrintX<'a> { x_ref: &'a i32 }
+    impl<'a> PrintX<'a> {
+        fn call(&self) { println!("x = {}", self.x_ref); }
+    }
+    let print_x_struct = PrintX { x_ref: &x };
+    print_x_struct.call();
+}
+
+pub fn example_capture_by_mut() {
+    println!("\n== Example 3: Capture by mutable reference (&mut T) ==");
+    let mut y = 0;
+    let mut inc_y = || { y += 1; println!("y = {}", y); };
+    inc_y();
+    inc_y();
+
+    // Rough internal equivalent:
+    struct IncY<'a> { y_ref: &'a mut i32 }
+    impl<'a> IncY<'a> {
+        fn call(&mut self) {
+            *self.y_ref += 1;
+            println!("y = {}", self.y_ref);
+        }
+    }
+    let mut y2 = 0;
+    let mut inc_y_struct = IncY { y_ref: &mut y2 };
+    inc_y_struct.call();
+    inc_y_struct.call();
+}
+
+pub fn example_capture_by_move() {
+    println!("\n== Example 4: Capture by move (T, owned) ==");
+    let s = String::from("owned");
+    let consume_s = move || println!("consumed: {}", s);
+    consume_s();
+
+    // Rough internal equivalent:
+    struct ConsumeS { s: String }
+    impl ConsumeS {
+        fn call_once(self) { println!("consumed: {}", self.s); }
+    }
+    let consume_s_struct = ConsumeS { s: String::from("owned2") };
+    consume_s_struct.call_once(); // can only call once
+}
+
+pub fn example_fn_traits() {
+    println!("\n== Example 5: Fn, FnMut, FnOnce traits ==");
+    fn call_fn<F: Fn()>(f: F) { f(); }
+    fn call_fn_mut<F: FnMut()>(mut f: F) { f(); }
+    fn call_fn_once<F: FnOnce()>(f: F) { f(); }
+
+    let x = 5;
+    let closure_fn = || println!("Fn sees x = {}", x);
+    call_fn(closure_fn);
+
+    let mut y = 0;
+    let closure_fnmut = || { y += 1; println!("FnMut increments y = {}", y); };
+    call_fn_mut(closure_fnmut);
+
+    let s = String::from("take");
+    let closure_fnonce = move || println!("FnOnce takes s = {}", s);
+    call_fn_once(closure_fnonce);
+}
+
+pub fn example_returning_closure() {
+    println!("\n== Example 6: Returning closures ==");
+    fn make_adder(n: i32) -> impl Fn(i32) -> i32 {
+        move |x| x + n // capture n by value
+    }
+    let add10 = make_adder(10);
+    println!("add10(5) = {}", add10(5));
+
+    // Rough internal equivalent:
+    struct Adder { n: i32 }
+    impl Adder {
+        fn call(&self, x: i32) -> i32 { x + self.n }
+    }
+    let adder_struct = Adder { n: 10 };
+    println!("adder_struct.call(5) = {}", adder_struct.call(5));
+}
+
+pub fn example_iterators() {
+    println!("\n== Example 7: Closures in iterators ==");
+    let nums = vec![1, 2, 3, 4];
+
+    let squares: Vec<_> = nums.iter().map(|x| x * x).collect();
+    println!("squares = {:?}", squares);
+
+    // Equivalent: Map holds a closure struct internally
+    struct Square;
+    impl Square {
+        fn call(&self, x: &i32) -> i32 { x * x }
+    }
+    let squares2: Vec<_> = vec![1, 2, 3, 4].iter().map(|x| Square.call(x)).collect();
+    println!("squares (manual struct) = {:?}", squares2);
+}
+
+
+/*
+Docs-style notes:
+
+How closures are built internally:
+- Each closure becomes an anonymous compiler-generated struct.
+- Captured variables become fields in that struct.
+- The struct implements one or more traits: Fn, FnMut, FnOnce.
+- Which trait is implemented depends on how captures happen:
+  * Capture by &T       -> implements Fn
+  * Capture by &mut T   -> implements FnMut (and FnOnce)
+  * Capture by move (T) -> implements FnOnce (and maybe FnMut/Fn if Copy)
+- Calling the closure is just calling the `call` method on that hidden struct.
+
+Examples:
+| Closure                   | Internal struct-like form             | Trait bound |
+|----------------------------|---------------------------------------|-------------|
+| let c = || println!(x);    | struct C { x_ref: &i32 }              | Fn          |
+| let mut c = || { y += 1; } | struct C { y_ref: &mut i32 }          | FnMut       |
+| let c = move || println!(s); | struct C { s: String } (owned)      | FnOnce      |
+
+Closures vs functions:
+- Functions: fixed type, no captures.
+- Closures: may capture environment, so type is unique and inferred.
+- Both can be used where Fn traits are expected.
+
+Performance:
+- Zero-cost abstraction: closure structs are monomorphized like generics.
+- No runtime overhead compared to writing the struct manually.
+
+*/
diff --git a/closures-doc/src/main.rs b/closures-doc/src/main.rs
index 1ed2dd2a9e1a358c5ea2a73a848ad57f75fe3c33..db78cf4d98063d9e809a02462e4549915c527de1 100644
--- a/closures-doc/src/main.rs
+++ b/closures-doc/src/main.rs
@@ -1,163 +1,19 @@
-//! Closures in Rust: extended docs + examples
-//!
-//! Internally, closures are basically structs that hold captured variables
-//! and implement one (or more) of the traits: Fn, FnMut, FnOnce.
-
-fn example_basic() {
-    println!("== Example 1: Basic closure ==");
-    let add_one = |x: i32| x + 1;
-    println!("3 + 1 = {}", add_one(3));
-
-    // Rough internal equivalent:
-    struct AddOne;
-    impl AddOne {
-        fn call(&self, x: i32) -> i32 { x + 1 }
-    }
-    let add_one_struct = AddOne;
-    println!("3 + 1 (struct) = {}", add_one_struct.call(3));
-}
-
-fn example_capture_by_ref() {
-    println!("\n== Example 2: Capture by reference (&T) ==");
-    let x = 10;
-    let print_x = || println!("x = {}", x);
-    print_x();
-    print_x();
-
-    // Rough internal equivalent:
-    struct PrintX<'a> { x_ref: &'a i32 }
-    impl<'a> PrintX<'a> {
-        fn call(&self) { println!("x = {}", self.x_ref); }
-    }
-    let print_x_struct = PrintX { x_ref: &x };
-    print_x_struct.call();
-}
-
-fn example_capture_by_mut() {
-    println!("\n== Example 3: Capture by mutable reference (&mut T) ==");
-    let mut y = 0;
-    let mut inc_y = || { y += 1; println!("y = {}", y); };
-    inc_y();
-    inc_y();
-
-    // Rough internal equivalent:
-    struct IncY<'a> { y_ref: &'a mut i32 }
-    impl<'a> IncY<'a> {
-        fn call(&mut self) {
-            *self.y_ref += 1;
-            println!("y = {}", self.y_ref);
-        }
-    }
-    let mut y2 = 0;
-    let mut inc_y_struct = IncY { y_ref: &mut y2 };
-    inc_y_struct.call();
-    inc_y_struct.call();
-}
-
-fn example_capture_by_move() {
-    println!("\n== Example 4: Capture by move (T, owned) ==");
-    let s = String::from("owned");
-    let consume_s = move || println!("consumed: {}", s);
-    consume_s();
-
-    // Rough internal equivalent:
-    struct ConsumeS { s: String }
-    impl ConsumeS {
-        fn call_once(self) { println!("consumed: {}", self.s); }
-    }
-    let consume_s_struct = ConsumeS { s: String::from("owned2") };
-    consume_s_struct.call_once(); // can only call once
-}
-
-fn example_fn_traits() {
-    println!("\n== Example 5: Fn, FnMut, FnOnce traits ==");
-    fn call_fn<F: Fn()>(f: F) { f(); }
-    fn call_fn_mut<F: FnMut()>(mut f: F) { f(); }
-    fn call_fn_once<F: FnOnce()>(f: F) { f(); }
-
-    let x = 5;
-    let closure_fn = || println!("Fn sees x = {}", x);
-    call_fn(closure_fn);
-
-    let mut y = 0;
-    let closure_fnmut = || { y += 1; println!("FnMut increments y = {}", y); };
-    call_fn_mut(closure_fnmut);
-
-    let s = String::from("take");
-    let closure_fnonce = move || println!("FnOnce takes s = {}", s);
-    call_fn_once(closure_fnonce);
-}
-
-fn example_returning_closure() {
-    println!("\n== Example 6: Returning closures ==");
-    fn make_adder(n: i32) -> impl Fn(i32) -> i32 {
-        move |x| x + n // capture n by value
-    }
-    let add10 = make_adder(10);
-    println!("add10(5) = {}", add10(5));
-
-    // Rough internal equivalent:
-    struct Adder { n: i32 }
-    impl Adder {
-        fn call(&self, x: i32) -> i32 { x + self.n }
-    }
-    let adder_struct = Adder { n: 10 };
-    println!("adder_struct.call(5) = {}", adder_struct.call(5));
-}
-
-fn example_iterators() {
-    println!("\n== Example 7: Closures in iterators ==");
-    let nums = vec![1, 2, 3, 4];
-
-    let squares: Vec<_> = nums.iter().map(|x| x * x).collect();
-    println!("squares = {:?}", squares);
-
-    // Equivalent: Map holds a closure struct internally
-    struct Square;
-    impl Square {
-        fn call(&self, x: &i32) -> i32 { x * x }
-    }
-    let squares2: Vec<_> = vec![1, 2, 3, 4].iter().map(|x| Square.call(x)).collect();
-    println!("squares (manual struct) = {:?}", squares2);
-}
+use closures_doc::{
+    example_basic,
+    example_capture_by_ref,
+    example_capture_by_mut,
+    example_capture_by_move,
+    example_fn_traits,
+    example_returning_closure,
+    example_iterators,
+};
 
 fn main() {
     example_basic();
     example_capture_by_ref();
     example_capture_by_mut();
     example_capture_by_move();
     example_fn_traits();
     example_returning_closure();
     example_iterators();
 }
-
-/*
-Docs-style notes:
-
-How closures are built internally:
-- Each closure becomes an anonymous compiler-generated struct.
-- Captured variables become fields in that struct.
-- The struct implements one or more traits: Fn, FnMut, FnOnce.
-- Which trait is implemented depends on how captures happen:
-  * Capture by &T       -> implements Fn
-  * Capture by &mut T   -> implements FnMut (and FnOnce)
-  * Capture by move (T) -> implements FnOnce (and maybe FnMut/Fn if Copy)
-- Calling the closure is just calling the `call` method on that hidden struct.
-
-Examples:
-| Closure                   | Internal struct-like form             | Trait bound |
-|----------------------------|---------------------------------------|-------------|
-| let c = || println!(x);    | struct C { x_ref: &i32 }              | Fn          |
-| let mut c = || { y += 1; } | struct C { y_ref: &mut i32 }          | FnMut       |
-| let c = move || println!(s); | struct C { s: String } (owned)      | FnOnce      |
-
-Closures vs functions:
-- Functions: fixed type, no captures.
-- Closures: may capture environment, so type is unique and inferred.
-- Both can be used where Fn traits are expected.
-
-Performance:
-- Zero-cost abstraction: closure structs are monomorphized like generics.
-- No runtime overhead compared to writing the struct manually.
-
-*/
diff --git a/desclarative-macros-doc/src/lib.rs b/desclarative-macros-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..dc0ec3102d37bf198b5fd4071eec87f50600d6b4
--- /dev/null
+++ b/desclarative-macros-doc/src/lib.rs
@@ -0,0 +1,255 @@
+//! Declarative Macros in Rust — mini-docs + runnable examples
+//!
+//! TL;DR
+//! - `macro_rules! name { (pattern) => { expansion } ... }`
+//! - Match token patterns at *compile time* and expand into Rust code.
+//! - Captures use *fragment specifiers* (`$x:expr`, `$i:ident`, `$tt:tt`, …).
+//! - Repetition: `$( ... )*`, `+`, `?` (with optional separators like `,` or `;`).
+//! - Macros are hygienic; identifiers in expansions don’t accidentally collide.
+//! - `$crate` points to the defining crate (works across crate boundaries).
+//!
+//! This file demonstrates:
+//!  1) Basics & syntax sugar
+//!  2) Fragment specifiers you’ll actually use
+//!  3) Repetitions, separators, optional trailing comma
+//!  4) Overloading by pattern (macro arms) + dispatch tricks
+//!  5) Counting arguments (no runtime cost)
+//!  6) Container builders: `vec!` / `hashmap!`-style
+//!  7) TT-muncher recursion (tiny DSL)
+//!  8) Hygiene & `$crate`
+//!  9) API design tips (at bottom)
+
+use std::collections::HashMap;
+
+/* ────────────────────────────── 1) BASICS ────────────────────────────── */
+
+// Simple forwarding wrapper: forward to println! while preserving formatting.
+#[macro_export]
+macro_rules! mprintln {
+    ($($arg:tt)*) => {
+        println!($($arg)*)
+    };
+}
+
+/* ───────────────── 2) FRAGMENT SPECIFIERS (common ones) ─────────────────
+A few of the many specifiers:
+
+- ident     → an identifier (e.g., foo, Bar)
+- path      → a path (e.g., std::io::Result, crate::module::Type)
+- ty        → a type (e.g., Option<i32>, &str)
+- expr      → an expression (e.g., 1+2, some_call())
+- pat       → a pattern (e.g., Some(x), 3..=9)
+- stmt      → a statement
+- block     → a block `{ ... }`
+- item      → an item (fn, struct, impl, etc.)
+- lifetime  → a lifetime 'a
+- meta      → meta item inside attributes (e.g., path = "x")
+- tt        → a single token tree (most general; building block for munchers)
+*/
+
+// Tiny demo: accept different fragments and print a tag at runtime.
+#[macro_export]
+macro_rules! show_kind {
+    ($x:ident)    => { mprintln!("ident: {}", stringify!($x)); };
+    ($x:path)     => { mprintln!("path:  {}", stringify!($x)); };
+    ($x:ty)       => { mprintln!("type:  {}", stringify!($x)); };
+    ($x:expr)     => { mprintln!("expr:  {:?}", ($x)); };
+    ($x:pat)      => { mprintln!("pat:   {}", stringify!($x)); };
+    ($b:block)    => { mprintln!("block: {}", stringify!($b)); };
+    ($m:meta)     => { mprintln!("meta:  {}", stringify!($m)); };
+    ($t:tt)       => { mprintln!("tt:    {}", stringify!($t)); };
+}
+
+/* ─────────────── 3) REPETITIONS, SEPARATORS, TRAILING COMMA ─────────────── */
+
+// Collect comma-separated expressions into a Vec.
+//  - `$( $x:expr ),*`   = zero-or-more, separated by commas
+//  - `$(,)?`            = optional trailing comma
+#[macro_export]
+macro_rules! make_vec {
+    ( $( $x:expr ),* $(,)? ) => {{
+        let mut v = Vec::new();
+        $(
+            v.push($x);
+        )*
+        v
+    }};
+}
+
+// Key=>value hashmap literal (like maplit::hashmap! but minimal).
+#[macro_export]
+macro_rules! make_map {
+    ( $( $k:expr => $v:expr ),* $(,)? ) => {{
+        let mut m = ::std::collections::HashMap::new();
+        $(
+            m.insert($k, $v);
+        )*
+        m
+    }};
+}
+
+/* ──────────────── 4) OVERLOADING BY PATTERN (macro arms) ──────────────── */
+
+// Same macro name; different arms select by first token/shape.
+#[macro_export]
+macro_rules! over {
+    // one expression
+    ($x:expr) => { mprintln!("one expr = {:?}", $x); };
+    // two expressions with comma
+    ($a:expr, $b:expr) => { mprintln!("two exprs = {:?}, {:?}", $a, $b); };
+    // named form: key = expr
+    ($name:ident = $x:expr) => { mprintln!("named {} = {:?}", stringify!($name), $x); };
+}
+
+/* ───────────────────────── 5) COUNTING ARGUMENTS ─────────────────────────
+Classic trick: map each argument to `()`, then take the array length *at compile time*.
+We need a helper that replaces any token-tree with `()`.
+*/
+#[macro_export]
+macro_rules! __replace_unit { ($_t:tt) => { () } }
+
+#[macro_export]
+macro_rules! count_args {
+    ( $( $xs:tt ),* $(,)? ) => {
+        <[()]>::len(&[ $( $crate::__replace_unit!($xs) ),* ])
+    }
+}
+
+/* ────────────────────── 6) CONTAINER BUILDER EXAMPLES ────────────────────── */
+
+// Re-implement a tiny subset of `vec!` (already in std, for teaching).
+#[macro_export]
+macro_rules! tiny_vec {
+    // vec![elem; n] form
+    ($elem:expr ; $n:expr) => {{
+        let n = $n;
+        let mut v = ::std::vec::Vec::with_capacity(n as usize);
+        v.resize(n as usize, $elem);
+        v
+    }};
+    // vec![a, b, c] form
+    ( $( $x:expr ),* $(,)? ) => {{
+        let mut v = ::std::vec::Vec::new();
+        $( v.push($x); )*
+        v
+    }};
+}
+
+// HashMap builder with inferred types.
+#[macro_export]
+macro_rules! hashmap {
+    ( $( $k:expr => $v:expr ),* $(,)? ) => {{
+        let mut m = ::std::collections::HashMap::new();
+        $( m.insert($k, $v); )*
+        m
+    }}
+}
+
+/* ──────────────────────── 7) TT-MUNCHER (recursive parse) ────────────────────────
+We’ll parse a tiny "command list" DSL and produce code:
+    cmds! { add 3; add 4; sub 1; }
+expands to runtime code computing (((0 + 3) + 4) - 1).
+
+Pattern: a recursive macro that "eats" tokens from the left until input is empty.
+*/
+
+#[macro_export]
+macro_rules! cmds {
+    // Entry point: start with accumulator = 0
+    ( $($toks:tt)* ) => { cmds!(@acc 0 ; $($toks)* ) };
+
+    // When input is empty -> yield the accumulator expr
+    (@acc $acc:expr ; ) => { $acc };
+
+    // Match `add <expr>; ...`
+    (@acc $acc:expr ; add $x:expr ; $($rest:tt)* ) => {
+        cmds!(@acc ($acc + ($x)) ; $($rest)* )
+    };
+
+    // Match `sub <expr>; ...`
+    (@acc $acc:expr ; sub $x:expr ; $($rest:tt)* ) => {
+        cmds!(@acc ($acc - ($x)) ; $($rest)* )
+    };
+
+    // Fallback: error if unknown token
+    (@acc $acc:expr ; $bad:tt $($rest:tt)* ) => {
+        compile_error!(concat!("cmds!: unexpected token: ", stringify!($bad)));
+    };
+}
+
+/* ─────────────────────────── 8) HYGIENE & $crate ───────────────────────────
+- Hygiene: identifiers introduced in the macro don’t accidentally capture or clash
+  with variables at call-site.
+- `$crate`: resolves to the defining crate, so paths work from dependents.
+*/
+
+// A "debug" macro that *creates a binding* internally (won’t clash with caller's).
+#[macro_export] // pretend we export; `$crate` would point back here if this were a library
+macro_rules! my_debug {
+    ($e:expr) => {{
+        // This `__val` is hygienic: distinct from any `__val` in caller code.
+        let __val = &$e;
+        $crate::mprintln!("[{}:{}] {} = {:?}", file!(), line!(), stringify!($e), __val);
+        __val
+    }};
+}
+
+/* ─────────────────────────────── EXAMPLES ─────────────────────────────── */
+
+
+/* ────────────────────────────── DOCS NOTES ──────────────────────────────
+
+MENTAL MODEL / “INTERNALS”
+- Declarative macros are *compile-time* pattern matchers. They do not run at runtime and allocate no memory.
+- The compiler tokenizes your source into token trees (TTs). `macro_rules!` matches those TTs against your arms.
+- An arm that matches expands to tokens which are then parsed as Rust and compiled normally.
+- Hygiene: new identifiers created inside the macro expansion don’t capture caller bindings (and vice versa).
+- `$crate`: resolves to the crate where the macro is defined, so paths inside expansions remain correct when used from other crates.
+
+COMMON FRAGMENT SPECIFIERS
+- `$i:ident`, `$p:path`, `$t:ty`, `$e:expr`, `$pat:pat`, `$s:stmt`, `$b:block`, `$it:item`, `$l:lifetime`, `$m:meta`, `$tt:tt`.
+- `$tt` is the most general; use it for recursive (tt-muncher) designs when other fragments are too restrictive.
+
+REPETITIONS
+- `$( PATTERN ),*`  → zero-or-more items separated by commas.
+- `$( PATTERN ),+`  → one-or-more.
+- `$( PATTERN )?`   → optional (0 or 1).
+- Add separators like `;` or `,` between the parens.
+- Optional trailing separator: append `$(,)?` or `$(;)?`.
+
+OVERLOADING / DISPATCH
+- Provide multiple arms ordered from most-specific to most-general; the first match wins.
+- A catch-all arm with `$tt:tt` is handy for helpful `compile_error!`.
+
+COUNTING ARGUMENTS (TRICK)
+- Map each argument to `()` and measure slice length:
+  `<[()]>::len(&[ $( __replace_unit!($x) ),* ])`.
+- Useful for choosing different expansions based on arity (with `macro_rules!` recursion).
+
+TT-MUNCHER PATTERN
+- For simple DSLs, write a recursive macro:
+  - Keep an accumulator (`@acc`) nonterminal.
+  - Consume tokens left-to-right, transforming the accumulator.
+  - End on empty input.
+
+HYGIENE & `$crate`
+- Don’t rely on caller’s local names; create your own bindings freely—they won’t clash.
+- Use `$crate::path::to::item` inside exported macros so referenced items resolve from the def crate.
+
+SCOPING / EXPORT
+- Macros live in the module system. Invoke them after they’re visible (same module, `pub use`, or `#[macro_export]`).
+- `#[macro_export]` places a macro at the crate root for downstream users; prefer re-exporting with `pub use` for namespacing.
+
+DESIGN TIPS
+- Keep expansions expression-based when possible: users can write `let x = mac!(...);`.
+- Accept both with and without trailing comma: `$(,)?` improves ergonomics.
+- For builders, prefer using fully qualified std paths in expansions (`::std::vec::Vec`) to avoid surprises.
+- Provide helpful compile-time errors with `compile_error!(...)` on bad inputs.
+- Avoid parsing *Rust* in macros you don’t need to—lean on fragments (`expr`, `ty`, `path`) rather than `tt` when possible.
+
+LIMITATIONS
+- Declarative macros can’t perform arbitrary computation; they manipulate tokens.
+- No partial identifier construction on stable (avoid trying to “concatenate” idents—prefer `match`/traits/regular code).
+- For advanced compile-time logic, consider `proc_macro` (procedural macros).
+
+*/ 
diff --git a/desclarative-macros-doc/src/main.rs b/desclarative-macros-doc/src/main.rs
index 6246d29948ea7377fcb82d2abdf74ec32e4a2d84..a07176f05bbcaa35059d3d753e4f411b8758d2d4 100644
--- a/desclarative-macros-doc/src/main.rs
+++ b/desclarative-macros-doc/src/main.rs
@@ -1,298 +1,57 @@
-//! Declarative Macros in Rust — mini-docs + runnable examples
-//!
-//! TL;DR
-//! - `macro_rules! name { (pattern) => { expansion } ... }`
-//! - Match token patterns at *compile time* and expand into Rust code.
-//! - Captures use *fragment specifiers* (`$x:expr`, `$i:ident`, `$tt:tt`, …).
-//! - Repetition: `$( ... )*`, `+`, `?` (with optional separators like `,` or `;`).
-//! - Macros are hygienic; identifiers in expansions don’t accidentally collide.
-//! - `$crate` points to the defining crate (works across crate boundaries).
-//!
-//! This file demonstrates:
-//!  1) Basics & syntax sugar
-//!  2) Fragment specifiers you’ll actually use
-//!  3) Repetitions, separators, optional trailing comma
-//!  4) Overloading by pattern (macro arms) + dispatch tricks
-//!  5) Counting arguments (no runtime cost)
-//!  6) Container builders: `vec!` / `hashmap!`-style
-//!  7) TT-muncher recursion (tiny DSL)
-//!  8) Hygiene & `$crate`
-//!  9) API design tips (at bottom)
-
 use std::collections::HashMap;
-
-/* ────────────────────────────── 1) BASICS ────────────────────────────── */
-
-// Simple forwarding wrapper: forward to println! while preserving formatting.
-macro_rules! mprintln {
-    ($($arg:tt)*) => {
-        println!($($arg)*)
-    };
-}
-
-/* ───────────────── 2) FRAGMENT SPECIFIERS (common ones) ─────────────────
-A few of the many specifiers:
-
-- ident     → an identifier (e.g., foo, Bar)
-- path      → a path (e.g., std::io::Result, crate::module::Type)
-- ty        → a type (e.g., Option<i32>, &str)
-- expr      → an expression (e.g., 1+2, some_call())
-- pat       → a pattern (e.g., Some(x), 3..=9)
-- stmt      → a statement
-- block     → a block `{ ... }`
-- item      → an item (fn, struct, impl, etc.)
-- lifetime  → a lifetime 'a
-- meta      → meta item inside attributes (e.g., path = "x")
-- tt        → a single token tree (most general; building block for munchers)
-*/
-
-// Tiny demo: accept different fragments and print a tag at runtime.
-macro_rules! show_kind {
-    ($x:ident)    => { mprintln!("ident: {}", stringify!($x)); };
-    ($x:path)     => { mprintln!("path:  {}", stringify!($x)); };
-    ($x:ty)       => { mprintln!("type:  {}", stringify!($x)); };
-    ($x:expr)     => { mprintln!("expr:  {:?}", ($x)); };
-    ($x:pat)      => { mprintln!("pat:   {}", stringify!($x)); };
-    ($b:block)    => { mprintln!("block: {}", stringify!($b)); };
-    ($m:meta)     => { mprintln!("meta:  {}", stringify!($m)); };
-    ($t:tt)       => { mprintln!("tt:    {}", stringify!($t)); };
-}
-
-/* ─────────────── 3) REPETITIONS, SEPARATORS, TRAILING COMMA ─────────────── */
-
-// Collect comma-separated expressions into a Vec.
-//  - `$( $x:expr ),*`   = zero-or-more, separated by commas
-//  - `$(,)?`            = optional trailing comma
-macro_rules! make_vec {
-    ( $( $x:expr ),* $(,)? ) => {{
-        let mut v = Vec::new();
-        $(
-            v.push($x);
-        )*
-        v
-    }};
-}
-
-// Key=>value hashmap literal (like maplit::hashmap! but minimal).
-macro_rules! make_map {
-    ( $( $k:expr => $v:expr ),* $(,)? ) => {{
-        let mut m = ::std::collections::HashMap::new();
-        $(
-            m.insert($k, $v);
-        )*
-        m
-    }};
-}
-
-/* ──────────────── 4) OVERLOADING BY PATTERN (macro arms) ──────────────── */
-
-// Same macro name; different arms select by first token/shape.
-macro_rules! over {
-    // one expression
-    ($x:expr) => { mprintln!("one expr = {:?}", $x); };
-    // two expressions with comma
-    ($a:expr, $b:expr) => { mprintln!("two exprs = {:?}, {:?}", $a, $b); };
-    // named form: key = expr
-    ($name:ident = $x:expr) => { mprintln!("named {} = {:?}", stringify!($name), $x); };
-}
-
-/* ───────────────────────── 5) COUNTING ARGUMENTS ─────────────────────────
-Classic trick: map each argument to `()`, then take the array length *at compile time*.
-We need a helper that replaces any token-tree with `()`.
-*/
-macro_rules! __replace_unit { ($_t:tt) => { () } }
-
-macro_rules! count_args {
-    ( $( $xs:tt ),* $(,)? ) => {
-        <[()]>::len(&[ $( __replace_unit!($xs) ),* ])
-    }
-}
-
-/* ────────────────────── 6) CONTAINER BUILDER EXAMPLES ────────────────────── */
-
-// Re-implement a tiny subset of `vec!` (already in std, for teaching).
-macro_rules! tiny_vec {
-    // vec![elem; n] form
-    ($elem:expr ; $n:expr) => {{
-        let n = $n;
-        let mut v = ::std::vec::Vec::with_capacity(n as usize);
-        v.resize(n as usize, $elem);
-        v
-    }};
-    // vec![a, b, c] form
-    ( $( $x:expr ),* $(,)? ) => {{
-        let mut v = ::std::vec::Vec::new();
-        $( v.push($x); )*
-        v
-    }};
-}
-
-// HashMap builder with inferred types.
-macro_rules! hashmap {
-    ( $( $k:expr => $v:expr ),* $(,)? ) => {{
-        let mut m = ::std::collections::HashMap::new();
-        $( m.insert($k, $v); )*
-        m
-    }}
-}
-
-/* ──────────────────────── 7) TT-MUNCHER (recursive parse) ────────────────────────
-We’ll parse a tiny "command list" DSL and produce code:
-    cmds! { add 3; add 4; sub 1; }
-expands to runtime code computing (((0 + 3) + 4) - 1).
-
-Pattern: a recursive macro that "eats" tokens from the left until input is empty.
-*/
-
-macro_rules! cmds {
-    // Entry point: start with accumulator = 0
-    ( $($toks:tt)* ) => { cmds!(@acc 0 ; $($toks)* ) };
-
-    // When input is empty -> yield the accumulator expr
-    (@acc $acc:expr ; ) => { $acc };
-
-    // Match `add <expr>; ...`
-    (@acc $acc:expr ; add $x:expr ; $($rest:tt)* ) => {
-        cmds!(@acc ($acc + ($x)) ; $($rest)* )
-    };
-
-    // Match `sub <expr>; ...`
-    (@acc $acc:expr ; sub $x:expr ; $($rest:tt)* ) => {
-        cmds!(@acc ($acc - ($x)) ; $($rest)* )
-    };
-
-    // Fallback: error if unknown token
-    (@acc $acc:expr ; $bad:tt $($rest:tt)* ) => {
-        compile_error!(concat!("cmds!: unexpected token: ", stringify!($bad)));
-    };
-}
-
-/* ─────────────────────────── 8) HYGIENE & $crate ───────────────────────────
-- Hygiene: identifiers introduced in the macro don’t accidentally capture or clash
-  with variables at call-site.
-- `$crate`: resolves to the defining crate, so paths work from dependents.
-*/
-
-// A "debug" macro that *creates a binding* internally (won’t clash with caller's).
-#[macro_export] // pretend we export; `$crate` would point back here if this were a library
-macro_rules! my_debug {
-    ($e:expr) => {{
-        // This `__val` is hygienic: distinct from any `__val` in caller code.
-        let __val = &$e;
-        $crate::mprintln!("[{}:{}] {} = {:?}", file!(), line!(), stringify!($e), __val);
-        __val
-    }};
-}
-
-/* ─────────────────────────────── EXAMPLES ─────────────────────────────── */
+use rust_desclarative_macros_doc::{
+    mprintln, show_kind, make_vec, make_map, over, count_args, tiny_vec, hashmap, cmds, my_debug,
+};
 
 fn main() {
     mprintln!("== 1) basics");
     mprintln!("hello {}", "macros");
 
     mprintln!("\n== 2) fragment specifiers");
     show_kind!(foo);                     // ident
     show_kind!(std::collections::HashMap::<i32, i32>); // path
     show_kind!(Option<Result<i32, ()>>); // ty
     show_kind!(1 + 2 * 3);               // expr
     show_kind!({ let z = 1; z + 1 });    // block
     show_kind!(cfg(feature = "x"));      // meta
     show_kind!(<T as Into<U>>::into);    // tt (generic path)
 
     mprintln!("\n== 3) repetitions / separators / trailing comma");
     let a = make_vec![10, 20, 30,];
     mprintln!("make_vec -> {:?}", a);
     let m = make_map!{
         "a" => 1,
         "b" => 2,
     };
     mprintln!("make_map -> {:?}", m);
 
     mprintln!("\n== 4) overloading by pattern");
     over!(123);
     over!(10, 20);
     over!(answer = 42);
 
     mprintln!("\n== 5) count args");
     mprintln!("count() 0 => {}", count_args![]);
     mprintln!("count() 3 => {}", count_args![a, b, c]);
     mprintln!("count() 5 => {}", count_args![1, (x, y), {3}, foo, bar]);
 
     mprintln!("\n== 6) container builders");
     let v1 = tiny_vec![1, 2, 3];
     let v2 = tiny_vec![9; 4];
     mprintln!("tiny_vec lits     -> {:?}", v1);
     mprintln!("tiny_vec repeat   -> {:?}", v2);
     let hm: HashMap<&'static str, i32> = hashmap!{ "x" => 1, "y" => 2 };
     mprintln!("hashmap -> {:?}", hm);
 
     mprintln!("\n== 7) tt-muncher DSL");
     let result = cmds! { add 3; add 4; sub 1; add (2*2); };
-    mprintln!("cmds! result = {}", result); // (((0+3)+4)-1)+(2*2) = 10
+    mprintln!("cmds! result = {}", result);
 
     mprintln!("\n== 8) hygiene & $crate");
-    let __val = 999; // try to collide with internal name inside my_debug! (won't)
+    let __val = 999;
     let x = 123;
     let got = my_debug!(x * 2);
     mprintln!("my_debug returned {}", got);
 
-    // Bonus: show that optional trailing commas are accepted
     let _ok = make_vec![ "a", "b", "c", ];
 }
-
-/* ────────────────────────────── DOCS NOTES ──────────────────────────────
-
-MENTAL MODEL / “INTERNALS”
-- Declarative macros are *compile-time* pattern matchers. They do not run at runtime and allocate no memory.
-- The compiler tokenizes your source into token trees (TTs). `macro_rules!` matches those TTs against your arms.
-- An arm that matches expands to tokens which are then parsed as Rust and compiled normally.
-- Hygiene: new identifiers created inside the macro expansion don’t capture caller bindings (and vice versa).
-- `$crate`: resolves to the crate where the macro is defined, so paths inside expansions remain correct when used from other crates.
-
-COMMON FRAGMENT SPECIFIERS
-- `$i:ident`, `$p:path`, `$t:ty`, `$e:expr`, `$pat:pat`, `$s:stmt`, `$b:block`, `$it:item`, `$l:lifetime`, `$m:meta`, `$tt:tt`.
-- `$tt` is the most general; use it for recursive (tt-muncher) designs when other fragments are too restrictive.
-
-REPETITIONS
-- `$( PATTERN ),*`  → zero-or-more items separated by commas.
-- `$( PATTERN ),+`  → one-or-more.
-- `$( PATTERN )?`   → optional (0 or 1).
-- Add separators like `;` or `,` between the parens.
-- Optional trailing separator: append `$(,)?` or `$(;)?`.
-
-OVERLOADING / DISPATCH
-- Provide multiple arms ordered from most-specific to most-general; the first match wins.
-- A catch-all arm with `$tt:tt` is handy for helpful `compile_error!`.
-
-COUNTING ARGUMENTS (TRICK)
-- Map each argument to `()` and measure slice length:
-  `<[()]>::len(&[ $( __replace_unit!($x) ),* ])`.
-- Useful for choosing different expansions based on arity (with `macro_rules!` recursion).
-
-TT-MUNCHER PATTERN
-- For simple DSLs, write a recursive macro:
-  - Keep an accumulator (`@acc`) nonterminal.
-  - Consume tokens left-to-right, transforming the accumulator.
-  - End on empty input.
-
-HYGIENE & `$crate`
-- Don’t rely on caller’s local names; create your own bindings freely—they won’t clash.
-- Use `$crate::path::to::item` inside exported macros so referenced items resolve from the def crate.
-
-SCOPING / EXPORT
-- Macros live in the module system. Invoke them after they’re visible (same module, `pub use`, or `#[macro_export]`).
-- `#[macro_export]` places a macro at the crate root for downstream users; prefer re-exporting with `pub use` for namespacing.
-
-DESIGN TIPS
-- Keep expansions expression-based when possible: users can write `let x = mac!(...);`.
-- Accept both with and without trailing comma: `$(,)?` improves ergonomics.
-- For builders, prefer using fully qualified std paths in expansions (`::std::vec::Vec`) to avoid surprises.
-- Provide helpful compile-time errors with `compile_error!(...)` on bad inputs.
-- Avoid parsing *Rust* in macros you don’t need to—lean on fragments (`expr`, `ty`, `path`) rather than `tt` when possible.
-
-LIMITATIONS
-- Declarative macros can’t perform arbitrary computation; they manipulate tokens.
-- No partial identifier construction on stable (avoid trying to “concatenate” idents—prefer `match`/traits/regular code).
-- For advanced compile-time logic, consider `proc_macro` (procedural macros).
-
-*/ 
diff --git a/hashmap-doc/src/lib.rs b/hashmap-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..f316b45b0e14772229b3570c20a951a6b723f4bb
--- /dev/null
+++ b/hashmap-doc/src/lib.rs
@@ -0,0 +1,273 @@
+//! HashMap<K, V> in Rust — mini-docs + runnable examples
+//!
+//! TL;DR
+//! - `HashMap<K, V>`: growable hash table on the heap, average O(1) insert/lookup/remove.
+//! - Keys must implement `Eq + Hash`. Order of iteration is NOT stable.
+//! - Prefer the `entry` API for “insert-or-update” without double lookups.
+//! - For lookups with borrowed forms (e.g., `String` key, `&str` lookup) use `get::<Q>` patterns.
+
+use std::collections::HashMap;
+use std::hash::Hash;
+
+pub fn ex_basics() {
+    println!("== Basics ==");
+    // create
+    let mut m: HashMap<String, i32> = HashMap::new();
+    m.insert("apples".into(), 3);
+    m.insert("bananas".into(), 5);
+
+    // read
+    println!("apples? {:?}", m.get("apples")); // Some(&3)
+    println!("or zero: {}", m.get("oranges").copied().unwrap_or(0));
+
+    // update / overwrite
+    m.insert("apples".into(), 7); // overwrites previous value
+    println!("apples now = {:?}", m.get("apples"));
+
+    // contains / len / is_empty
+    println!("has bananas? {}", m.contains_key("bananas"));
+    println!("len={}, is_empty? {}", m.len(), m.is_empty());
+}
+
+pub fn ex_borrowed_lookup() {
+    println!("\n== Borrowed lookup (&str vs String) ==");
+    let mut m: HashMap<String, usize> = HashMap::new();
+    m.insert("alpha".to_string(), 1);
+
+    // You can query with &str even though keys are String:
+    // HashMap::get<Q: ?Sized>(&self, k: &Q)
+    // where K: Borrow<Q>, Q: Hash + Eq
+    let q: &str = "alpha";
+    println!("m.get(\"alpha\") = {:?}", m.get(q)); // Some(&1)
+
+    // get_mut for in-place update
+    if let Some(v) = m.get_mut("alpha") {
+        *v += 1;
+    }
+    println!("after get_mut: {:?}", m.get("alpha"));
+}
+
+pub fn ex_entry_api() {
+    println!("\n== entry() API (insert-or-update without double lookup) ==");
+    let mut counts: HashMap<String, usize> = HashMap::new();
+    for w in ["a", "b", "a", "c", "a", "b"] {
+        *counts.entry(w.to_string()).or_insert(0) += 1;
+    }
+    println!("word counts = {:?}", counts);
+
+    // and_modify + or_insert pattern
+    let mut settings: HashMap<&'static str, i32> = HashMap::new();
+    settings.insert("volume", 5);
+    settings.entry("volume").and_modify(|v| *v += 1).or_insert(10);
+    settings.entry("brightness").and_modify(|v| *v += 1).or_insert(50);
+    println!("settings = {:?}", settings);
+
+    // try_insert (avoids overwriting; returns Result)
+    let mut cfg: HashMap<&str, &str> = HashMap::new();
+    cfg.insert("mode", "fast");
+    match cfg.try_insert("mode", "safe") {
+        Ok(_) => println!("inserted mode"),
+        Err(e) => println!("key existed, old value = {}", e.entry.get()),
+    }
+    println!("cfg = {:?}", cfg);
+}
+
+pub fn ex_iteration() {
+    println!("\n== Iteration (order is arbitrary) ==");
+    let mut m = HashMap::from([("x", 1), ("y", 2), ("z", 3)]);
+    // by reference
+    for (k, v) in &m {
+        println!("&  {k} => {v}");
+    }
+    // by mutable reference
+    for v in m.values_mut() {
+        *v *= 10;
+    }
+    println!("after values_mut: {:?}", m);
+    // keys/values views
+    println!("keys   = {:?}", m.keys().collect::<Vec<_>>());
+    println!("values = {:?}", m.values().collect::<Vec<_>>());
+}
+
+pub fn ex_remove_clear_retain() {
+    println!("\n== remove / remove_entry / retain / clear ==");
+    let mut m = HashMap::from([("a", 1), ("b", 2), ("c", 3)]);
+
+    // remove returns Option<V>
+    let b = m.remove("b");
+    println!("removed b -> {:?}, map = {:?}", b, m);
+
+    // remove_entry returns Option<(K, V)>
+    // (requires owned key type; here &str literal is 'static so fine via reinsert)
+    m.insert("b", 22);
+    let e = m.remove_entry("b");
+    println!("remove_entry b -> {:?}, map = {:?}", e, m);
+
+    // retain keeps entries that satisfy predicate
+    m.retain(|_k, v| *v % 2 == 1);
+    println!("retain odd -> {:?}", m);
+
+    // clear empties without freeing capacity
+    m.clear();
+    println!("cleared -> len={}, cap~stays", m.len());
+}
+
+pub fn ex_capacity_and_grow() {
+    println!("\n== Capacity management ==");
+    let mut m: HashMap<i32, i32> = HashMap::with_capacity(2);
+    println!("cap (initial guess) ~2; len={}", m.len());
+    for i in 0..10 {
+        m.insert(i, i * i);
+    }
+    println!("len={}, (capacity grows automatically)", m.len());
+
+    // reserve additional space (reduce future rehashes)
+    m.reserve(100);
+    println!("reserved more; len={}", m.len());
+
+    // shrink_to_fit may reduce allocation (not guaranteed)
+    m.shrink_to_fit();
+    println!("shrink_to_fit called.");
+}
+
+pub fn ex_building_collect_merge() {
+    println!("\n== Build / collect / merge ==");
+    // from iterator of pairs
+    let m1: HashMap<_, _> = [("a", 1), ("b", 2)].into_iter().collect();
+    let m2: HashMap<_, _> = vec![("b", 20), ("c", 3)].into_iter().collect();
+    println!("m1={:?}, m2={:?}", m1, m2);
+
+    // extend/merge: later values overwrite same keys
+    let mut merged = m1.clone();
+    merged.extend(m2.clone()); // now "b" -> 20
+    println!("merged (extend) -> {:?}", merged);
+
+    // merge-with-logic using entry
+    let mut merged2 = m1.clone();
+    for (k, v) in m2 {
+        merged2.entry(k).and_modify(|old| *old += v).or_insert(v);
+    }
+    println!("merged2 (sum on conflict) -> {:?}", merged2);
+}
+
+pub fn ex_fn_signatures_and_passing() {
+    println!("\n== Passing maps to functions (borrow vs own) ==");
+
+    // Read-only view: &HashMap<K, V>
+    fn total<K: Eq + Hash>(m: &HashMap<K, i32>) -> i32 {
+        m.values().sum()
+    }
+
+    // In-place edit: &mut HashMap<K, V>
+    fn bump<K: Eq + Hash>(m: &mut HashMap<K, i32>, by: i32) {
+        for v in m.values_mut() {
+            *v += by;
+        }
+    }
+
+    // Take ownership (e.g., to return or store)
+    fn into_keys<K: Eq + Hash, V>(m: HashMap<K, V>) -> Vec<K> {
+        m.into_keys().collect()
+    }
+
+    let mut m = HashMap::from([("a", 1), ("b", 2)]);
+    println!("total(&m) = {}", total(&m));
+    bump(&mut m, 5);
+    println!("after bump: {:?}", m);
+    let keys = into_keys(m.clone());
+    println!("into_keys -> {:?}", keys);
+}
+
+pub fn ex_common_patterns() {
+    println!("\n== Common patterns ==");
+    // Frequency count
+    let text = "ababa";
+    let mut freq: HashMap<char, usize> = HashMap::new();
+    for ch in text.chars() {
+        *freq.entry(ch).or_insert(0) += 1;
+    }
+    println!("freq('{text}') = {:?}", freq);
+
+    // Grouping by key
+    let pairs = [("eu", "pl"), ("eu", "de"), ("us", "ny")];
+    let mut groups: HashMap<&str, Vec<&str>> = HashMap::new();
+    for (k, v) in pairs {
+        groups.entry(k).or_default().push(v);
+    }
+    println!("groups = {:?}", groups);
+
+    // LRU-ish bump (toy)
+    let mut hits: HashMap<&str, u64> = HashMap::new();
+    for key in ["a", "b", "a", "c", "a"] {
+        *hits.entry(key).or_insert(0) += 1;
+    }
+    println!("hits = {:?}", hits);
+}
+
+
+/*
+Docs-style notes:
+
+WHAT IT IS
+- `HashMap<K, V>`: hash table mapping keys to values with average O(1) insert/lookup/remove.
+- Keys: require `Eq + Hash`. Values: any type.
+- Type: `pub struct HashMap<K, V, S = RandomState>` where S is the hasher builder.
+
+OWNERSHIP & BORROWING
+- The map OWNS its keys and values.
+- Lookups take `&self` and a borrowed key: `get<Q>(&self, k: &Q) -> Option<&V>`
+  where `K: Borrow<Q>`, `Q: Hash + Eq`. This enables `String` keys looked up by `&str`.
+- Mutating lookups: `get_mut`, `entry`.
+- Pass `&HashMap<K, V>` for read-only, `&mut HashMap<K, V>` for in-place edits,
+  or `HashMap<K, V>` to transfer ownership.
+
+INSERT / UPDATE / UPSERT
+- `insert(k, v)` -> Option<V> (old value if key existed).
+- `entry(k)`:
+  * `.or_insert(v)` / `.or_default()` — insert if absent, then &mut V.
+  * `.and_modify(|v| ...)` — run only when present (combine with or_insert for upsert).
+  * `.or_insert_with(|| ...)` — lazily construct default.
+- `try_insert(k, v)` -> Result<(), OccupiedEntry> (no overwrite).
+
+LOOKUPS
+- `get(&k)` / `get_mut(&k)`, `contains_key(&k)`.
+- Borrowed lookup pattern: `map.get::<str>("key")` (type inference usually enough).
+- `values()`, `values_mut()`, `keys()`, `iter()`, `iter_mut()`.
+
+REMOVAL
+- `remove(&k) -> Option<V>` (returns value).
+- `remove_entry(&k) -> Option<(K, V)>` (returns key + value).
+- `retain(|k, v| ...)`, `clear()`.
+
+BUILD / MERGE
+- From iterators of `(K, V)`: `iter.collect::<HashMap<_, _>>()`, `HashMap::from([...])`.
+- `extend(other_map)` — overwrites on duplicate keys.
+- Merge with logic: loop over other and use `entry` to combine.
+
+CAPACITY & PERF
+- `with_capacity(n)` to preallocate; `reserve(additional)` to grow; `shrink_to_fit()`.
+- Table grows automatically as you insert; growth may rehash/move buckets.
+- Iteration order is arbitrary and may change as the table grows.
+- Average O(1), worst-case O(n) (pathological hashing).
+
+INTERNALS (mental model)
+- Heap-allocated hash table (std uses a `hashbrown`-style implementation with robin-hood probing).
+- Fields include a pointer to buckets, length, and metadata for capacity/hash builder.
+- Load factor triggers rehash/growth to keep O(1) averages.
+- Hasher: default `RandomState` (SipHash-like); type param `S: BuildHasher` allows custom hashers.
+
+FUNCTION SIGNATURES (when designing APIs)
+- Read-only:      `fn f<K: Eq + Hash, V>(m: &HashMap<K, V>) { ... }`
+- Mutating:       `fn f<K: Eq + Hash, V>(m: &mut HashMap<K, V>) { ... }`
+- Take ownership: `fn f<K: Eq + Hash, V>(m: HashMap<K, V>) -> ...`
+- Accept “map-like” iterables: `fn f<I, K, V>(it: I) where I: IntoIterator<Item=(K,V)>`
+
+WHEN NOT TO USE HASHMAP
+- Need ordered iteration / range queries → use `BTreeMap`.
+- Need stable insertion order → consider `indexmap::IndexMap` (external crate).
+
+COMMON PITFALLS
+- Assuming stable iteration order (it isn’t).
+- Double lookups for upsert instead of `entry`.
+- Holding references across operations that may rehash (keep borrows short).
+*/
diff --git a/hashmap-doc/src/main.rs b/hashmap-doc/src/main.rs
index 3ec627fc86246d4ebc4a216ee43d9f7cb50860f0..0710c03c79d8161f64936e83d1210f9c55131ee7 100644
--- a/hashmap-doc/src/main.rs
+++ b/hashmap-doc/src/main.rs
@@ -1,284 +1,23 @@
-//! HashMap<K, V> in Rust — mini-docs + runnable examples
-//!
-//! TL;DR
-//! - `HashMap<K, V>`: growable hash table on the heap, average O(1) insert/lookup/remove.
-//! - Keys must implement `Eq + Hash`. Order of iteration is NOT stable.
-//! - Prefer the `entry` API for “insert-or-update” without double lookups.
-//! - For lookups with borrowed forms (e.g., `String` key, `&str` lookup) use `get::<Q>` patterns.
-
-use std::collections::HashMap;
-use std::hash::Hash;
-
-fn ex_basics() {
-    println!("== Basics ==");
-    // create
-    let mut m: HashMap<String, i32> = HashMap::new();
-    m.insert("apples".into(), 3);
-    m.insert("bananas".into(), 5);
-
-    // read
-    println!("apples? {:?}", m.get("apples")); // Some(&3)
-    println!("or zero: {}", m.get("oranges").copied().unwrap_or(0));
-
-    // update / overwrite
-    m.insert("apples".into(), 7); // overwrites previous value
-    println!("apples now = {:?}", m.get("apples"));
-
-    // contains / len / is_empty
-    println!("has bananas? {}", m.contains_key("bananas"));
-    println!("len={}, is_empty? {}", m.len(), m.is_empty());
-}
-
-fn ex_borrowed_lookup() {
-    println!("\n== Borrowed lookup (&str vs String) ==");
-    let mut m: HashMap<String, usize> = HashMap::new();
-    m.insert("alpha".to_string(), 1);
-
-    // You can query with &str even though keys are String:
-    // HashMap::get<Q: ?Sized>(&self, k: &Q)
-    // where K: Borrow<Q>, Q: Hash + Eq
-    let q: &str = "alpha";
-    println!("m.get(\"alpha\") = {:?}", m.get(q)); // Some(&1)
-
-    // get_mut for in-place update
-    if let Some(v) = m.get_mut("alpha") {
-        *v += 1;
-    }
-    println!("after get_mut: {:?}", m.get("alpha"));
-}
-
-fn ex_entry_api() {
-    println!("\n== entry() API (insert-or-update without double lookup) ==");
-    let mut counts: HashMap<String, usize> = HashMap::new();
-    for w in ["a", "b", "a", "c", "a", "b"] {
-        *counts.entry(w.to_string()).or_insert(0) += 1;
-    }
-    println!("word counts = {:?}", counts);
-
-    // and_modify + or_insert pattern
-    let mut settings: HashMap<&'static str, i32> = HashMap::new();
-    settings.insert("volume", 5);
-    settings.entry("volume").and_modify(|v| *v += 1).or_insert(10);
-    settings.entry("brightness").and_modify(|v| *v += 1).or_insert(50);
-    println!("settings = {:?}", settings);
-
-    // try_insert (avoids overwriting; returns Result)
-    let mut cfg: HashMap<&str, &str> = HashMap::new();
-    cfg.insert("mode", "fast");
-    match cfg.try_insert("mode", "safe") {
-        Ok(_) => println!("inserted mode"),
-        Err(e) => println!("key existed, old value = {}", e.entry.get()),
-    }
-    println!("cfg = {:?}", cfg);
-}
-
-fn ex_iteration() {
-    println!("\n== Iteration (order is arbitrary) ==");
-    let mut m = HashMap::from([("x", 1), ("y", 2), ("z", 3)]);
-    // by reference
-    for (k, v) in &m {
-        println!("&  {k} => {v}");
-    }
-    // by mutable reference
-    for v in m.values_mut() {
-        *v *= 10;
-    }
-    println!("after values_mut: {:?}", m);
-    // keys/values views
-    println!("keys   = {:?}", m.keys().collect::<Vec<_>>());
-    println!("values = {:?}", m.values().collect::<Vec<_>>());
-}
-
-fn ex_remove_clear_retain() {
-    println!("\n== remove / remove_entry / retain / clear ==");
-    let mut m = HashMap::from([("a", 1), ("b", 2), ("c", 3)]);
-
-    // remove returns Option<V>
-    let b = m.remove("b");
-    println!("removed b -> {:?}, map = {:?}", b, m);
-
-    // remove_entry returns Option<(K, V)>
-    // (requires owned key type; here &str literal is 'static so fine via reinsert)
-    m.insert("b", 22);
-    let e = m.remove_entry("b");
-    println!("remove_entry b -> {:?}, map = {:?}", e, m);
-
-    // retain keeps entries that satisfy predicate
-    m.retain(|_k, v| *v % 2 == 1);
-    println!("retain odd -> {:?}", m);
-
-    // clear empties without freeing capacity
-    m.clear();
-    println!("cleared -> len={}, cap~stays", m.len());
-}
-
-fn ex_capacity_and_grow() {
-    println!("\n== Capacity management ==");
-    let mut m: HashMap<i32, i32> = HashMap::with_capacity(2);
-    println!("cap (initial guess) ~2; len={}", m.len());
-    for i in 0..10 {
-        m.insert(i, i * i);
-    }
-    println!("len={}, (capacity grows automatically)", m.len());
-
-    // reserve additional space (reduce future rehashes)
-    m.reserve(100);
-    println!("reserved more; len={}", m.len());
-
-    // shrink_to_fit may reduce allocation (not guaranteed)
-    m.shrink_to_fit();
-    println!("shrink_to_fit called.");
-}
-
-fn ex_building_collect_merge() {
-    println!("\n== Build / collect / merge ==");
-    // from iterator of pairs
-    let m1: HashMap<_, _> = [("a", 1), ("b", 2)].into_iter().collect();
-    let m2: HashMap<_, _> = vec![("b", 20), ("c", 3)].into_iter().collect();
-    println!("m1={:?}, m2={:?}", m1, m2);
-
-    // extend/merge: later values overwrite same keys
-    let mut merged = m1.clone();
-    merged.extend(m2.clone()); // now "b" -> 20
-    println!("merged (extend) -> {:?}", merged);
-
-    // merge-with-logic using entry
-    let mut merged2 = m1.clone();
-    for (k, v) in m2 {
-        merged2.entry(k).and_modify(|old| *old += v).or_insert(v);
-    }
-    println!("merged2 (sum on conflict) -> {:?}", merged2);
-}
-
-fn ex_fn_signatures_and_passing() {
-    println!("\n== Passing maps to functions (borrow vs own) ==");
-
-    // Read-only view: &HashMap<K, V>
-    fn total<K: Eq + Hash>(m: &HashMap<K, i32>) -> i32 {
-        m.values().sum()
-    }
-
-    // In-place edit: &mut HashMap<K, V>
-    fn bump<K: Eq + Hash>(m: &mut HashMap<K, i32>, by: i32) {
-        for v in m.values_mut() {
-            *v += by;
-        }
-    }
-
-    // Take ownership (e.g., to return or store)
-    fn into_keys<K: Eq + Hash, V>(m: HashMap<K, V>) -> Vec<K> {
-        m.into_keys().collect()
-    }
-
-    let mut m = HashMap::from([("a", 1), ("b", 2)]);
-    println!("total(&m) = {}", total(&m));
-    bump(&mut m, 5);
-    println!("after bump: {:?}", m);
-    let keys = into_keys(m.clone());
-    println!("into_keys -> {:?}", keys);
-}
-
-fn ex_common_patterns() {
-    println!("\n== Common patterns ==");
-    // Frequency count
-    let text = "ababa";
-    let mut freq: HashMap<char, usize> = HashMap::new();
-    for ch in text.chars() {
-        *freq.entry(ch).or_insert(0) += 1;
-    }
-    println!("freq('{text}') = {:?}", freq);
-
-    // Grouping by key
-    let pairs = [("eu", "pl"), ("eu", "de"), ("us", "ny")];
-    let mut groups: HashMap<&str, Vec<&str>> = HashMap::new();
-    for (k, v) in pairs {
-        groups.entry(k).or_default().push(v);
-    }
-    println!("groups = {:?}", groups);
-
-    // LRU-ish bump (toy)
-    let mut hits: HashMap<&str, u64> = HashMap::new();
-    for key in ["a", "b", "a", "c", "a"] {
-        *hits.entry(key).or_insert(0) += 1;
-    }
-    println!("hits = {:?}", hits);
-}
+use hashmap_doc::{
+    ex_basics,
+    ex_borrowed_lookup,
+    ex_entry_api,
+    ex_iteration,
+    ex_remove_clear_retain,
+    ex_capacity_and_grow,
+    ex_building_collect_merge,
+    ex_fn_signatures_and_passing,
+    ex_common_patterns,
+};
 
 fn main() {
     ex_basics();
     ex_borrowed_lookup();
     ex_entry_api();
     ex_iteration();
     ex_remove_clear_retain();
     ex_capacity_and_grow();
     ex_building_collect_merge();
     ex_fn_signatures_and_passing();
     ex_common_patterns();
 }
-
-/*
-Docs-style notes:
-
-WHAT IT IS
-- `HashMap<K, V>`: hash table mapping keys to values with average O(1) insert/lookup/remove.
-- Keys: require `Eq + Hash`. Values: any type.
-- Type: `pub struct HashMap<K, V, S = RandomState>` where S is the hasher builder.
-
-OWNERSHIP & BORROWING
-- The map OWNS its keys and values.
-- Lookups take `&self` and a borrowed key: `get<Q>(&self, k: &Q) -> Option<&V>`
-  where `K: Borrow<Q>`, `Q: Hash + Eq`. This enables `String` keys looked up by `&str`.
-- Mutating lookups: `get_mut`, `entry`.
-- Pass `&HashMap<K, V>` for read-only, `&mut HashMap<K, V>` for in-place edits,
-  or `HashMap<K, V>` to transfer ownership.
-
-INSERT / UPDATE / UPSERT
-- `insert(k, v)` -> Option<V> (old value if key existed).
-- `entry(k)`:
-  * `.or_insert(v)` / `.or_default()` — insert if absent, then &mut V.
-  * `.and_modify(|v| ...)` — run only when present (combine with or_insert for upsert).
-  * `.or_insert_with(|| ...)` — lazily construct default.
-- `try_insert(k, v)` -> Result<(), OccupiedEntry> (no overwrite).
-
-LOOKUPS
-- `get(&k)` / `get_mut(&k)`, `contains_key(&k)`.
-- Borrowed lookup pattern: `map.get::<str>("key")` (type inference usually enough).
-- `values()`, `values_mut()`, `keys()`, `iter()`, `iter_mut()`.
-
-REMOVAL
-- `remove(&k) -> Option<V>` (returns value).
-- `remove_entry(&k) -> Option<(K, V)>` (returns key + value).
-- `retain(|k, v| ...)`, `clear()`.
-
-BUILD / MERGE
-- From iterators of `(K, V)`: `iter.collect::<HashMap<_, _>>()`, `HashMap::from([...])`.
-- `extend(other_map)` — overwrites on duplicate keys.
-- Merge with logic: loop over other and use `entry` to combine.
-
-CAPACITY & PERF
-- `with_capacity(n)` to preallocate; `reserve(additional)` to grow; `shrink_to_fit()`.
-- Table grows automatically as you insert; growth may rehash/move buckets.
-- Iteration order is arbitrary and may change as the table grows.
-- Average O(1), worst-case O(n) (pathological hashing).
-
-INTERNALS (mental model)
-- Heap-allocated hash table (std uses a `hashbrown`-style implementation with robin-hood probing).
-- Fields include a pointer to buckets, length, and metadata for capacity/hash builder.
-- Load factor triggers rehash/growth to keep O(1) averages.
-- Hasher: default `RandomState` (SipHash-like); type param `S: BuildHasher` allows custom hashers.
-
-FUNCTION SIGNATURES (when designing APIs)
-- Read-only:      `fn f<K: Eq + Hash, V>(m: &HashMap<K, V>) { ... }`
-- Mutating:       `fn f<K: Eq + Hash, V>(m: &mut HashMap<K, V>) { ... }`
-- Take ownership: `fn f<K: Eq + Hash, V>(m: HashMap<K, V>) -> ...`
-- Accept “map-like” iterables: `fn f<I, K, V>(it: I) where I: IntoIterator<Item=(K,V)>`
-
-WHEN NOT TO USE HASHMAP
-- Need ordered iteration / range queries → use `BTreeMap`.
-- Need stable insertion order → consider `indexmap::IndexMap` (external crate).
-
-COMMON PITFALLS
-- Assuming stable iteration order (it isn’t).
-- Double lookups for upsert instead of `entry`.
-- Holding references across operations that may rehash (keep borrows short).
-*/
diff --git a/iterators-doc/src/lib.rs b/iterators-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..7c7e3108dbd223ff1eda7a7ec7fa467d21aa49aa
--- /dev/null
+++ b/iterators-doc/src/lib.rs
@@ -0,0 +1,165 @@
+//! Iterators in Rust: docs + runnable examples
+//!
+//! What is an Iterator?
+//! - An object that produces a sequence of values on demand.
+//! - In Rust: anything implementing the `Iterator` trait.
+//!
+//! Core API (from std::iter):
+//! trait Iterator {
+//!     type Item;
+//!     fn next(&mut self) -> Option<Self::Item>;
+//!     // default methods (map, filter, fold, etc.) are built on top of next()
+//! }
+//!
+//! - Lazy: iterator adapters (map, filter, etc.) build new iterators.
+//! - Consuming adapters (collect, for_each, sum, etc.) pull values and end iteration.
+
+pub fn example_basic() {
+    println!("== Example 1: Iteration entry points ==");
+
+    let v = vec![10, 20, 30];
+
+    // 1. into_iter() -> takes ownership of the collection
+    //    - The vector itself is consumed.
+    //    - Yields owned values (T).
+    //    - After calling into_iter(), you cannot use v again unless it’s cloned before.
+    for x in v.clone().into_iter() {
+        println!("into_iter got {}", x);
+    }
+    // println!("{:?}", v); // ❌ cannot use here, v moved
+
+    // 2. iter() -> borrows immutably
+    //    - The vector is not consumed.
+    //    - Yields &T (references to elements).
+    //    - You can still use v afterwards, since it’s only borrowed.
+    for x in v.iter() {
+        println!("iter got {}", x);
+    }
+    println!("v is still usable after iter(): {:?}", v);
+
+    // 3. iter_mut() -> borrows mutably
+    //    - The vector is not consumed.
+    //    - Yields &mut T (mutable references).
+    //    - You can modify elements through the iterator.
+    let mut v2 = v.clone();
+    for x in v2.iter_mut() {
+        *x += 1; // increment each element
+    }
+    println!("after iter_mut = {:?}", v2);
+}
+
+pub fn example_next() {
+    println!("\n== Example 2: Using next() directly ==");
+    let mut it = [1, 2, 3].iter();
+
+    println!("next = {:?}", it.next()); // Some(&1)
+    println!("next = {:?}", it.next()); // Some(&2)
+    println!("next = {:?}", it.next()); // Some(&3)
+    println!("next = {:?}", it.next()); // None (end)
+}
+
+pub fn example_adapters() {
+    println!("\n== Example 3: Iterator adapters (lazy) ==");
+    let nums = vec![1, 2, 3, 4, 5];
+
+    // map squares
+    let squares = nums.iter().map(|x| x * x);
+    println!("squares = {:?}", squares.collect::<Vec<_>>());
+
+    // filter evens
+    let evens: Vec<_> = nums.iter().cloned().filter(|x| x % 2 == 0).collect();
+    println!("evens = {:?}", evens);
+
+    // chaining adapters
+    let odds_squared: Vec<_> = nums.iter()
+        .cloned()
+        .filter(|x| x % 2 == 1)
+        .map(|x| x * x)
+        .collect();
+    println!("odds_squared = {:?}", odds_squared);
+}
+
+pub fn example_consumers() {
+    println!("\n== Example 4: Consuming adapters ==");
+    let nums = vec![1, 2, 3, 4];
+
+    let sum: i32 = nums.iter().sum();
+    println!("sum = {}", sum);
+
+    let product: i32 = nums.iter().product();
+    println!("product = {}", product);
+
+    let found = nums.iter().find(|&&x| x > 2);
+    println!("first >2 = {:?}", found);
+
+    nums.iter().for_each(|x| println!("for_each prints {}", x));
+
+    let folded = nums.iter().fold(0, |acc, x| acc + x);
+    println!("fold = {}", folded);
+}
+
+pub fn example_custom_iterator() {
+    println!("\n== Example 5: Custom iterator implementing Iterator trait ==");
+
+    struct Counter { n: u32 }
+    impl Iterator for Counter {
+        type Item = u32;
+        fn next(&mut self) -> Option<Self::Item> {
+            if self.n < 5 {
+                self.n += 1;
+                Some(self.n)
+            } else {
+                None
+            }
+        }
+    }
+
+    let mut c = Counter { n: 0 };
+    println!("manual next: {:?}", (0..6).map(|_| c.next()).collect::<Vec<_>>());
+
+    // reuse in for loop
+    for val in Counter { n: 0 } {
+        println!("Counter yields {}", val);
+    }
+}
+
+
+/*
+Docs-style notes:
+
+Iterator trait:
+- type Item;
+- fn next(&mut self) -> Option<Self::Item>;
+  - Returns Some(item) until exhausted, then None.
+- Default methods (map, filter, fold, etc.) are built on top of next().
+
+Kinds of iteration over Vec<T>:
+- into_iter()  -> takes ownership, yields T, consumes the vector
+- iter()       -> borrows immutably, yields &T, vector remains usable
+- iter_mut()   -> borrows mutably, yields &mut T, can modify elements in place
+
+Iterator adapters (lazy, return a new iterator):
+- map, filter, filter_map, enumerate, zip, chain, take, skip, etc.
+- Do nothing until consumed.
+
+Consuming adapters:
+- collect, for_each, fold, sum, product, find, any, all, count, etc.
+- Drive the iteration to completion.
+
+Custom iterators:
+- Implement Iterator by writing your own next().
+- Once you have next(), you automatically get access to all the adapters.
+
+Performance:
+- Iterators are zero-cost abstractions (monomorphized).
+- Compiler optimizes chains of adapters into efficient loops (fusion).
+
+Comparison:
+| Category         | Example method      | Notes                                      |
+|------------------|---------------------|--------------------------------------------|
+| Entry points     | into_iter, iter     | How iteration begins                       |
+| Lazy adapters    | map, filter, zip    | Return new iterators, do nothing immediately|
+| Consuming        | collect, sum, fold  | Actually run the iteration                 |
+| Custom impl      | impl Iterator::next | Create your own iterator types             |
+
+*/
diff --git a/iterators-doc/src/main.rs b/iterators-doc/src/main.rs
index 76fceb19f05ce3139b1c6f36270169189dd9993f..4feb016eaf4a7e9d61646c40ad89b461aca2b1e7 100644
--- a/iterators-doc/src/main.rs
+++ b/iterators-doc/src/main.rs
@@ -1,172 +1,15 @@
-//! Iterators in Rust: docs + runnable examples
-//!
-//! What is an Iterator?
-//! - An object that produces a sequence of values on demand.
-//! - In Rust: anything implementing the `Iterator` trait.
-//!
-//! Core API (from std::iter):
-//! trait Iterator {
-//!     type Item;
-//!     fn next(&mut self) -> Option<Self::Item>;
-//!     // default methods (map, filter, fold, etc.) are built on top of next()
-//! }
-//!
-//! - Lazy: iterator adapters (map, filter, etc.) build new iterators.
-//! - Consuming adapters (collect, for_each, sum, etc.) pull values and end iteration.
-
-fn example_basic() {
-    println!("== Example 1: Iteration entry points ==");
-
-    let v = vec![10, 20, 30];
-
-    // 1. into_iter() -> takes ownership of the collection
-    //    - The vector itself is consumed.
-    //    - Yields owned values (T).
-    //    - After calling into_iter(), you cannot use v again unless it’s cloned before.
-    for x in v.clone().into_iter() {
-        println!("into_iter got {}", x);
-    }
-    // println!("{:?}", v); // ❌ cannot use here, v moved
-
-    // 2. iter() -> borrows immutably
-    //    - The vector is not consumed.
-    //    - Yields &T (references to elements).
-    //    - You can still use v afterwards, since it’s only borrowed.
-    for x in v.iter() {
-        println!("iter got {}", x);
-    }
-    println!("v is still usable after iter(): {:?}", v);
-
-    // 3. iter_mut() -> borrows mutably
-    //    - The vector is not consumed.
-    //    - Yields &mut T (mutable references).
-    //    - You can modify elements through the iterator.
-    let mut v2 = v.clone();
-    for x in v2.iter_mut() {
-        *x += 1; // increment each element
-    }
-    println!("after iter_mut = {:?}", v2);
-}
-
-fn example_next() {
-    println!("\n== Example 2: Using next() directly ==");
-    let mut it = [1, 2, 3].iter();
-
-    println!("next = {:?}", it.next()); // Some(&1)
-    println!("next = {:?}", it.next()); // Some(&2)
-    println!("next = {:?}", it.next()); // Some(&3)
-    println!("next = {:?}", it.next()); // None (end)
-}
-
-fn example_adapters() {
-    println!("\n== Example 3: Iterator adapters (lazy) ==");
-    let nums = vec![1, 2, 3, 4, 5];
-
-    // map squares
-    let squares = nums.iter().map(|x| x * x);
-    println!("squares = {:?}", squares.collect::<Vec<_>>());
-
-    // filter evens
-    let evens: Vec<_> = nums.iter().cloned().filter(|x| x % 2 == 0).collect();
-    println!("evens = {:?}", evens);
-
-    // chaining adapters
-    let odds_squared: Vec<_> = nums.iter()
-        .cloned()
-        .filter(|x| x % 2 == 1)
-        .map(|x| x * x)
-        .collect();
-    println!("odds_squared = {:?}", odds_squared);
-}
-
-fn example_consumers() {
-    println!("\n== Example 4: Consuming adapters ==");
-    let nums = vec![1, 2, 3, 4];
-
-    let sum: i32 = nums.iter().sum();
-    println!("sum = {}", sum);
-
-    let product: i32 = nums.iter().product();
-    println!("product = {}", product);
-
-    let found = nums.iter().find(|&&x| x > 2);
-    println!("first >2 = {:?}", found);
-
-    nums.iter().for_each(|x| println!("for_each prints {}", x));
-
-    let folded = nums.iter().fold(0, |acc, x| acc + x);
-    println!("fold = {}", folded);
-}
-
-fn example_custom_iterator() {
-    println!("\n== Example 5: Custom iterator implementing Iterator trait ==");
-
-    struct Counter { n: u32 }
-    impl Iterator for Counter {
-        type Item = u32;
-        fn next(&mut self) -> Option<Self::Item> {
-            if self.n < 5 {
-                self.n += 1;
-                Some(self.n)
-            } else {
-                None
-            }
-        }
-    }
-
-    let mut c = Counter { n: 0 };
-    println!("manual next: {:?}", (0..6).map(|_| c.next()).collect::<Vec<_>>());
-
-    // reuse in for loop
-    for val in Counter { n: 0 } {
-        println!("Counter yields {}", val);
-    }
-}
+use iterators_doc::{
+    example_basic,
+    example_next,
+    example_adapters,
+    example_consumers,
+    example_custom_iterator,
+};
 
 fn main() {
     example_basic();
     example_next();
     example_adapters();
     example_consumers();
     example_custom_iterator();
 }
-
-/*
-Docs-style notes:
-
-Iterator trait:
-- type Item;
-- fn next(&mut self) -> Option<Self::Item>;
-  - Returns Some(item) until exhausted, then None.
-- Default methods (map, filter, fold, etc.) are built on top of next().
-
-Kinds of iteration over Vec<T>:
-- into_iter()  -> takes ownership, yields T, consumes the vector
-- iter()       -> borrows immutably, yields &T, vector remains usable
-- iter_mut()   -> borrows mutably, yields &mut T, can modify elements in place
-
-Iterator adapters (lazy, return a new iterator):
-- map, filter, filter_map, enumerate, zip, chain, take, skip, etc.
-- Do nothing until consumed.
-
-Consuming adapters:
-- collect, for_each, fold, sum, product, find, any, all, count, etc.
-- Drive the iteration to completion.
-
-Custom iterators:
-- Implement Iterator by writing your own next().
-- Once you have next(), you automatically get access to all the adapters.
-
-Performance:
-- Iterators are zero-cost abstractions (monomorphized).
-- Compiler optimizes chains of adapters into efficient loops (fusion).
-
-Comparison:
-| Category         | Example method      | Notes                                      |
-|------------------|---------------------|--------------------------------------------|
-| Entry points     | into_iter, iter     | How iteration begins                       |
-| Lazy adapters    | map, filter, zip    | Return new iterators, do nothing immediately|
-| Consuming        | collect, sum, fold  | Actually run the iteration                 |
-| Custom impl      | impl Iterator::next | Create your own iterator types             |
-
-*/
diff --git a/memory-init-layout-doc/src/lib.rs b/memory-init-layout-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..846b3550bd758ef9c08c8bfc9c736059babb6e84
--- /dev/null
+++ b/memory-init-layout-doc/src/lib.rs
@@ -0,0 +1,236 @@
+//! Memory layout & initialization in Rust — mini-docs + runnable examples
+//!
+//! Topics:
+//!  1) MaybeUninit<T>: uninitialized memory, manual init, *zeroing is not init*, safe patterns
+//!  2) ManuallyDrop<T>: suppress Drop (FFI buffers, unions); compare with mem::forget
+//!  3) Niche optimization & NonZero*: how `Option<NonZeroUsize>` is one word; `Option<&T>` too
+//!
+//! Run: `cargo run`
+
+use std::{
+    mem::{self, ManuallyDrop, MaybeUninit, size_of},
+    num::{NonZeroU8, NonZeroUsize},
+    ptr,
+};
+
+/* ───────────────────────────── 1) MaybeUninit<T> ─────────────────────────────
+`MaybeUninit<T>` lets you handle memory that is not (yet) initialized, without
+immediately invoking UB. You *must* initialize every byte of a `T` before you
+treat it as a `T`.
+
+Key APIs you’ll typically use:
+- `MaybeUninit::<T>::uninit()`                 // uninitialized slot
+- `MaybeUninit::<T>::new(value)`               // initialized slot
+- `slot.write(value)`                          // write without reading old
+- `assume_init()`                              // turn into T (only if fully init!)
+- Arrays: `MaybeUninit::uninit_array()` + `MaybeUninit::array_assume_init(...)`
+*/
+
+pub fn ex_maybeuninit_array() {
+    println!("== 1a) MaybeUninit: initialize array element-by-element ==");
+    const N: usize = 4;
+
+    // Allocate uninitialized array of T
+    let mut buf: [MaybeUninit<String>; N] = MaybeUninit::uninit_array();
+
+    // Initialize each element *exactly once*
+    for i in 0..N {
+        let s = format!("item-{i}");
+        buf[i].write(s);
+    }
+
+    // SAFETY: we wrote all elements; no panics in between → fully initialized
+    let arr: [String; N] = unsafe { MaybeUninit::array_assume_init(buf) };
+    println!("array = {:?}", arr);
+}
+
+pub fn ex_maybeuninit_out_param() {
+    println!("\n== 1b) MaybeUninit: out-parameter pattern ==");
+    // Pretend we call an FFI that writes into a provided slot.
+    #[inline]
+    unsafe fn produce_into(slot: *mut u32) {
+        // Initialize without reading the old memory:
+        ptr::write(slot, 0xABCD_FFFF);
+    }
+
+    let mut slot: MaybeUninit<u32> = MaybeUninit::uninit();
+    unsafe {
+        produce_into(slot.as_mut_ptr());
+        let val: u32 = slot.assume_init(); // fully initialized by callee
+        println!("produced = 0x{val:08X}");
+    }
+}
+
+/* ────────────────── “Zeroing is not init” (when it is / isn’t) ──────────────────
+- For *plain old data* (POD) where the all-zero bit pattern is a valid value (e.g., u32),
+  `MaybeUninit::<u32>::zeroed().assume_init()` is fine.
+- For types like `String`, `Vec<T>`, `Box<T>`, zero bytes are NOT a valid representation
+  (would violate their invariants) → assuming init after zeroing is UB.
+
+We’ll demonstrate “okay” vs “not okay” in comments + a safe example:
+*/
+
+pub fn ex_zeroing_note() {
+    println!("\n== 1c) Zeroing: when it’s okay vs UB ==");
+    // OK: integers/pointers where 0 is valid
+    let x = unsafe { MaybeUninit::<u32>::zeroed().assume_init() };
+    println!("zeroed u32 = {x}");
+
+    // ❌ NEVER do this (UB):
+    // let s = unsafe { MaybeUninit::<String>::zeroed().assume_init() };
+
+    // If you need a default String, *construct* it:
+    let s = String::new();
+    println!("constructed String OK: {:?}", s);
+}
+
+/* Safe patterns with MaybeUninit:
+- Build arrays of non-Copy / no-Default elements, then assume_init after fully filling.
+- Use `.write(...)` to overwrite uninitialized / possibly-garbage bytes without reading them.
+- If initialization can fail mid-way, use a guard to drop already-initialized elements before unwind.
+  (Omitted here for brevity; see std docs for a drop guard pattern.)
+*/
+
+/* ───────────────────────────── 2) ManuallyDrop<T> ─────────────────────────────
+Wrap a value to *suppress automatic Drop*. You can later:
+- extract it (consuming) via `ManuallyDrop::into_inner` (no Drop called on the wrapper),
+- or call `ManuallyDrop::drop(&mut x)` manually if/when you choose.
+
+Use cases:
+- FFI buffers whose ownership you transfer (avoid double-free),
+- unions containing non-Copy fields,
+- custom drop ordering.
+
+Compare with `mem::forget`: that *leaks* the value permanently. `ManuallyDrop`
+lets you control when/how to drop or extract it.
+*/
+
+pub fn ex_manuallydrop_basics() {
+    println!("\n== 2) ManuallyDrop basics, vs mem::forget ==");
+    #[derive(Debug)]
+    struct Loud(String);
+    impl Drop for Loud {
+        fn drop(&mut self) { println!("Drop(Loud: {:?})", self.0); }
+    }
+
+    // Suppress automatic drop
+    let m = ManuallyDrop::new(Loud("held".into()));
+    println!("wrapped: {:?}", unsafe { &*(&*m as *const Loud) });
+
+    // 2a) Extract the inner value without running Drop on the wrapper:
+    let inner: Loud = unsafe { ManuallyDrop::into_inner(m) };
+    println!("extracted {:?}", inner.0);
+    // Drop will run here (on `inner`) at end of scope.
+
+    // 2b) Forget permanently (leak) — not recommended unless you *intend* to leak:
+    let leak = Loud("leaked".into());
+    mem::forget(leak); // no Drop() call will happen for this one
+}
+
+/* A tiny FFI-flavored example: take ownership of a raw allocation and prevent double drop. */
+pub fn ex_manuallydrop_ffi_style() {
+    println!("\n== 2b) ManuallyDrop: ownership transfer (FFI style) ==");
+    // Imagine we received a Box<T> from C and must take ownership exactly once:
+    let p = Box::new(String::from("ffi-owned"));
+    let raw = Box::into_raw(p);           // C gives us this pointer…
+
+    // Wrap the would-be Box in ManuallyDrop so we can control drop vs extraction:
+    let mut wrapper: ManuallyDrop<Box<String>> = ManuallyDrop::new(unsafe { Box::from_raw(raw) });
+
+    // Decide to *extract* and keep ownership in safe Rust:
+    let owned_box: Box<String> = unsafe { ManuallyDrop::into_inner(ptr::read(&*wrapper)) };
+    // SAFETY: we read (copy) the ManuallyDrop<..> content by value, leaving a moved-from wrapper.
+    // We must not drop `wrapper` now (it contains moved value). That’s okay: it’s on the stack.
+
+    println!("owned_box = {:?}", owned_box);
+    // Drop occurs once, here, when owned_box goes out of scope.
+}
+
+/* ───────────── 3) Niche optimization & NonZero* (and pointers) ─────────────
+A “niche” is a bit-pattern that a type never uses. The compiler can pack an `Option<T>`
+into the same size as `T` by using the niche to encode `None`.
+
+Examples:
+- `NonZeroUsize` never uses 0 → `Option<NonZeroUsize>` is one word (0 encodes None).
+- `&T` pointers are never null → `Option<&T>` is one word (null encodes None).
+- `Box<T>` is non-null → `Option<Box<T>>` is one word too.
+
+This saves space and improves cache behavior without extra code.
+*/
+
+pub fn ex_niche_sizes() {
+    println!("\n== 3) Niche sizes (Option<T> size vs T) ==");
+    println!("usize                      = {}", size_of::<usize>());
+    println!("Option<usize>              = {}", size_of::<Option<usize>>()); // often also one word on many platforms
+    println!("NonZeroUsize               = {}", size_of::<NonZeroUsize>());
+    println!("Option<NonZeroUsize>       = {}", size_of::<Option<NonZeroUsize>>()); // == usize
+
+    println!("&u8                        = {}", size_of::<&u8>());
+    println!("Option<&u8>                = {}", size_of::<Option<&u8>>()); // == pointer size
+
+    println!("Box<u8>                    = {}", size_of::<Box<u8>>());
+    println!("Option<Box<u8>>            = {}", size_of::<Option<Box<u8>>>()); // == pointer size
+
+    println!("NonZeroU8                  = {}", size_of::<NonZeroU8>());
+    println!("Option<NonZeroU8>          = {}", size_of::<Option<NonZeroU8>>()); // == 1 byte
+}
+
+/* Using NonZero with Option in APIs */
+pub fn ex_nonzero_api() {
+    println!("\n== 3b) NonZero: ergonomic Option payloads ==");
+    fn next_id(prev: Option<NonZeroUsize>) -> Option<NonZeroUsize> {
+        // “0 means none” compactly encoded
+        Some(prev.map_or(NonZeroUsize::new(1).unwrap(), |nz| NonZeroUsize::new(nz.get() + 1).unwrap()))
+    }
+    let a = next_id(None).unwrap();
+    let b = next_id(Some(a)).unwrap();
+    println!("ids: {} -> {}", a.get(), b.get());
+}
+
+
+/* ───────────────────────────── Docs-style notes ─────────────────────────────
+
+MAYBEUNINIT<T>
+- Use when you need a `T`’s storage before it’s fully initialized.
+- Correct patterns:
+  * Allocate: `let mut x: MaybeUninit<T> = MaybeUninit::uninit();`
+  * Write once: `x.write(value)` or via raw pointer `ptr::write(x.as_mut_ptr(), value)`.
+  * After fully initializing, convert: `unsafe { x.assume_init() }`.
+  * For arrays: `MaybeUninit::uninit_array()` + write each element + `array_assume_init(...)`.
+- Do NOT read from uninitialized memory. Do NOT call `assume_init` unless *every* byte is valid for `T`.
+- “Zeroing is not init” unless the all-zero bit pattern is valid for `T` (e.g., integers, some C POD).
+  Never zero-init `String`, `Vec<T>`, `Box<T>`, etc.
+
+MANUALLYDROP<T>
+- Prevents automatic Drop. Useful for:
+  * Transferring ownership across FFI boundaries (avoid double-free).
+  * Unions with non-Copy fields (control when to drop the active field).
+  * Custom drop order in complex structures.
+- Ways to use:
+  * `let m = ManuallyDrop::new(value);`  // no Drop at scope end
+  * Extract: `let v = unsafe { ManuallyDrop::into_inner(m) };` (consumes `m`)
+  * Drop now: `unsafe { ManuallyDrop::drop(&mut m) }`
+- `mem::forget(value)` *leaks* the value forever (never drops). Prefer `ManuallyDrop` when you still want control.
+
+NICHE OPTIMIZATION (size wins)
+- `Option<&T>` / `Option<Box<T>>` / `Option<NonZero*>` are the same size as their non-Option counterparts.
+  The compiler uses an invalid/unused representation (null or zero) to encode `None`.
+- Practically: choose `Option<NonZeroUsize>` instead of `Option<usize>` when you semantically exclude zero,
+  to guarantee the one-word layout and document the invariant.
+- This optimization is automatic. No unsafe needed.
+
+PITFALLS
+- UB magnets: calling `assume_init` too early; zero-initializing non-zeroable types; reading uninit bytes.
+- Mixing partial init with panics: if constructing a collection element-by-element, use a guard to drop
+  already-initialized elements on early exit.
+- With `ManuallyDrop`, be sure each value is dropped exactly once (or intentionally leaked).
+
+CHEATSHEET
+- Uninit array:        `let mut a: [MaybeUninit<T>; N] = MaybeUninit::uninit_array();`
+- Write elements:      `a[i].write(val);`
+- Finalize:            `let arr: [T; N] = unsafe { MaybeUninit::array_assume_init(a) };`
+- Suppress drop:       `let m = ManuallyDrop::new(v);`
+- Extract owned:       `let v = unsafe { ManuallyDrop::into_inner(m) };`
+- One-word Option:     `Option<NonZeroUsize>`, `Option<&T>`, `Option<Box<T>>`
+
+*/
diff --git a/memory-init-layout-doc/src/main.rs b/memory-init-layout-doc/src/main.rs
index 386d4bcdee454b8fe622c97c5ee08871a1b6646c..67a2e3d9154eb441d0f58a14e3d64d6f0eeaeabc 100644
--- a/memory-init-layout-doc/src/main.rs
+++ b/memory-init-layout-doc/src/main.rs
@@ -1,249 +1,20 @@
-//! Memory layout & initialization in Rust — mini-docs + runnable examples
-//!
-//! Topics:
-//!  1) MaybeUninit<T>: uninitialized memory, manual init, *zeroing is not init*, safe patterns
-//!  2) ManuallyDrop<T>: suppress Drop (FFI buffers, unions); compare with mem::forget
-//!  3) Niche optimization & NonZero*: how `Option<NonZeroUsize>` is one word; `Option<&T>` too
-//!
-//! Run: `cargo run`
-
-use std::{
-    mem::{self, ManuallyDrop, MaybeUninit, size_of},
-    num::{NonZeroU8, NonZeroUsize},
-    ptr,
+use memory_init_layout_doc::{
+    ex_maybeuninit_array,
+    ex_maybeuninit_out_param,
+    ex_zeroing_note,
+    ex_manuallydrop_basics,
+    ex_manuallydrop_ffi_style,
+    ex_niche_sizes,
+    ex_nonzero_api,
 };
 
-/* ───────────────────────────── 1) MaybeUninit<T> ─────────────────────────────
-`MaybeUninit<T>` lets you handle memory that is not (yet) initialized, without
-immediately invoking UB. You *must* initialize every byte of a `T` before you
-treat it as a `T`.
-
-Key APIs you’ll typically use:
-- `MaybeUninit::<T>::uninit()`                 // uninitialized slot
-- `MaybeUninit::<T>::new(value)`               // initialized slot
-- `slot.write(value)`                          // write without reading old
-- `assume_init()`                              // turn into T (only if fully init!)
-- Arrays: `MaybeUninit::uninit_array()` + `MaybeUninit::array_assume_init(...)`
-*/
-
-fn ex_maybeuninit_array() {
-    println!("== 1a) MaybeUninit: initialize array element-by-element ==");
-    const N: usize = 4;
-
-    // Allocate uninitialized array of T
-    let mut buf: [MaybeUninit<String>; N] = MaybeUninit::uninit_array();
-
-    // Initialize each element *exactly once*
-    for i in 0..N {
-        let s = format!("item-{i}");
-        buf[i].write(s);
-    }
-
-    // SAFETY: we wrote all elements; no panics in between → fully initialized
-    let arr: [String; N] = unsafe { MaybeUninit::array_assume_init(buf) };
-    println!("array = {:?}", arr);
-}
-
-fn ex_maybeuninit_out_param() {
-    println!("\n== 1b) MaybeUninit: out-parameter pattern ==");
-    // Pretend we call an FFI that writes into a provided slot.
-    #[inline]
-    unsafe fn produce_into(slot: *mut u32) {
-        // Initialize without reading the old memory:
-        ptr::write(slot, 0xABCD_FFFF);
-    }
-
-    let mut slot: MaybeUninit<u32> = MaybeUninit::uninit();
-    unsafe {
-        produce_into(slot.as_mut_ptr());
-        let val: u32 = slot.assume_init(); // fully initialized by callee
-        println!("produced = 0x{val:08X}");
-    }
-}
-
-/* ────────────────── “Zeroing is not init” (when it is / isn’t) ──────────────────
-- For *plain old data* (POD) where the all-zero bit pattern is a valid value (e.g., u32),
-  `MaybeUninit::<u32>::zeroed().assume_init()` is fine.
-- For types like `String`, `Vec<T>`, `Box<T>`, zero bytes are NOT a valid representation
-  (would violate their invariants) → assuming init after zeroing is UB.
-
-We’ll demonstrate “okay” vs “not okay” in comments + a safe example:
-*/
-
-fn ex_zeroing_note() {
-    println!("\n== 1c) Zeroing: when it’s okay vs UB ==");
-    // OK: integers/pointers where 0 is valid
-    let x = unsafe { MaybeUninit::<u32>::zeroed().assume_init() };
-    println!("zeroed u32 = {x}");
-
-    // ❌ NEVER do this (UB):
-    // let s = unsafe { MaybeUninit::<String>::zeroed().assume_init() };
-
-    // If you need a default String, *construct* it:
-    let s = String::new();
-    println!("constructed String OK: {:?}", s);
-}
-
-/* Safe patterns with MaybeUninit:
-- Build arrays of non-Copy / no-Default elements, then assume_init after fully filling.
-- Use `.write(...)` to overwrite uninitialized / possibly-garbage bytes without reading them.
-- If initialization can fail mid-way, use a guard to drop already-initialized elements before unwind.
-  (Omitted here for brevity; see std docs for a drop guard pattern.)
-*/
-
-/* ───────────────────────────── 2) ManuallyDrop<T> ─────────────────────────────
-Wrap a value to *suppress automatic Drop*. You can later:
-- extract it (consuming) via `ManuallyDrop::into_inner` (no Drop called on the wrapper),
-- or call `ManuallyDrop::drop(&mut x)` manually if/when you choose.
-
-Use cases:
-- FFI buffers whose ownership you transfer (avoid double-free),
-- unions containing non-Copy fields,
-- custom drop ordering.
-
-Compare with `mem::forget`: that *leaks* the value permanently. `ManuallyDrop`
-lets you control when/how to drop or extract it.
-*/
-
-fn ex_manuallydrop_basics() {
-    println!("\n== 2) ManuallyDrop basics, vs mem::forget ==");
-    #[derive(Debug)]
-    struct Loud(String);
-    impl Drop for Loud {
-        fn drop(&mut self) { println!("Drop(Loud: {:?})", self.0); }
-    }
-
-    // Suppress automatic drop
-    let m = ManuallyDrop::new(Loud("held".into()));
-    println!("wrapped: {:?}", unsafe { &*(&*m as *const Loud) });
-
-    // 2a) Extract the inner value without running Drop on the wrapper:
-    let inner: Loud = unsafe { ManuallyDrop::into_inner(m) };
-    println!("extracted {:?}", inner.0);
-    // Drop will run here (on `inner`) at end of scope.
-
-    // 2b) Forget permanently (leak) — not recommended unless you *intend* to leak:
-    let leak = Loud("leaked".into());
-    mem::forget(leak); // no Drop() call will happen for this one
-}
-
-/* A tiny FFI-flavored example: take ownership of a raw allocation and prevent double drop. */
-fn ex_manuallydrop_ffi_style() {
-    println!("\n== 2b) ManuallyDrop: ownership transfer (FFI style) ==");
-    // Imagine we received a Box<T> from C and must take ownership exactly once:
-    let p = Box::new(String::from("ffi-owned"));
-    let raw = Box::into_raw(p);           // C gives us this pointer…
-
-    // Wrap the would-be Box in ManuallyDrop so we can control drop vs extraction:
-    let mut wrapper: ManuallyDrop<Box<String>> = ManuallyDrop::new(unsafe { Box::from_raw(raw) });
-
-    // Decide to *extract* and keep ownership in safe Rust:
-    let owned_box: Box<String> = unsafe { ManuallyDrop::into_inner(ptr::read(&*wrapper)) };
-    // SAFETY: we read (copy) the ManuallyDrop<..> content by value, leaving a moved-from wrapper.
-    // We must not drop `wrapper` now (it contains moved value). That’s okay: it’s on the stack.
-
-    println!("owned_box = {:?}", owned_box);
-    // Drop occurs once, here, when owned_box goes out of scope.
-}
-
-/* ───────────── 3) Niche optimization & NonZero* (and pointers) ─────────────
-A “niche” is a bit-pattern that a type never uses. The compiler can pack an `Option<T>`
-into the same size as `T` by using the niche to encode `None`.
-
-Examples:
-- `NonZeroUsize` never uses 0 → `Option<NonZeroUsize>` is one word (0 encodes None).
-- `&T` pointers are never null → `Option<&T>` is one word (null encodes None).
-- `Box<T>` is non-null → `Option<Box<T>>` is one word too.
-
-This saves space and improves cache behavior without extra code.
-*/
-
-fn ex_niche_sizes() {
-    println!("\n== 3) Niche sizes (Option<T> size vs T) ==");
-    println!("usize                      = {}", size_of::<usize>());
-    println!("Option<usize>              = {}", size_of::<Option<usize>>()); // often also one word on many platforms
-    println!("NonZeroUsize               = {}", size_of::<NonZeroUsize>());
-    println!("Option<NonZeroUsize>       = {}", size_of::<Option<NonZeroUsize>>()); // == usize
-
-    println!("&u8                        = {}", size_of::<&u8>());
-    println!("Option<&u8>                = {}", size_of::<Option<&u8>>()); // == pointer size
-
-    println!("Box<u8>                    = {}", size_of::<Box<u8>>());
-    println!("Option<Box<u8>>            = {}", size_of::<Option<Box<u8>>>()); // == pointer size
-
-    println!("NonZeroU8                  = {}", size_of::<NonZeroU8>());
-    println!("Option<NonZeroU8>          = {}", size_of::<Option<NonZeroU8>>()); // == 1 byte
-}
-
-/* Using NonZero with Option in APIs */
-fn ex_nonzero_api() {
-    println!("\n== 3b) NonZero: ergonomic Option payloads ==");
-    fn next_id(prev: Option<NonZeroUsize>) -> Option<NonZeroUsize> {
-        // “0 means none” compactly encoded
-        Some(prev.map_or(NonZeroUsize::new(1).unwrap(), |nz| NonZeroUsize::new(nz.get() + 1).unwrap()))
-    }
-    let a = next_id(None).unwrap();
-    let b = next_id(Some(a)).unwrap();
-    println!("ids: {} -> {}", a.get(), b.get());
-}
-
 fn main() {
     ex_maybeuninit_array();
     ex_maybeuninit_out_param();
     ex_zeroing_note();
-
     ex_manuallydrop_basics();
     ex_manuallydrop_ffi_style();
-
     ex_niche_sizes();
     ex_nonzero_api();
-
     println!("\n== Cheatsheet in comments below ==");
 }
-
-/* ───────────────────────────── Docs-style notes ─────────────────────────────
-
-MAYBEUNINIT<T>
-- Use when you need a `T`’s storage before it’s fully initialized.
-- Correct patterns:
-  * Allocate: `let mut x: MaybeUninit<T> = MaybeUninit::uninit();`
-  * Write once: `x.write(value)` or via raw pointer `ptr::write(x.as_mut_ptr(), value)`.
-  * After fully initializing, convert: `unsafe { x.assume_init() }`.
-  * For arrays: `MaybeUninit::uninit_array()` + write each element + `array_assume_init(...)`.
-- Do NOT read from uninitialized memory. Do NOT call `assume_init` unless *every* byte is valid for `T`.
-- “Zeroing is not init” unless the all-zero bit pattern is valid for `T` (e.g., integers, some C POD).
-  Never zero-init `String`, `Vec<T>`, `Box<T>`, etc.
-
-MANUALLYDROP<T>
-- Prevents automatic Drop. Useful for:
-  * Transferring ownership across FFI boundaries (avoid double-free).
-  * Unions with non-Copy fields (control when to drop the active field).
-  * Custom drop order in complex structures.
-- Ways to use:
-  * `let m = ManuallyDrop::new(value);`  // no Drop at scope end
-  * Extract: `let v = unsafe { ManuallyDrop::into_inner(m) };` (consumes `m`)
-  * Drop now: `unsafe { ManuallyDrop::drop(&mut m) }`
-- `mem::forget(value)` *leaks* the value forever (never drops). Prefer `ManuallyDrop` when you still want control.
-
-NICHE OPTIMIZATION (size wins)
-- `Option<&T>` / `Option<Box<T>>` / `Option<NonZero*>` are the same size as their non-Option counterparts.
-  The compiler uses an invalid/unused representation (null or zero) to encode `None`.
-- Practically: choose `Option<NonZeroUsize>` instead of `Option<usize>` when you semantically exclude zero,
-  to guarantee the one-word layout and document the invariant.
-- This optimization is automatic. No unsafe needed.
-
-PITFALLS
-- UB magnets: calling `assume_init` too early; zero-initializing non-zeroable types; reading uninit bytes.
-- Mixing partial init with panics: if constructing a collection element-by-element, use a guard to drop
-  already-initialized elements on early exit.
-- With `ManuallyDrop`, be sure each value is dropped exactly once (or intentionally leaked).
-
-CHEATSHEET
-- Uninit array:        `let mut a: [MaybeUninit<T>; N] = MaybeUninit::uninit_array();`
-- Write elements:      `a[i].write(val);`
-- Finalize:            `let arr: [T; N] = unsafe { MaybeUninit::array_assume_init(a) };`
-- Suppress drop:       `let m = ManuallyDrop::new(v);`
-- Extract owned:       `let v = unsafe { ManuallyDrop::into_inner(m) };`
-- One-word Option:     `Option<NonZeroUsize>`, `Option<&T>`, `Option<Box<T>>`
-
-*/
diff --git a/ownership-egro-doc/src/lib.rs b/ownership-egro-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..8553be9ff7006fb43b669d42790ebd8f0fcc3c5f
--- /dev/null
+++ b/ownership-egro-doc/src/lib.rs
@@ -0,0 +1,305 @@
+//! Ownership Ergonomics in Rust — mini-docs + runnable examples
+//!
+//! Topics:
+//!  1) `Cow<'a, T>` (copy-on-write) for “borrow most, own occasionally”; `ToOwned`
+//!  2) Borrowing helpers: `Borrow`, `AsRef`, `Into`/`From` — flexible, zero-copy-ish APIs
+//!  3) Guard types: `MutexGuard`, `RwLockReadGuard`/`RwLockWriteGuard`, `Ref`/`RefMut`
+//!
+//! Run: `cargo run`
+
+use std::{
+    borrow::{Borrow, Cow, ToOwned},
+    cell::{RefCell, Ref, RefMut},
+    collections::HashMap,
+    path::{Path, PathBuf},
+    sync::{Arc, Mutex, MutexGuard, RwLock, RwLockReadGuard, RwLockWriteGuard},
+    thread,
+    time::Duration,
+};
+
+/* ───────────────────────────── 1) Cow<'a, T> ─────────────────────────────
+`Cow<'a, T>` = “Clone-On-Write”. It can be either:
+- `Cow::Borrowed(&'a T)` → zero-copy borrow
+- `Cow::Owned(T)`        → owned value you can mutate freely
+
+When you *need to mutate* a borrowed cow, call `to_mut()` — it clones into owned first
+(once), then you mutate the owned data. `Cow<T>` requires `T: ToOwned` (e.g., `str` ↔ `String`,
+`[T]` ↔ `Vec<T>`).
+*/
+
+fn normalize_whitespace<'a>(input: impl Into<Cow<'a, str>>) -> Cow<'a, str> {
+    let mut cow = input.into(); // may be borrowed or owned
+    if cow.contains('\t') || cow.contains('\n') {
+        // Need to modify: get mutable access; borrowed becomes owned here (clone-on-write).
+        let s = cow.to_mut();
+        *s = s.split_whitespace().collect::<Vec<_>>().join(" ");
+    }
+    cow
+}
+
+pub fn ex_cow_str() {
+    println!("== 1) Cow<'a, str> (copy-on-write) ==");
+    let borrowed: &str = "hello\tworld";
+    let owned: String = "no-tabs-here".to_string();
+
+    let a = normalize_whitespace(borrowed); // borrowed path → will clone because we modify
+    let b = normalize_whitespace(&owned);   // borrowed path (from &String) → no change, stays borrowed
+    let c = normalize_whitespace("a\nb\nc"); // &str → need to modify → becomes owned
+
+    println!("a = {:?} (owned? {})", a, matches!(a, Cow::Owned(_)));
+    println!("b = {:?} (borrowed? {})", b, matches!(b, Cow::Borrowed(_)));
+    println!("c = {:?} (owned? {})", c, matches!(c, Cow::Owned(_)));
+}
+
+/* ───────────────── 1b) Cow for slices: &[T] ↔ Vec<T> ─────────────────
+Useful when you usually pass a slice, but occasionally need to sort/unique/etc.
+*/
+
+fn sorted_unique<'a, T: Ord + Clone>(xs: impl Into<Cow<'a, [T]>>) -> Cow<'a, [T]> {
+    let mut cow = xs.into();
+    if !is_sorted_unique(&cow) {
+        let v = cow.to_mut(); // clone to Vec<T> only if we need to change
+        v.sort();
+        v.dedup();
+    }
+    cow
+}
+
+fn is_sorted_unique<T: Ord>(slice: &[T]) -> bool {
+    slice.windows(2).all(|w| w[0] < w[1])
+}
+
+pub fn ex_cow_slice() {
+    println!("\n== 1b) Cow<'a, [T]> ==");
+    let already_good = [1, 3, 5];
+    let needs_work = vec![3, 1, 3, 2];
+
+    let a = sorted_unique(&already_good[..]); // borrowed, unchanged
+    let b = sorted_unique(&needs_work[..]);   // must own to sort/dedup
+
+    println!("a: {:?} (borrowed? {})", a, matches!(a, Cow::Borrowed(_)));
+    println!("b: {:?} (owned? {})", b, matches!(b, Cow::Owned(_)));
+}
+
+/* ─────────────────── 2) Borrow, AsRef, Into / From ───────────────────
+Designing flexible APIs that accept many input types without copying.
+
+- `AsRef<T>`: “cheap reference-to-reference conversion”. Great for read-only APIs.
+  Examples: `AsRef<str>`, `AsRef<[u8]>`, `AsRef<Path>`.
+- `Borrow<Q>`: like AsRef but preserves *Eq/Hash* semantics for key lookup (used by collections).
+  Lets you look up `String` keys by `&str`, `PathBuf` by `&Path`, etc.
+- `Into<T>` / `From<T>`: move/convert into an owned type. Prefer `impl Into<T>` to be flexible.
+*/
+
+fn sum_bytes<A: AsRef<[u8]>>(data: A) -> u64 {
+    data.as_ref().iter().map(|&b| b as u64).sum()
+}
+
+fn print_path<P: AsRef<Path>>(p: P) {
+    let path: &Path = p.as_ref();
+    println!("path = {}", path.display());
+}
+
+// Lookup by borrowed key using Borrow<Q>
+fn borrow_lookup_demo() {
+    let mut map: HashMap<String, usize> = HashMap::new();
+    map.insert("alpha".into(), 1);
+    map.insert("beta".into(), 2);
+
+    // Query with &str although map keys are String
+    let k: &str = "alpha";
+    // HashMap::get<Q: ?Sized>(&self, k: &Q) where String: Borrow<Q>, Q: Eq + Hash
+    println!("get(\"alpha\") = {:?}", map.get(k)); // Some(&1)
+}
+
+// Owning conversion (Into/From) — commonly used when the callee needs to own the value.
+fn needs_owned<S: Into<String>>(s: S) -> String {
+    let owned: String = s.into();
+    owned + "!"
+}
+
+pub fn ex_borrow_asref_into() {
+    println!("\n== 2) Borrow / AsRef / Into ==");
+    // AsRef examples
+    println!("sum_bytes(&[1,2,3]) = {}", sum_bytes(&[1u8, 2, 3]));
+    println!("sum_bytes(Vec)      = {}", sum_bytes(vec![4u8, 5, 6]));
+    print_path("Cargo.toml");
+    print_path(PathBuf::from("src/main.rs"));
+
+    // Borrow for lookups
+    borrow_lookup_demo();
+
+    // Into for owned conversions
+    println!("needs_owned(\"hi\") = {}", needs_owned("hi"));
+    println!("needs_owned(String) = {}", needs_owned(String::from("yo")));
+}
+
+/* ────────────────────────── 3) Guard types ──────────────────────────
+"Guards" are values that *own a lock or a borrow* and implement `Deref`/`DerefMut`
+to access the protected inner value. When the guard is dropped, the lock/borrow is released.
+
+- `MutexGuard<'a, T>`: holds exclusive lock on `Mutex<T>` for `'a`
+- `RwLockReadGuard<'a, T>`: shared (read) lock on `RwLock<T>`
+- `RwLockWriteGuard<'a, T>`: exclusive (write) lock on `RwLock<T>`
+- `Ref<'a, T>` / `RefMut<'a, T>`: dynamic borrow guards from `RefCell<T>`
+
+Key lifetime rule:
+- You *cannot* return `&T` that outlives the guard; the reference is tied to the guard’s lifetime.
+- Prefer returning an *owned* value (clone/copy) or confine use to the closure scope (“with_*” pattern).
+*/
+
+pub fn ex_mutex_guard_lifetimes() {
+    println!("\n== 3a) MutexGuard lifetimes ==");
+    let m = Mutex::new(String::from("secret"));
+
+    // Scope the guard (keep lock short-lived):
+    {
+        let mut guard: MutexGuard<'_, String> = m.lock().unwrap();
+        guard.push_str(" sauce");
+        println!("inside lock: {}", *guard);
+    } // guard dropped here → lock released
+
+    // If you need data outside the lock, clone/move it out while holding the guard:
+    let extracted: String = {
+        let guard = m.lock().unwrap();
+        guard.clone() // clone small amount of data; then guard drops
+    };
+    println!("outside lock (cloned) = {}", extracted);
+
+    // Pattern: "with_lock" to restrict guard lifetime to a closure
+    fn with_lock<T, R, F: FnOnce(&mut T) -> R>(m: &Mutex<T>, f: F) -> R {
+        let mut g = m.lock().unwrap();
+        f(&mut *g)
+        // g drops here
+    }
+    let len = with_lock(&m, |s| s.len());
+    println!("with_lock len = {}", len);
+}
+
+pub fn ex_rwlock_guards() {
+    println!("\n== 3b) RwLock guards (many readers OR one writer) ==");
+    let data = RwLock::new(vec![1, 2, 3]);
+
+    // Many simultaneous readers
+    {
+        let r1: RwLockReadGuard<'_, Vec<i32>> = data.read().unwrap();
+        let r2 = data.read().unwrap();
+        println!("readers see: {:?} / {:?}", *r1, *r2);
+        // r1, r2 drop here
+    }
+
+    // Exclusive writer
+    {
+        let mut w: RwLockWriteGuard<'_, Vec<i32>> = data.write().unwrap();
+        w.push(4);
+        println!("writer pushed: {:?}", *w);
+    }
+
+    // Another read
+    println!("after write: {:?}", *data.read().unwrap());
+}
+
+pub fn ex_refcell_guards_runtime() {
+    println!("\n== 3c) RefCell guards (Ref / RefMut) with runtime checks ==");
+    let cell = RefCell::new(String::from("hi"));
+
+    // Immutable borrow: multiple allowed
+    let r1: Ref<'_, String> = cell.borrow();
+    let r2 = cell.borrow();
+    println!("r1={}, r2={}", r1.as_str(), r2.as_str());
+    drop((r1, r2));
+
+    // Mutable borrow: exclusive — panics at runtime if violated
+    {
+        let mut m: RefMut<'_, String> = cell.borrow_mut();
+        m.push_str(" there");
+        println!("mut = {}", m.as_str());
+        // If we tried `let _r = cell.borrow();` here → panic!
+    }
+}
+
+/* ─────────────────────────── 3d) Guard pitfalls ───────────────────────────
+- Don’t hold a guard across slow IO / long computation → potential deadlocks/starvation.
+- Don’t try to return `&T` from a function by derefing a guard; return owned or close over a closure.
+- Avoid nested lock orders that can deadlock; standard trick: keep lock scopes small and consistent.
+*/
+
+pub fn ex_guard_pitfall_demo() {
+    println!("\n== 3d) Guard pitfalls (quick demo) ==");
+    let m1 = Arc::new(Mutex::new(0));
+    let m2 = Arc::new(Mutex::new(0));
+
+    // Bad: different lock order across threads can deadlock. We'll just *not* do it;
+    // instead, lock in a consistent order (address-based).
+    let a = m1.clone();
+    let b = m2.clone();
+    let t1 = thread::spawn(move || {
+        lock_both_in_order(&a, &b, |x, y| { *x += 1; *y += 1; });
+    });
+    let t2 = thread::spawn(move || {
+        lock_both_in_order(&m1, &m2, |x, y| { *x += 1; *y += 1; });
+    });
+    t1.join().unwrap();
+    t2.join().unwrap();
+    println!("m1={}, m2={}", *m1.lock().unwrap(), *m2.lock().unwrap());
+
+    fn lock_both_in_order<T, F: FnOnce(&mut T, &mut T)>(
+        a: &Mutex<T>,
+        b: &Mutex<T>,
+        f: F,
+    ) {
+        // Order by pointer address to avoid deadlock
+        let (first, second) = if (a as *const _) < (b as *const _) { (a, b) } else { (b, a) };
+        let mut g1 = first.lock().unwrap();
+        let mut g2 = second.lock().unwrap();
+        f(&mut *g1, &mut *g2);
+        // guards drop in reverse order as they go out of scope
+    }
+}
+
+/* ─────────────────────────────────── main ─────────────────────────────────── */
+
+
+/* ───────────────────────────── Docs-style notes ─────────────────────────────
+
+COW<'a, T>
+- Type: `enum Cow<'a, B: ToOwned + ?Sized> { Borrowed(&'a B), Owned(<B as ToOwned>::Owned) }`
+- Common aliases: `Cow<'a, str>` ↔ `String`, `Cow<'a, [T]>` ↔ `Vec<T>`.
+- Use when your function *often* returns a borrow but *sometimes* needs to allocate or modify.
+- Key methods: `Cow::Borrowed(_)/Owned(_)`, `into_owned()`, `to_mut()`, `is_borrowed()`/`is_owned()`.
+
+BORROW / ASREF / INTO (and FROM)
+- `AsRef<T>`: zero-cost ref conversion (borrow-in, borrow-out). Great for read-only params:
+  `fn f<P: AsRef<Path>>(p: P) { let p: &Path = p.as_ref(); }`
+- `Borrow<Q>`: like AsRef but preserves equality/hashing semantics — used in map/set lookups:
+  `HashMap<String, V>::get(&str)` works because `String: Borrow<str>`.
+- `Into<T>` / `From<T>`: owned conversions. Prefer `impl Into<T>` for parameters when the function
+  must *take ownership*. At call sites, both `T` and types convertible *into* `T` are accepted.
+  Blanket rule: `impl<T, U> Into<U> for T where U: From<T>` — if `From` exists, `Into` is auto-implemented.
+
+GUARD TYPES (lifetimes and patterns)
+- `MutexGuard<'a, T>`: holds the mutex lock until drop; deref to `&T` / `&mut T`. Don’t return `&T` that
+  outlives the guard; clone/move data you need outside the lock or use a closure (“with_lock”).
+- `RwLockReadGuard<'a, T>` / `RwLockWriteGuard<'a, T>`: many readers OR one writer; same lifetime rules.
+- `Ref<'a, T>` / `RefMut<'a, T>`: runtime-checked borrows from `RefCell<T>`. Violations panic. Think of them
+  as guards; keep them short-lived and don’t interleave conflicting borrows.
+
+API DESIGN QUICK TIPS
+- Read-only data → `&[T]`, `&str`, or generics `AsRef<[T]>`, `AsRef<str>`, `AsRef<Path>`.
+- Owned result sometimes, borrowed otherwise → return `Cow<'a, T>`.
+- Map lookups by borrowed form → use `Borrow<Q>` so users can pass `&str` for `String` keys, etc.
+- Must own input → `impl Into<String>` (or a custom type), call `.into()` internally.
+- Lock scope small; avoid holding guards across `.await` (in async) or slow IO / long compute sections.
+
+COMMON PITFALLS
+- Returning a reference derived from a guard — ties lifetime to the guard; either return owned or keep usage in the guard’s scope.
+- Using `RefCell` across threads — it’s *not* `Sync`. Use `Mutex`/`RwLock` (or async variants) for multi-threading.
+- Overusing `Into<String>` when you only need a `&str` — prefer `AsRef<str>` to avoid allocations.
+
+CHEATSHEET
+- Cow normalize:         `fn normalize<'a>(x: impl Into<Cow<'a, str>>) -> Cow<'a, str>`
+- Read-only param:       `fn f<A: AsRef<[u8]>>(a: A)`
+- Borrow lookup:         `map.get::<str>("key")` because `String: Borrow<str>`
+- Own if needed:         `fn g<S: Into<String>>(s: S) { let s = s.into(); }`
+- Mutex “with” pattern:  `fn with_lock<T,R,F:FnOnce(&mut T)->R>(m:&Mutex<T>, f:F)->R`
+*/
diff --git a/ownership-egro-doc/src/main.rs b/ownership-egro-doc/src/main.rs
index 5d1f5aa75387ceaaa18b2191db5aaab37c6f3c3f..286118289c4d3293e1c8fd2bbbb4a9ede43fd88a 100644
--- a/ownership-egro-doc/src/main.rs
+++ b/ownership-egro-doc/src/main.rs
@@ -1,316 +1,20 @@
-//! Ownership Ergonomics in Rust — mini-docs + runnable examples
-//!
-//! Topics:
-//!  1) `Cow<'a, T>` (copy-on-write) for “borrow most, own occasionally”; `ToOwned`
-//!  2) Borrowing helpers: `Borrow`, `AsRef`, `Into`/`From` — flexible, zero-copy-ish APIs
-//!  3) Guard types: `MutexGuard`, `RwLockReadGuard`/`RwLockWriteGuard`, `Ref`/`RefMut`
-//!
-//! Run: `cargo run`
-
-use std::{
-    borrow::{Borrow, Cow, ToOwned},
-    cell::{RefCell, Ref, RefMut},
-    collections::HashMap,
-    path::{Path, PathBuf},
-    sync::{Arc, Mutex, MutexGuard, RwLock, RwLockReadGuard, RwLockWriteGuard},
-    thread,
-    time::Duration,
+use ownership_egro_doc::{
+    ex_cow_str,
+    ex_cow_slice,
+    ex_borrow_asref_into,
+    ex_mutex_guard_lifetimes,
+    ex_rwlock_guards,
+    ex_refcell_guards_runtime,
+    ex_guard_pitfall_demo,
 };
 
-/* ───────────────────────────── 1) Cow<'a, T> ─────────────────────────────
-`Cow<'a, T>` = “Clone-On-Write”. It can be either:
-- `Cow::Borrowed(&'a T)` → zero-copy borrow
-- `Cow::Owned(T)`        → owned value you can mutate freely
-
-When you *need to mutate* a borrowed cow, call `to_mut()` — it clones into owned first
-(once), then you mutate the owned data. `Cow<T>` requires `T: ToOwned` (e.g., `str` ↔ `String`,
-`[T]` ↔ `Vec<T>`).
-*/
-
-fn normalize_whitespace<'a>(input: impl Into<Cow<'a, str>>) -> Cow<'a, str> {
-    let mut cow = input.into(); // may be borrowed or owned
-    if cow.contains('\t') || cow.contains('\n') {
-        // Need to modify: get mutable access; borrowed becomes owned here (clone-on-write).
-        let s = cow.to_mut();
-        *s = s.split_whitespace().collect::<Vec<_>>().join(" ");
-    }
-    cow
-}
-
-fn ex_cow_str() {
-    println!("== 1) Cow<'a, str> (copy-on-write) ==");
-    let borrowed: &str = "hello\tworld";
-    let owned: String = "no-tabs-here".to_string();
-
-    let a = normalize_whitespace(borrowed); // borrowed path → will clone because we modify
-    let b = normalize_whitespace(&owned);   // borrowed path (from &String) → no change, stays borrowed
-    let c = normalize_whitespace("a\nb\nc"); // &str → need to modify → becomes owned
-
-    println!("a = {:?} (owned? {})", a, matches!(a, Cow::Owned(_)));
-    println!("b = {:?} (borrowed? {})", b, matches!(b, Cow::Borrowed(_)));
-    println!("c = {:?} (owned? {})", c, matches!(c, Cow::Owned(_)));
-}
-
-/* ───────────────── 1b) Cow for slices: &[T] ↔ Vec<T> ─────────────────
-Useful when you usually pass a slice, but occasionally need to sort/unique/etc.
-*/
-
-fn sorted_unique<'a, T: Ord + Clone>(xs: impl Into<Cow<'a, [T]>>) -> Cow<'a, [T]> {
-    let mut cow = xs.into();
-    if !is_sorted_unique(&cow) {
-        let v = cow.to_mut(); // clone to Vec<T> only if we need to change
-        v.sort();
-        v.dedup();
-    }
-    cow
-}
-
-fn is_sorted_unique<T: Ord>(slice: &[T]) -> bool {
-    slice.windows(2).all(|w| w[0] < w[1])
-}
-
-fn ex_cow_slice() {
-    println!("\n== 1b) Cow<'a, [T]> ==");
-    let already_good = [1, 3, 5];
-    let needs_work = vec![3, 1, 3, 2];
-
-    let a = sorted_unique(&already_good[..]); // borrowed, unchanged
-    let b = sorted_unique(&needs_work[..]);   // must own to sort/dedup
-
-    println!("a: {:?} (borrowed? {})", a, matches!(a, Cow::Borrowed(_)));
-    println!("b: {:?} (owned? {})", b, matches!(b, Cow::Owned(_)));
-}
-
-/* ─────────────────── 2) Borrow, AsRef, Into / From ───────────────────
-Designing flexible APIs that accept many input types without copying.
-
-- `AsRef<T>`: “cheap reference-to-reference conversion”. Great for read-only APIs.
-  Examples: `AsRef<str>`, `AsRef<[u8]>`, `AsRef<Path>`.
-- `Borrow<Q>`: like AsRef but preserves *Eq/Hash* semantics for key lookup (used by collections).
-  Lets you look up `String` keys by `&str`, `PathBuf` by `&Path`, etc.
-- `Into<T>` / `From<T>`: move/convert into an owned type. Prefer `impl Into<T>` to be flexible.
-*/
-
-fn sum_bytes<A: AsRef<[u8]>>(data: A) -> u64 {
-    data.as_ref().iter().map(|&b| b as u64).sum()
-}
-
-fn print_path<P: AsRef<Path>>(p: P) {
-    let path: &Path = p.as_ref();
-    println!("path = {}", path.display());
-}
-
-// Lookup by borrowed key using Borrow<Q>
-fn borrow_lookup_demo() {
-    let mut map: HashMap<String, usize> = HashMap::new();
-    map.insert("alpha".into(), 1);
-    map.insert("beta".into(), 2);
-
-    // Query with &str although map keys are String
-    let k: &str = "alpha";
-    // HashMap::get<Q: ?Sized>(&self, k: &Q) where String: Borrow<Q>, Q: Eq + Hash
-    println!("get(\"alpha\") = {:?}", map.get(k)); // Some(&1)
-}
-
-// Owning conversion (Into/From) — commonly used when the callee needs to own the value.
-fn needs_owned<S: Into<String>>(s: S) -> String {
-    let owned: String = s.into();
-    owned + "!"
-}
-
-fn ex_borrow_asref_into() {
-    println!("\n== 2) Borrow / AsRef / Into ==");
-    // AsRef examples
-    println!("sum_bytes(&[1,2,3]) = {}", sum_bytes(&[1u8, 2, 3]));
-    println!("sum_bytes(Vec)      = {}", sum_bytes(vec![4u8, 5, 6]));
-    print_path("Cargo.toml");
-    print_path(PathBuf::from("src/main.rs"));
-
-    // Borrow for lookups
-    borrow_lookup_demo();
-
-    // Into for owned conversions
-    println!("needs_owned(\"hi\") = {}", needs_owned("hi"));
-    println!("needs_owned(String) = {}", needs_owned(String::from("yo")));
-}
-
-/* ────────────────────────── 3) Guard types ──────────────────────────
-"Guards" are values that *own a lock or a borrow* and implement `Deref`/`DerefMut`
-to access the protected inner value. When the guard is dropped, the lock/borrow is released.
-
-- `MutexGuard<'a, T>`: holds exclusive lock on `Mutex<T>` for `'a`
-- `RwLockReadGuard<'a, T>`: shared (read) lock on `RwLock<T>`
-- `RwLockWriteGuard<'a, T>`: exclusive (write) lock on `RwLock<T>`
-- `Ref<'a, T>` / `RefMut<'a, T>`: dynamic borrow guards from `RefCell<T>`
-
-Key lifetime rule:
-- You *cannot* return `&T` that outlives the guard; the reference is tied to the guard’s lifetime.
-- Prefer returning an *owned* value (clone/copy) or confine use to the closure scope (“with_*” pattern).
-*/
-
-fn ex_mutex_guard_lifetimes() {
-    println!("\n== 3a) MutexGuard lifetimes ==");
-    let m = Mutex::new(String::from("secret"));
-
-    // Scope the guard (keep lock short-lived):
-    {
-        let mut guard: MutexGuard<'_, String> = m.lock().unwrap();
-        guard.push_str(" sauce");
-        println!("inside lock: {}", *guard);
-    } // guard dropped here → lock released
-
-    // If you need data outside the lock, clone/move it out while holding the guard:
-    let extracted: String = {
-        let guard = m.lock().unwrap();
-        guard.clone() // clone small amount of data; then guard drops
-    };
-    println!("outside lock (cloned) = {}", extracted);
-
-    // Pattern: "with_lock" to restrict guard lifetime to a closure
-    fn with_lock<T, R, F: FnOnce(&mut T) -> R>(m: &Mutex<T>, f: F) -> R {
-        let mut g = m.lock().unwrap();
-        f(&mut *g)
-        // g drops here
-    }
-    let len = with_lock(&m, |s| s.len());
-    println!("with_lock len = {}", len);
-}
-
-fn ex_rwlock_guards() {
-    println!("\n== 3b) RwLock guards (many readers OR one writer) ==");
-    let data = RwLock::new(vec![1, 2, 3]);
-
-    // Many simultaneous readers
-    {
-        let r1: RwLockReadGuard<'_, Vec<i32>> = data.read().unwrap();
-        let r2 = data.read().unwrap();
-        println!("readers see: {:?} / {:?}", *r1, *r2);
-        // r1, r2 drop here
-    }
-
-    // Exclusive writer
-    {
-        let mut w: RwLockWriteGuard<'_, Vec<i32>> = data.write().unwrap();
-        w.push(4);
-        println!("writer pushed: {:?}", *w);
-    }
-
-    // Another read
-    println!("after write: {:?}", *data.read().unwrap());
-}
-
-fn ex_refcell_guards_runtime() {
-    println!("\n== 3c) RefCell guards (Ref / RefMut) with runtime checks ==");
-    let cell = RefCell::new(String::from("hi"));
-
-    // Immutable borrow: multiple allowed
-    let r1: Ref<'_, String> = cell.borrow();
-    let r2 = cell.borrow();
-    println!("r1={}, r2={}", r1.as_str(), r2.as_str());
-    drop((r1, r2));
-
-    // Mutable borrow: exclusive — panics at runtime if violated
-    {
-        let mut m: RefMut<'_, String> = cell.borrow_mut();
-        m.push_str(" there");
-        println!("mut = {}", m.as_str());
-        // If we tried `let _r = cell.borrow();` here → panic!
-    }
-}
-
-/* ─────────────────────────── 3d) Guard pitfalls ───────────────────────────
-- Don’t hold a guard across slow IO / long computation → potential deadlocks/starvation.
-- Don’t try to return `&T` from a function by derefing a guard; return owned or close over a closure.
-- Avoid nested lock orders that can deadlock; standard trick: keep lock scopes small and consistent.
-*/
-
-fn ex_guard_pitfall_demo() {
-    println!("\n== 3d) Guard pitfalls (quick demo) ==");
-    let m1 = Arc::new(Mutex::new(0));
-    let m2 = Arc::new(Mutex::new(0));
-
-    // Bad: different lock order across threads can deadlock. We'll just *not* do it;
-    // instead, lock in a consistent order (address-based).
-    let a = m1.clone();
-    let b = m2.clone();
-    let t1 = thread::spawn(move || {
-        lock_both_in_order(&a, &b, |x, y| { *x += 1; *y += 1; });
-    });
-    let t2 = thread::spawn(move || {
-        lock_both_in_order(&m1, &m2, |x, y| { *x += 1; *y += 1; });
-    });
-    t1.join().unwrap();
-    t2.join().unwrap();
-    println!("m1={}, m2={}", *m1.lock().unwrap(), *m2.lock().unwrap());
-
-    fn lock_both_in_order<T, F: FnOnce(&mut T, &mut T)>(
-        a: &Mutex<T>,
-        b: &Mutex<T>,
-        f: F,
-    ) {
-        // Order by pointer address to avoid deadlock
-        let (first, second) = if (a as *const _) < (b as *const _) { (a, b) } else { (b, a) };
-        let mut g1 = first.lock().unwrap();
-        let mut g2 = second.lock().unwrap();
-        f(&mut *g1, &mut *g2);
-        // guards drop in reverse order as they go out of scope
-    }
-}
-
-/* ─────────────────────────────────── main ─────────────────────────────────── */
-
 fn main() {
     ex_cow_str();
     ex_cow_slice();
     ex_borrow_asref_into();
     ex_mutex_guard_lifetimes();
     ex_rwlock_guards();
     ex_refcell_guards_runtime();
     ex_guard_pitfall_demo();
-
     println!("\n== Cheatsheet in comments below ==");
 }
-
-/* ───────────────────────────── Docs-style notes ─────────────────────────────
-
-COW<'a, T>
-- Type: `enum Cow<'a, B: ToOwned + ?Sized> { Borrowed(&'a B), Owned(<B as ToOwned>::Owned) }`
-- Common aliases: `Cow<'a, str>` ↔ `String`, `Cow<'a, [T]>` ↔ `Vec<T>`.
-- Use when your function *often* returns a borrow but *sometimes* needs to allocate or modify.
-- Key methods: `Cow::Borrowed(_)/Owned(_)`, `into_owned()`, `to_mut()`, `is_borrowed()`/`is_owned()`.
-
-BORROW / ASREF / INTO (and FROM)
-- `AsRef<T>`: zero-cost ref conversion (borrow-in, borrow-out). Great for read-only params:
-  `fn f<P: AsRef<Path>>(p: P) { let p: &Path = p.as_ref(); }`
-- `Borrow<Q>`: like AsRef but preserves equality/hashing semantics — used in map/set lookups:
-  `HashMap<String, V>::get(&str)` works because `String: Borrow<str>`.
-- `Into<T>` / `From<T>`: owned conversions. Prefer `impl Into<T>` for parameters when the function
-  must *take ownership*. At call sites, both `T` and types convertible *into* `T` are accepted.
-  Blanket rule: `impl<T, U> Into<U> for T where U: From<T>` — if `From` exists, `Into` is auto-implemented.
-
-GUARD TYPES (lifetimes and patterns)
-- `MutexGuard<'a, T>`: holds the mutex lock until drop; deref to `&T` / `&mut T`. Don’t return `&T` that
-  outlives the guard; clone/move data you need outside the lock or use a closure (“with_lock”).
-- `RwLockReadGuard<'a, T>` / `RwLockWriteGuard<'a, T>`: many readers OR one writer; same lifetime rules.
-- `Ref<'a, T>` / `RefMut<'a, T>`: runtime-checked borrows from `RefCell<T>`. Violations panic. Think of them
-  as guards; keep them short-lived and don’t interleave conflicting borrows.
-
-API DESIGN QUICK TIPS
-- Read-only data → `&[T]`, `&str`, or generics `AsRef<[T]>`, `AsRef<str>`, `AsRef<Path>`.
-- Owned result sometimes, borrowed otherwise → return `Cow<'a, T>`.
-- Map lookups by borrowed form → use `Borrow<Q>` so users can pass `&str` for `String` keys, etc.
-- Must own input → `impl Into<String>` (or a custom type), call `.into()` internally.
-- Lock scope small; avoid holding guards across `.await` (in async) or slow IO / long compute sections.
-
-COMMON PITFALLS
-- Returning a reference derived from a guard — ties lifetime to the guard; either return owned or keep usage in the guard’s scope.
-- Using `RefCell` across threads — it’s *not* `Sync`. Use `Mutex`/`RwLock` (or async variants) for multi-threading.
-- Overusing `Into<String>` when you only need a `&str` — prefer `AsRef<str>` to avoid allocations.
-
-CHEATSHEET
-- Cow normalize:         `fn normalize<'a>(x: impl Into<Cow<'a, str>>) -> Cow<'a, str>`
-- Read-only param:       `fn f<A: AsRef<[u8]>>(a: A)`
-- Borrow lookup:         `map.get::<str>("key")` because `String: Borrow<str>`
-- Own if needed:         `fn g<S: Into<String>>(s: S) { let s = s.into(); }`
-- Mutex “with” pattern:  `fn with_lock<T,R,F:FnOnce(&mut T)->R>(m:&Mutex<T>, f:F)->R`
-*/
diff --git a/pattern-matchine-docs/src/lib.rs b/pattern-matchine-docs/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..4b9dc90ba2c4364e15182ea834c3657876890301
--- /dev/null
+++ b/pattern-matchine-docs/src/lib.rs
@@ -0,0 +1,234 @@
+//! Pattern Matching in Rust — mini-docs + runnable examples
+//!
+//! Patterns let you concisely decompose and test data shapes in `match`, `let`, `if let`,
+//! `while let`, function params, and more. They’re exhaustive by default in `match`.
+
+#[derive(Debug)]
+struct User {
+    id: u32,
+    name: String,
+    email: Option<String>,
+}
+
+#[derive(Debug)]
+enum Shape {
+    Circle { r: f64 },
+    Rect { w: f64, h: f64 },
+    Unit,                    // unit-like
+}
+
+pub fn ex_match_basics(x: i32) {
+    println!("== match basics ==");
+    let msg = match x {
+        0 => "zero",
+        1 | 2 => "one or two",                 // alternatives
+        3..=9 => "three to nine (inclusive)",  // range
+        _ => "something else",                 // wildcard (exhaustiveness)
+    };
+    println!("x={x} -> {msg}");
+}
+
+pub fn ex_tuple_struct_enum() {
+    println!("\n== tuples, structs, enums ==");
+    let pair = (1, "hi", true);
+
+    // tuple destructuring in `let` is a pattern as well
+    let (a, b, c) = pair;
+    println!("tuple destructured: a={a}, b={b}, c={c}");
+
+    // struct destructuring (with `..` to ignore the rest)
+    let user = User { id: 42, name: "Roman".into(), email: Some("r@example.com".into()) };
+    let User { id, name, .. } = &user; // borrow destructure
+    println!("User fields (borrowed): id={id}, name={name}");
+
+    // enum matching
+    let s = Shape::Rect { w: 3.0, h: 5.0 };
+    match s {
+        Shape::Circle { r } => println!("circle r={r}"),
+        Shape::Rect { w, h } => println!("rect w={w}, h={h}"),
+        Shape::Unit => println!("unit"),
+    }
+}
+
+pub fn ex_option_result() {
+    println!("\n== Option / Result ==");
+    let maybe: Option<i32> = Some(10);
+    match maybe {
+        Some(v) if v % 2 == 0 => println!("even Some({v})"), // guard
+        Some(v) => println!("odd Some({v})"),
+        None => println!("None"),
+    }
+
+    let res: Result<&str, &str> = Err("boom");
+    match res {
+        Ok(v) => println!("Ok: {v}"),
+        Err(e) => println!("Err: {e}"),
+    }
+
+    // if let sugar for single-arm matches
+    if let Some(v) = maybe {
+        println!("if let got {v}");
+    }
+}
+
+pub fn ex_guards_bindings_ranges(x: i32) {
+    println!("\n== guards, @ bindings, ranges ==");
+    match x {
+        small @ -3..=3 => println!("small or near zero: {small}"), // bind + test range
+        n if n % 2 == 0 => println!("even by guard: {n}"),         // guard after pattern
+        _ => println!("other"),
+    }
+}
+
+pub fn ex_slice_patterns() {
+    println!("\n== slice patterns ==");
+    let data = [10, 20, 30, 40];
+
+    match data {
+        // fixed-size binding with prefix/suffix + rest (`..`) in the middle
+        [first, .., last] => println!("first={first}, last={last}"),
+    }
+
+    let v = vec![1, 2, 3, 4, 5];
+    match v.as_slice() {
+        [] => println!("empty"),
+        [x] => println!("one element: {x}"),
+        [x, y] => println!("two elements: {x},{y}"),
+        [head, mid @ .., tail] => {
+            println!("head={head}, tail={tail}, mid={:?}", mid);
+        }
+    }
+}
+
+pub fn ex_references_boxes() {
+    println!("\n== references & boxes ==");
+    let n = 10;
+    let r = &n;
+    match r {
+        // match on reference: pattern `&pat` peels one layer of reference
+        &val if val > 5 => println!("ref > 5: {val}"),
+        &val => println!("ref other: {val}"),
+    }
+
+    let b = Box::new(String::from("hello"));
+    match b {
+        // `box` pattern moves out of the Box (value owned here)
+        box s => println!("boxed string moved out: {s}"),
+    }
+}
+
+pub fn ex_while_let() {
+    println!("\n== while let ==");
+    let mut it = (1..=3).peekable();
+    // consume while pattern matches
+    while let Some(&next) = it.peek() {
+        println!("peek={next}");
+        it.next();
+    }
+}
+
+pub fn ex_matches_macro() {
+    println!("\n== matches! macro ==");
+    let s = Shape::Circle { r: 2.0 };
+    if matches!(s, Shape::Circle { .. }) {
+        println!("it is a circle!");
+    }
+}
+
+pub fn ex_ignore_parts() {
+    println!("\n== ignoring with _ and .. ==");
+    let user = User { id: 7, name: "Neo".into(), email: None };
+
+    match user {
+        User { id, .. } => println!("only care about id={id}"), // ignore others
+    }
+
+    // ignore some tuple parts
+    let coords = (3, 4, 5);
+    match coords {
+        (x, _, z) => println!("x={x}, z={z}"),
+    }
+}
+
+pub fn ex_shadowing_and_order() {
+    println!("\n== binding shadowing & arm order ==");
+    let x = 5;
+
+    match x {
+        1 | 2 => println!("one or two"),
+        // order matters: this guard arm runs before wildcard
+        n if n > 3 => println!(">3 via guard: {n}"),
+        _ => println!("something else"),
+    }
+
+    // shadowing pattern variables (separate from outer x)
+    let x_outer = 10;
+    match 42 {
+        x @ 40..=50 => println!("bound x={x} (shadows x_outer={x_outer})"),
+        _ => {}
+    }
+}
+
+pub fn ex_function_param_patterns() {
+    println!("\n== patterns in function params ==");
+    // destructure in params
+    fn sum_pair((a, b): (i32, i32)) -> i32 { a + b }
+    println!("sum_pair = {}", sum_pair((3, 4)));
+
+    // destructure struct param partially
+    fn show_user(User { id, name, .. }: &User) {
+        println!("User(id={id}, name={name})");
+    }
+    let u = User { id: 1, name: "Ada".into(), email: None };
+    show_user(&u);
+}
+
+
+/*
+Docs-style notes:
+
+Pattern positions:
+- `match expr { pat => ... }`
+- `let pat = expr;`
+- `if let pat = expr { ... }` / `while let pat = expr { ... }`
+- Function parameters: `fn f((a, b): (i32, i32))`
+- Closures too: `|User { id, .. }| ...`
+
+Common pattern tools:
+- `_`          : wildcard, ignore the value
+- `..`         : ignore “the rest” (structs, tuples, slices)
+- `|`          : alternatives (OR patterns)
+- Ranges       : `1..=5`, `'a'..='z'` (only with integer/char)
+- Guards       : `pat if condition`
+- `@` binding  : bind matched value while testing its shape (e.g., `n @ 0..=9`)
+- `&` / `&mut` : reference patterns peel ref layers (e.g., `&x`, `&mut y`)
+- `box`        : box pattern to move out of `Box<T>` (ownership transferred)
+
+Exhaustiveness:
+- `match` must be exhaustive. Add `_ => ...` or cover all variants.
+- Arm order matters; the first matching arm runs.
+
+Matching ergonomics:
+- Matching on references often auto-derefs; use `&pat` to bind by value of a reference.
+- Use `ref`/`ref mut` in older code; modern Rust prefers `&` / `&mut` patterns.
+
+Option/Result sugar:
+- `if let Some(x) = opt { ... }` for single-interest cases.
+- `while let Some(x) = iter.next() { ... }` to consume iterators.
+
+Slices:
+- Array/slice patterns support `[a, b]`, `[head, ..]`, `[.., tail]`, `[h, mid @ .., t]`.
+- `mid @ ..` binds the “rest” as a subslice.
+
+Ignoring:
+- `_` discards a single value; `..` discards multiple/remaining fields/elements.
+- Combine with explicit bindings to keep just what you need.
+
+Bindings:
+- `@` lets you both test a shape and keep the original: `n @ 1..=9`.
+
+Performance:
+- Patterns are zero-cost; the compiler generates optimal tests/binds.
+- Guards run only after the structural pattern matches.
+
+*/
diff --git a/pattern-matchine-docs/src/main.rs b/pattern-matchine-docs/src/main.rs
index 49635b8b9db06e417ff06286ad5c097bc3c6673a..6454c1d364d5c8e27aad7801b5ad02be7eb05c73 100644
--- a/pattern-matchine-docs/src/main.rs
+++ b/pattern-matchine-docs/src/main.rs
@@ -1,247 +1,27 @@
-//! Pattern Matching in Rust — mini-docs + runnable examples
-//!
-//! Patterns let you concisely decompose and test data shapes in `match`, `let`, `if let`,
-//! `while let`, function params, and more. They’re exhaustive by default in `match`.
-
-#[derive(Debug)]
-struct User {
-    id: u32,
-    name: String,
-    email: Option<String>,
-}
-
-#[derive(Debug)]
-enum Shape {
-    Circle { r: f64 },
-    Rect { w: f64, h: f64 },
-    Unit,                    // unit-like
-}
-
-fn ex_match_basics(x: i32) {
-    println!("== match basics ==");
-    let msg = match x {
-        0 => "zero",
-        1 | 2 => "one or two",                 // alternatives
-        3..=9 => "three to nine (inclusive)",  // range
-        _ => "something else",                 // wildcard (exhaustiveness)
-    };
-    println!("x={x} -> {msg}");
-}
-
-fn ex_tuple_struct_enum() {
-    println!("\n== tuples, structs, enums ==");
-    let pair = (1, "hi", true);
-
-    // tuple destructuring in `let` is a pattern as well
-    let (a, b, c) = pair;
-    println!("tuple destructured: a={a}, b={b}, c={c}");
-
-    // struct destructuring (with `..` to ignore the rest)
-    let user = User { id: 42, name: "Roman".into(), email: Some("r@example.com".into()) };
-    let User { id, name, .. } = &user; // borrow destructure
-    println!("User fields (borrowed): id={id}, name={name}");
-
-    // enum matching
-    let s = Shape::Rect { w: 3.0, h: 5.0 };
-    match s {
-        Shape::Circle { r } => println!("circle r={r}"),
-        Shape::Rect { w, h } => println!("rect w={w}, h={h}"),
-        Shape::Unit => println!("unit"),
-    }
-}
-
-fn ex_option_result() {
-    println!("\n== Option / Result ==");
-    let maybe: Option<i32> = Some(10);
-    match maybe {
-        Some(v) if v % 2 == 0 => println!("even Some({v})"), // guard
-        Some(v) => println!("odd Some({v})"),
-        None => println!("None"),
-    }
-
-    let res: Result<&str, &str> = Err("boom");
-    match res {
-        Ok(v) => println!("Ok: {v}"),
-        Err(e) => println!("Err: {e}"),
-    }
-
-    // if let sugar for single-arm matches
-    if let Some(v) = maybe {
-        println!("if let got {v}");
-    }
-}
-
-fn ex_guards_bindings_ranges(x: i32) {
-    println!("\n== guards, @ bindings, ranges ==");
-    match x {
-        small @ -3..=3 => println!("small or near zero: {small}"), // bind + test range
-        n if n % 2 == 0 => println!("even by guard: {n}"),         // guard after pattern
-        _ => println!("other"),
-    }
-}
-
-fn ex_slice_patterns() {
-    println!("\n== slice patterns ==");
-    let data = [10, 20, 30, 40];
-
-    match data {
-        // fixed-size binding with prefix/suffix + rest (`..`) in the middle
-        [first, .., last] => println!("first={first}, last={last}"),
-    }
-
-    let v = vec![1, 2, 3, 4, 5];
-    match v.as_slice() {
-        [] => println!("empty"),
-        [x] => println!("one element: {x}"),
-        [x, y] => println!("two elements: {x},{y}"),
-        [head, mid @ .., tail] => {
-            println!("head={head}, tail={tail}, mid={:?}", mid);
-        }
-    }
-}
-
-fn ex_references_boxes() {
-    println!("\n== references & boxes ==");
-    let n = 10;
-    let r = &n;
-    match r {
-        // match on reference: pattern `&pat` peels one layer of reference
-        &val if val > 5 => println!("ref > 5: {val}"),
-        &val => println!("ref other: {val}"),
-    }
-
-    let b = Box::new(String::from("hello"));
-    match b {
-        // `box` pattern moves out of the Box (value owned here)
-        box s => println!("boxed string moved out: {s}"),
-    }
-}
-
-fn ex_while_let() {
-    println!("\n== while let ==");
-    let mut it = (1..=3).peekable();
-    // consume while pattern matches
-    while let Some(&next) = it.peek() {
-        println!("peek={next}");
-        it.next();
-    }
-}
-
-fn ex_matches_macro() {
-    println!("\n== matches! macro ==");
-    let s = Shape::Circle { r: 2.0 };
-    if matches!(s, Shape::Circle { .. }) {
-        println!("it is a circle!");
-    }
-}
-
-fn ex_ignore_parts() {
-    println!("\n== ignoring with _ and .. ==");
-    let user = User { id: 7, name: "Neo".into(), email: None };
-
-    match user {
-        User { id, .. } => println!("only care about id={id}"), // ignore others
-    }
-
-    // ignore some tuple parts
-    let coords = (3, 4, 5);
-    match coords {
-        (x, _, z) => println!("x={x}, z={z}"),
-    }
-}
-
-fn ex_shadowing_and_order() {
-    println!("\n== binding shadowing & arm order ==");
-    let x = 5;
-
-    match x {
-        1 | 2 => println!("one or two"),
-        // order matters: this guard arm runs before wildcard
-        n if n > 3 => println!(">3 via guard: {n}"),
-        _ => println!("something else"),
-    }
-
-    // shadowing pattern variables (separate from outer x)
-    let x_outer = 10;
-    match 42 {
-        x @ 40..=50 => println!("bound x={x} (shadows x_outer={x_outer})"),
-        _ => {}
-    }
-}
-
-fn ex_function_param_patterns() {
-    println!("\n== patterns in function params ==");
-    // destructure in params
-    fn sum_pair((a, b): (i32, i32)) -> i32 { a + b }
-    println!("sum_pair = {}", sum_pair((3, 4)));
-
-    // destructure struct param partially
-    fn show_user(User { id, name, .. }: &User) {
-        println!("User(id={id}, name={name})");
-    }
-    let u = User { id: 1, name: "Ada".into(), email: None };
-    show_user(&u);
-}
+use pattern_matchine_docs::{
+    ex_match_basics,
+    ex_tuple_struct_enum,
+    ex_option_result,
+    ex_guards_bindings_ranges,
+    ex_slice_patterns,
+    ex_references_boxes,
+    ex_while_let,
+    ex_matches_macro,
+    ex_ignore_parts,
+    ex_shadowing_and_order,
+    ex_function_param_patterns,
+};
 
 fn main() {
     ex_match_basics(4);
     ex_tuple_struct_enum();
     ex_option_result();
     ex_guards_bindings_ranges(2);
     ex_slice_patterns();
     ex_references_boxes();
     ex_while_let();
     ex_matches_macro();
     ex_ignore_parts();
     ex_shadowing_and_order();
     ex_function_param_patterns();
 }
-
-/*
-Docs-style notes:
-
-Pattern positions:
-- `match expr { pat => ... }`
-- `let pat = expr;`
-- `if let pat = expr { ... }` / `while let pat = expr { ... }`
-- Function parameters: `fn f((a, b): (i32, i32))`
-- Closures too: `|User { id, .. }| ...`
-
-Common pattern tools:
-- `_`          : wildcard, ignore the value
-- `..`         : ignore “the rest” (structs, tuples, slices)
-- `|`          : alternatives (OR patterns)
-- Ranges       : `1..=5`, `'a'..='z'` (only with integer/char)
-- Guards       : `pat if condition`
-- `@` binding  : bind matched value while testing its shape (e.g., `n @ 0..=9`)
-- `&` / `&mut` : reference patterns peel ref layers (e.g., `&x`, `&mut y`)
-- `box`        : box pattern to move out of `Box<T>` (ownership transferred)
-
-Exhaustiveness:
-- `match` must be exhaustive. Add `_ => ...` or cover all variants.
-- Arm order matters; the first matching arm runs.
-
-Matching ergonomics:
-- Matching on references often auto-derefs; use `&pat` to bind by value of a reference.
-- Use `ref`/`ref mut` in older code; modern Rust prefers `&` / `&mut` patterns.
-
-Option/Result sugar:
-- `if let Some(x) = opt { ... }` for single-interest cases.
-- `while let Some(x) = iter.next() { ... }` to consume iterators.
-
-Slices:
-- Array/slice patterns support `[a, b]`, `[head, ..]`, `[.., tail]`, `[h, mid @ .., t]`.
-- `mid @ ..` binds the “rest” as a subslice.
-
-Ignoring:
-- `_` discards a single value; `..` discards multiple/remaining fields/elements.
-- Combine with explicit bindings to keep just what you need.
-
-Bindings:
-- `@` lets you both test a shape and keep the original: `n @ 1..=9`.
-
-Performance:
-- Patterns are zero-cost; the compiler generates optimal tests/binds.
-- Guards run only after the structural pattern matches.
-
-*/
diff --git a/pin-doc/src/lib.rs b/pin-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..8df47dfb557b778d510439600eb8bcbeb627c6c0
--- /dev/null
+++ b/pin-doc/src/lib.rs
@@ -0,0 +1,228 @@
+//! Pin<P> / Unpin in Rust — mini-docs + runnable examples
+//!
+//! TL;DR
+//! - Pinning prevents *moves* of a value after it’s been pinned (its memory address must not change).
+//! - `Unpin` (auto trait): types that are safe to move even when "pinned" (most types are `Unpin`).
+//! - You pin *pointers*: `Pin<&mut T>`, `Pin<Box<T>>`, (and via APIs, `Pin<Rc<T>>` / `Pin<Arc<T>>`).
+//! - You still can mutate pinned values; pinning restricts *relocation*, not *mutation*.
+//! - Futures from `async fn` are usually `!Unpin`, so executors **pin** them before polling.
+//!
+//! This file demonstrates:
+//!  1) Unpin basics and "pin as a no-op" when T: Unpin
+//!  2) Pinning on the heap with `Box::pin` and address stability
+//!  3) A `!Unpin` type via `PhantomPinned`: what you *can* and *cannot* do
+//!  4) Safe & unsafe APIs on `Pin`: `get_ref`, `get_mut` (needs `Unpin`), `as_mut`, `map_unchecked_mut`
+//!  5) Field projection basics (why it’s tricky) and a minimal, careful example
+//!  6) Notes on async/futures and pinning
+//!
+//! Run with: `cargo run`
+
+use std::marker::PhantomPinned;
+use std::mem::{size_of, take};
+use std::pin::Pin;
+use std::ptr;
+
+/// Pretty print an address (for demos)
+fn addr_of<T>(r: &T) -> usize { r as *const T as usize }
+
+/* ───────────────────────── 1) Unpin basics ─────────────────────────
+`Unpin` means: "even if pinned, moving this value is harmless".
+Most standard types are `Unpin` (e.g., integers, `String`, `Vec`, user structs
+composed of `Unpin` fields). If T: Unpin, pinning is largely a *type-level* marker.
+*/
+pub fn ex_unpin_basics() {
+    println!("== 1) Unpin basics ==");
+    // i32 is Unpin; Pin<&mut i32> can be created and freely moved as a pointer wrapper.
+    let mut x = 10i32;
+    let mut pinned_ref: Pin<&mut i32> = Pin::new(&mut x);
+    // Because i32: Unpin, we can get a &mut i32 back safely:
+    let r: &mut i32 = Pin::get_mut(&mut pinned_ref);
+    *r += 1;
+    println!("x after Pin::get_mut = {}", x);
+
+    println!("size_of::<Pin<&mut i32>>() = {}", size_of::<Pin<&mut i32>>());
+}
+
+/* ─────────────────── 2) Pin<Box<T>> and address stability ───────────────────
+Heap-pin a value: moving the Pin<Box<T>> variable moves only the BOX (a pointer),
+not the allocation containing T; T’s address remains stable.
+*/
+pub fn ex_box_pin_address_stability() {
+    println!("\n== 2) Pin<Box<T>> address stability ==");
+    let p = Box::pin(String::from("hello"));
+    // Take the address of the *inner* String on the heap:
+    let start_addr = addr_of(&*p);
+    println!("inner addr at start = 0x{start_addr:x}");
+
+    // Move the Pin<Box<String>> value around (ownership moves); inner address stays.
+    let p = move_pin(p);
+    let middle_addr = addr_of(&*p);
+    println!("inner addr after move_pin() = 0x{middle_addr:x}");
+
+    let p2 = p; // another move
+    let end_addr = addr_of(&*p2);
+    println!("inner addr after second move = 0x{end_addr:x}");
+
+    assert_eq!(start_addr, middle_addr);
+    assert_eq!(start_addr, end_addr);
+
+    // We can still mutate the string contents while pinned (pin restricts *relocation*, not mutation):
+    let mut p2 = p2;
+    let mut_ref: Pin<&mut String> = Pin::as_mut(&mut p2);
+    // Because String: Unpin, we may get &mut String back safely:
+    let s: &mut String = Pin::get_mut(mut_ref);
+    s.push_str(" world");
+    println!("value = {}", s);
+}
+fn move_pin(p: Pin<Box<String>>) -> Pin<Box<String>> { p }
+
+/* ───────────── 3) A !Unpin type with PhantomPinned ─────────────
+If a type is `!Unpin` (does NOT implement Unpin), moving it after pinning is
+*forbidden* (would be Undefined Behavior if you somehow did it). `PhantomPinned`
+opts out of Unpin automatically.
+*/
+#[derive(Debug)]
+struct SelfRef {
+    data: String,
+    // Imagine we want to hold a self-referential pointer/slice into `data`.
+    // We won't actually create it (that requires careful construction), but
+    // we mark the type as `!Unpin` so the compiler enforces pinning rules.
+    _pin: PhantomPinned, // makes the type `!Unpin`
+}
+
+pub fn ex_non_unpin_type() {
+    println!("\n== 3) !Unpin type with PhantomPinned ==");
+    // Allocate on heap and pin:
+    let mut s = Box::pin(SelfRef { data: String::from("abc"), _pin: PhantomPinned });
+
+    // You can access &SelfRef:
+    println!("pinned SelfRef.data = {}", s.data);
+
+    // You may *mutate fields* through a pinned mutable reference (carefully):
+    let mut s_pin_ref: Pin<&mut SelfRef> = Pin::as_mut(&mut s);
+    // We cannot move `s`'s value out; but we can modify `data` in place:
+    // To get &mut to a field, we must not move the whole struct. For Unpin fields,
+    // we can use unsafe projection helpers (see next section). As a trivial safe demo:
+    let new_data = take(&mut s_pin_ref.data); // `String` is Unpin; this replaces the field
+    println!("took data (moved out field safely): {new_data}");
+    // Put something back (still in-place field assignment):
+    s_pin_ref.data = String::from("replaced");
+    println!("now SelfRef.data = {}", s_pin_ref.data);
+
+    // Because SelfRef is !Unpin, the following is illegal:
+    // let moved = *s; // ❌ cannot move out (would require `SelfRef: Unpin`)
+    // let inner = Pin::into_inner(s); // ❌ requires T: Unpin; SelfRef is !Unpin
+}
+
+/* ───────────── 4) Pin API: safe vs unsafe (and why) ─────────────
+Key methods (selected):
+- Pin::new(&mut T)            -> Pin<&mut T>              (safe)    // create pinned ref from &mut
+- Box::pin(T)                 -> Pin<Box<T>>              (safe)    // allocate & pin on heap
+- Pin::get_ref(&Pin<&T>)      -> &T                       (safe)    // read-only access
+- Pin::as_mut(&mut Pin<P>)    -> Pin<&mut T>              (safe)    // reborrow as pinned &mut
+- Pin::get_mut(&mut Pin<P>)   -> &mut T                   (safe IFF T: Unpin)
+- Pin::into_inner(Pin<P>)     -> P::Target                (safe IFF T: Unpin)
+- Pin::new_unchecked(...)     -> Pin<...>                 (unsafe)  // caller must uphold pin invariants
+- map_unchecked_mut / map_unchecked   (unsafe)            // project fields (you must prove no move)
+*/
+#[derive(Debug)]
+struct Container {
+    a: String, // Unpin
+    b: u64,    // Unpin
+}
+pub fn ex_pin_api_and_projection() {
+    println!("\n== 4) Pin API & field projection (minimal) ==");
+    let mut c = Box::pin(Container { a: "hi".to_string(), b: 7 });
+
+    // Read-only access is easy & safe:
+    println!("a={}, b={}", Pin::get_ref(&c).a, Pin::get_ref(&c).b);
+
+    // Mutating through a pinned ref:
+    // Step 1: get a `Pin<&mut Container>`
+    let cref: Pin<&mut Container> = Pin::as_mut(&mut c);
+
+    // If we want a pinned reference to a *field*, we must "project" without moving the outer struct.
+    // The standard library doesn't auto-project; use crates (pin-project / pin-project-lite) in real code.
+    // For Unpin fields, it's sound to produce an *unpinned* &mut:
+    // SAFETY: We create an &mut to a field (`a`) without moving `Container`. That's fine.
+    let a_mut: &mut String = unsafe { Pin::get_unchecked_mut(cref) }.a.as_mut();
+    a_mut.push_str(" there");
+    println!("after edit, a = {}", Pin::get_ref(&c).a);
+
+    // If we needed a *pinned* projection (e.g., the field were `!Unpin`),
+    // we'd need `map_unchecked_mut` + proof that the field's address won't change relative to `c`.
+    // We won't do that here to keep things simple & safe.
+}
+
+/* ───────────── 5) Why field projection is hard (the short version) ─────────────
+If `T: !Unpin`, pinning `Pin<&mut T>` promises the *whole T* will not move.
+Projecting to a field and treating it as independently pinned requires proving that moving the
+outer T cannot occur without also moving the field — which is why safe projection is nontrivial.
+Crates like `pin-project` generate correct projections for you. Here we just explain the idea.
+*/
+
+/* ───────────── 6) Async & pinning (conceptual) ─────────────
+- `async fn` returns an *anonymous* `impl Future<Output = T>` that is **usually `!Unpin`**.
+- Executors (Tokio/etc.) **pin** futures before polling them: the state machine inside stores
+  self-references between `.await` points, so its address must not change.
+- If you manually poll a future, you typically do:
+    let mut fut = my_async();          // impl Future (likely !Unpin)
+    let mut fut = Box::pin(fut);       // Pin<Box<dyn Future>> or Pin<Box<_>>
+    use std::future::Future;
+    use std::task::{Context, Poll, Waker, RawWaker, RawWakerVTable};
+    // ... build a dummy Context and call fut.as_mut().poll(&mut cx)
+- Most apps never need manual poll; runtimes handle pinning for you.
+*/
+
+
+/*
+Docs-style notes:
+
+WHAT PINNING GUARANTEES
+- After a value is pinned, its memory location must not change (no "move").
+- You pin pointer types (`&mut T`, `Box<T>`, etc.), not values directly.
+- Moving the *pointer* (e.g., the Box itself) is OK; the allocation containing the value remains at a stable address.
+
+`Unpin` (auto trait)
+- If `T: Unpin`, it’s safe to move T even when pinned; pin is effectively a no-op for relocation.
+- Most types are Unpin. Types that are self-referential (or want to prevent moves) are `!Unpin`.
+- Opt out with `PhantomPinned` to make your type `!Unpin`.
+
+HOW TO CREATE PINS
+- Stack reference: `Pin::new(&mut t)` → `Pin<&mut T>` (valid for the borrow's lifetime).
+- Heap allocation: `Box::pin(t)` → `Pin<Box<T>>` (common for long-lived / async cases).
+- There are also APIs to pin in `Rc`/`Arc` on newer Rust versions; in practice, `Box::pin` is most common.
+
+SAFE ACCESSORS
+- `Pin::get_ref(&Pin<&T>) -> &T`                 // shared access
+- `Pin::as_mut(&mut Pin<P>) -> Pin<&mut T>`       // reborrow as pinned &mut
+- `Pin::get_mut(&mut Pin<P>) -> &mut T`           // only if T: Unpin
+- `Pin::into_inner(Pin<P>) -> T`                  // only if T: Unpin
+
+UNSAFE ACCESSORS (when you must prove “no move” yourself)
+- `Pin::new_unchecked(ptr)`                       // create a Pin without checks
+- `Pin::map_unchecked_mut`, `Pin::map_unchecked`  // project to fields
+- Rule of thumb: prefer a projection macro crate (`pin-project`) over handwritten unsafe.
+
+FIELD PROJECTION
+- Safe projection is hard because pinning is about the *whole* value. If you pin a struct and
+  want to pin an inner field, you must ensure the field can't outlive or move independently of the outer.
+- Libraries provide safe generated projections—use them.
+
+ASYNC CONNECTION
+- Futures from `async fn` are typically `!Unpin`; executors pin them. This is why you often see `Pin<Box<dyn Future>>` internally.
+- You rarely handle pinning explicitly in high-level async code; runtimes do it for you.
+
+COMMON PITFALLS
+- Thinking pinning prevents mutation—no, it prevents *relocation*. You can still mutate content.
+- Using `get_mut`/`into_inner` on `!Unpin` types—won’t compile (that’s the point).
+- Hand-rolling unsafe projection when you could use `pin-project(-lite)`.
+
+CHEAT SHEET
+- Pin a heap value:        `let p = Box::pin(val);`
+- Reborrow pinned mutably: `let p_mut = p.as_mut();`
+- Read fields:             `Pin::get_ref(&p).field`
+- Mutate Unpin field:      `unsafe { Pin::get_unchecked_mut(p_mut) }.field = ...`
+- Never move a `!Unpin` after pinning; keep borrows short & avoid mem::replace on the whole value.
+
+*/
diff --git a/pin-doc/src/main.rs b/pin-doc/src/main.rs
index e00ee1c83b6ef1f187744593a44abea9f0cfc2bb..5876cf4ecc5330255d43185d8f7ed03a66c7914e 100644
--- a/pin-doc/src/main.rs
+++ b/pin-doc/src/main.rs
@@ -1,237 +1,16 @@
-//! Pin<P> / Unpin in Rust — mini-docs + runnable examples
-//!
-//! TL;DR
-//! - Pinning prevents *moves* of a value after it’s been pinned (its memory address must not change).
-//! - `Unpin` (auto trait): types that are safe to move even when "pinned" (most types are `Unpin`).
-//! - You pin *pointers*: `Pin<&mut T>`, `Pin<Box<T>>`, (and via APIs, `Pin<Rc<T>>` / `Pin<Arc<T>>`).
-//! - You still can mutate pinned values; pinning restricts *relocation*, not *mutation*.
-//! - Futures from `async fn` are usually `!Unpin`, so executors **pin** them before polling.
-//!
-//! This file demonstrates:
-//!  1) Unpin basics and "pin as a no-op" when T: Unpin
-//!  2) Pinning on the heap with `Box::pin` and address stability
-//!  3) A `!Unpin` type via `PhantomPinned`: what you *can* and *cannot* do
-//!  4) Safe & unsafe APIs on `Pin`: `get_ref`, `get_mut` (needs `Unpin`), `as_mut`, `map_unchecked_mut`
-//!  5) Field projection basics (why it’s tricky) and a minimal, careful example
-//!  6) Notes on async/futures and pinning
-//!
-//! Run with: `cargo run`
-
-use std::marker::PhantomPinned;
-use std::mem::{size_of, take};
-use std::pin::Pin;
-use std::ptr;
-
-/// Pretty print an address (for demos)
-fn addr_of<T>(r: &T) -> usize { r as *const T as usize }
-
-/* ───────────────────────── 1) Unpin basics ─────────────────────────
-`Unpin` means: "even if pinned, moving this value is harmless".
-Most standard types are `Unpin` (e.g., integers, `String`, `Vec`, user structs
-composed of `Unpin` fields). If T: Unpin, pinning is largely a *type-level* marker.
-*/
-fn ex_unpin_basics() {
-    println!("== 1) Unpin basics ==");
-    // i32 is Unpin; Pin<&mut i32> can be created and freely moved as a pointer wrapper.
-    let mut x = 10i32;
-    let mut pinned_ref: Pin<&mut i32> = Pin::new(&mut x);
-    // Because i32: Unpin, we can get a &mut i32 back safely:
-    let r: &mut i32 = Pin::get_mut(&mut pinned_ref);
-    *r += 1;
-    println!("x after Pin::get_mut = {}", x);
-
-    println!("size_of::<Pin<&mut i32>>() = {}", size_of::<Pin<&mut i32>>());
-}
-
-/* ─────────────────── 2) Pin<Box<T>> and address stability ───────────────────
-Heap-pin a value: moving the Pin<Box<T>> variable moves only the BOX (a pointer),
-not the allocation containing T; T’s address remains stable.
-*/
-fn ex_box_pin_address_stability() {
-    println!("\n== 2) Pin<Box<T>> address stability ==");
-    let p = Box::pin(String::from("hello"));
-    // Take the address of the *inner* String on the heap:
-    let start_addr = addr_of(&*p);
-    println!("inner addr at start = 0x{start_addr:x}");
-
-    // Move the Pin<Box<String>> value around (ownership moves); inner address stays.
-    let p = move_pin(p);
-    let middle_addr = addr_of(&*p);
-    println!("inner addr after move_pin() = 0x{middle_addr:x}");
-
-    let p2 = p; // another move
-    let end_addr = addr_of(&*p2);
-    println!("inner addr after second move = 0x{end_addr:x}");
-
-    assert_eq!(start_addr, middle_addr);
-    assert_eq!(start_addr, end_addr);
-
-    // We can still mutate the string contents while pinned (pin restricts *relocation*, not mutation):
-    let mut p2 = p2;
-    let mut_ref: Pin<&mut String> = Pin::as_mut(&mut p2);
-    // Because String: Unpin, we may get &mut String back safely:
-    let s: &mut String = Pin::get_mut(mut_ref);
-    s.push_str(" world");
-    println!("value = {}", s);
-}
-fn move_pin(p: Pin<Box<String>>) -> Pin<Box<String>> { p }
-
-/* ───────────── 3) A !Unpin type with PhantomPinned ─────────────
-If a type is `!Unpin` (does NOT implement Unpin), moving it after pinning is
-*forbidden* (would be Undefined Behavior if you somehow did it). `PhantomPinned`
-opts out of Unpin automatically.
-*/
-#[derive(Debug)]
-struct SelfRef {
-    data: String,
-    // Imagine we want to hold a self-referential pointer/slice into `data`.
-    // We won't actually create it (that requires careful construction), but
-    // we mark the type as `!Unpin` so the compiler enforces pinning rules.
-    _pin: PhantomPinned, // makes the type `!Unpin`
-}
-
-fn ex_non_unpin_type() {
-    println!("\n== 3) !Unpin type with PhantomPinned ==");
-    // Allocate on heap and pin:
-    let mut s = Box::pin(SelfRef { data: String::from("abc"), _pin: PhantomPinned });
-
-    // You can access &SelfRef:
-    println!("pinned SelfRef.data = {}", s.data);
-
-    // You may *mutate fields* through a pinned mutable reference (carefully):
-    let mut s_pin_ref: Pin<&mut SelfRef> = Pin::as_mut(&mut s);
-    // We cannot move `s`'s value out; but we can modify `data` in place:
-    // To get &mut to a field, we must not move the whole struct. For Unpin fields,
-    // we can use unsafe projection helpers (see next section). As a trivial safe demo:
-    let new_data = take(&mut s_pin_ref.data); // `String` is Unpin; this replaces the field
-    println!("took data (moved out field safely): {new_data}");
-    // Put something back (still in-place field assignment):
-    s_pin_ref.data = String::from("replaced");
-    println!("now SelfRef.data = {}", s_pin_ref.data);
-
-    // Because SelfRef is !Unpin, the following is illegal:
-    // let moved = *s; // ❌ cannot move out (would require `SelfRef: Unpin`)
-    // let inner = Pin::into_inner(s); // ❌ requires T: Unpin; SelfRef is !Unpin
-}
-
-/* ───────────── 4) Pin API: safe vs unsafe (and why) ─────────────
-Key methods (selected):
-- Pin::new(&mut T)            -> Pin<&mut T>              (safe)    // create pinned ref from &mut
-- Box::pin(T)                 -> Pin<Box<T>>              (safe)    // allocate & pin on heap
-- Pin::get_ref(&Pin<&T>)      -> &T                       (safe)    // read-only access
-- Pin::as_mut(&mut Pin<P>)    -> Pin<&mut T>              (safe)    // reborrow as pinned &mut
-- Pin::get_mut(&mut Pin<P>)   -> &mut T                   (safe IFF T: Unpin)
-- Pin::into_inner(Pin<P>)     -> P::Target                (safe IFF T: Unpin)
-- Pin::new_unchecked(...)     -> Pin<...>                 (unsafe)  // caller must uphold pin invariants
-- map_unchecked_mut / map_unchecked   (unsafe)            // project fields (you must prove no move)
-*/
-#[derive(Debug)]
-struct Container {
-    a: String, // Unpin
-    b: u64,    // Unpin
-}
-fn ex_pin_api_and_projection() {
-    println!("\n== 4) Pin API & field projection (minimal) ==");
-    let mut c = Box::pin(Container { a: "hi".to_string(), b: 7 });
-
-    // Read-only access is easy & safe:
-    println!("a={}, b={}", Pin::get_ref(&c).a, Pin::get_ref(&c).b);
-
-    // Mutating through a pinned ref:
-    // Step 1: get a `Pin<&mut Container>`
-    let cref: Pin<&mut Container> = Pin::as_mut(&mut c);
-
-    // If we want a pinned reference to a *field*, we must "project" without moving the outer struct.
-    // The standard library doesn't auto-project; use crates (pin-project / pin-project-lite) in real code.
-    // For Unpin fields, it's sound to produce an *unpinned* &mut:
-    // SAFETY: We create an &mut to a field (`a`) without moving `Container`. That's fine.
-    let a_mut: &mut String = unsafe { Pin::get_unchecked_mut(cref) }.a.as_mut();
-    a_mut.push_str(" there");
-    println!("after edit, a = {}", Pin::get_ref(&c).a);
-
-    // If we needed a *pinned* projection (e.g., the field were `!Unpin`),
-    // we'd need `map_unchecked_mut` + proof that the field's address won't change relative to `c`.
-    // We won't do that here to keep things simple & safe.
-}
-
-/* ───────────── 5) Why field projection is hard (the short version) ─────────────
-If `T: !Unpin`, pinning `Pin<&mut T>` promises the *whole T* will not move.
-Projecting to a field and treating it as independently pinned requires proving that moving the
-outer T cannot occur without also moving the field — which is why safe projection is nontrivial.
-Crates like `pin-project` generate correct projections for you. Here we just explain the idea.
-*/
-
-/* ───────────── 6) Async & pinning (conceptual) ─────────────
-- `async fn` returns an *anonymous* `impl Future<Output = T>` that is **usually `!Unpin`**.
-- Executors (Tokio/etc.) **pin** futures before polling them: the state machine inside stores
-  self-references between `.await` points, so its address must not change.
-- If you manually poll a future, you typically do:
-    let mut fut = my_async();          // impl Future (likely !Unpin)
-    let mut fut = Box::pin(fut);       // Pin<Box<dyn Future>> or Pin<Box<_>>
-    use std::future::Future;
-    use std::task::{Context, Poll, Waker, RawWaker, RawWakerVTable};
-    // ... build a dummy Context and call fut.as_mut().poll(&mut cx)
-- Most apps never need manual poll; runtimes handle pinning for you.
-*/
+use pin_doc::{
+    ex_unpin_basics,
+    ex_box_pin_address_stability,
+    ex_non_unpin_type,
+    ex_pin_api_and_projection,
+};
 
 fn main() {
     ex_unpin_basics();
     ex_box_pin_address_stability();
     ex_non_unpin_type();
     ex_pin_api_and_projection();
 
     println!("\n== Extra notes ==");
     println!("Most types are Unpin; pinning primarily matters for `!Unpin` (self-referential, async state).");
 }
-
-/*
-Docs-style notes:
-
-WHAT PINNING GUARANTEES
-- After a value is pinned, its memory location must not change (no "move").
-- You pin pointer types (`&mut T`, `Box<T>`, etc.), not values directly.
-- Moving the *pointer* (e.g., the Box itself) is OK; the allocation containing the value remains at a stable address.
-
-`Unpin` (auto trait)
-- If `T: Unpin`, it’s safe to move T even when pinned; pin is effectively a no-op for relocation.
-- Most types are Unpin. Types that are self-referential (or want to prevent moves) are `!Unpin`.
-- Opt out with `PhantomPinned` to make your type `!Unpin`.
-
-HOW TO CREATE PINS
-- Stack reference: `Pin::new(&mut t)` → `Pin<&mut T>` (valid for the borrow's lifetime).
-- Heap allocation: `Box::pin(t)` → `Pin<Box<T>>` (common for long-lived / async cases).
-- There are also APIs to pin in `Rc`/`Arc` on newer Rust versions; in practice, `Box::pin` is most common.
-
-SAFE ACCESSORS
-- `Pin::get_ref(&Pin<&T>) -> &T`                 // shared access
-- `Pin::as_mut(&mut Pin<P>) -> Pin<&mut T>`       // reborrow as pinned &mut
-- `Pin::get_mut(&mut Pin<P>) -> &mut T`           // only if T: Unpin
-- `Pin::into_inner(Pin<P>) -> T`                  // only if T: Unpin
-
-UNSAFE ACCESSORS (when you must prove “no move” yourself)
-- `Pin::new_unchecked(ptr)`                       // create a Pin without checks
-- `Pin::map_unchecked_mut`, `Pin::map_unchecked`  // project to fields
-- Rule of thumb: prefer a projection macro crate (`pin-project`) over handwritten unsafe.
-
-FIELD PROJECTION
-- Safe projection is hard because pinning is about the *whole* value. If you pin a struct and
-  want to pin an inner field, you must ensure the field can't outlive or move independently of the outer.
-- Libraries provide safe generated projections—use them.
-
-ASYNC CONNECTION
-- Futures from `async fn` are typically `!Unpin`; executors pin them. This is why you often see `Pin<Box<dyn Future>>` internally.
-- You rarely handle pinning explicitly in high-level async code; runtimes do it for you.
-
-COMMON PITFALLS
-- Thinking pinning prevents mutation—no, it prevents *relocation*. You can still mutate content.
-- Using `get_mut`/`into_inner` on `!Unpin` types—won’t compile (that’s the point).
-- Hand-rolling unsafe projection when you could use `pin-project(-lite)`.
-
-CHEAT SHEET
-- Pin a heap value:        `let p = Box::pin(val);`
-- Reborrow pinned mutably: `let p_mut = p.as_mut();`
-- Read fields:             `Pin::get_ref(&p).field`
-- Mutate Unpin field:      `unsafe { Pin::get_unchecked_mut(p_mut) }.field = ...`
-- Never move a `!Unpin` after pinning; keep borrows short & avoid mem::replace on the whole value.
-
-*/
diff --git a/rc-doc/src/lib.rs b/rc-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..861839d9f5fe48881e3de24048518e96c555162c
--- /dev/null
+++ b/rc-doc/src/lib.rs
@@ -0,0 +1,138 @@
+//! Rc<T> mini-docs + runnable examples in one file
+//!
+//! What is Rc<T>?
+//! - Single-threaded reference-counted smart pointer.
+//! - Enables multiple owners of the same heap value.
+//! - Cloning is cheap (increments strong refcount).
+//! - Not thread-safe (use Arc<T> for multi-threading).
+//!
+//! Common combos:
+//! - Rc<T> alone -> shared immutable ownership
+//! - Rc<RefCell<T>> -> shared + interior-mutable (single-thread)
+//! - Rc<Something> + Weak<Something> -> shared graphs without cycles
+
+use std::cell::RefCell;
+use std::rc::{Rc, Weak};
+
+pub fn example_basic() {
+    println!("== Example 1: Basic Rc usage ==");
+    let a = Rc::new("hello".to_string());
+
+    let b = Rc::clone(&a); // same as a.clone()
+    let c = a.clone();
+
+    println!("a = {a}, b = {b}, c = {c}");
+    println!("strong_count(a) = {}", Rc::strong_count(&a)); // 3
+
+    drop(b);
+    println!("after drop(b), strong_count(a) = {}", Rc::strong_count(&a)); // 2
+
+    drop(c);
+    println!("after drop(c), strong_count(a) = {}", Rc::strong_count(&a)); // 1
+}
+
+#[derive(Debug)]
+struct Node {
+    value: i32,
+    next: Option<Rc<Node>>, // many parents can point to the same child
+}
+
+pub fn example_tree_like_sharing() {
+    println!("\n== Example 2: Tree-like sharing with Rc ==");
+    let leaf = Rc::new(Node { value: 1, next: None });
+
+    let branch1 = Rc::new(Node { value: 2, next: Some(leaf.clone()) });
+    let branch2 = Rc::new(Node { value: 3, next: Some(leaf.clone()) });
+
+    println!("branch1 -> {:?}", branch1.next.as_ref().unwrap());
+    println!("branch2 -> {:?}", branch2.next.as_ref().unwrap());
+    println!("leaf strong_count = {}", Rc::strong_count(&leaf)); // 3 (leaf, branch1, branch2)
+}
+
+pub fn example_mutation_with_refcell() {
+    println!("\n== Example 3: Shared + mutable with Rc<RefCell<T>> ==");
+    let numbers: Rc<RefCell<Vec<i32>>> = Rc::new(RefCell::new(vec![1, 2, 3]));
+
+    let a = numbers.clone();
+    let b = numbers.clone();
+
+    // mutate via one owner
+    a.borrow_mut().push(4);
+
+    // observe via another owner
+    println!("b sees {:?}", b.borrow()); // [1, 2, 3, 4]
+    println!("strong_count(numbers) = {}", Rc::strong_count(&numbers)); // 3
+}
+
+#[derive(Debug)]
+struct GraphNode {
+    name: String,
+    // Strong edges to children:
+    children: RefCell<Vec<Rc<GraphNode>>>,
+    // Weak edge to parent to avoid reference cycle:
+    parent: RefCell<Weak<GraphNode>>,
+}
+
+pub fn example_weak_to_avoid_cycles() {
+    println!("\n== Example 4: Avoid cycles with Weak ==");
+    let root = Rc::new(GraphNode {
+        name: "root".into(),
+        children: RefCell::new(Vec::new()),
+        parent: RefCell::new(Weak::new()),
+    });
+
+    let child = Rc::new(GraphNode {
+        name: "child".into(),
+        children: RefCell::new(Vec::new()),
+        parent: RefCell::new(Weak::new()),
+    });
+
+    // root --(strong)--> child
+    root.children.borrow_mut().push(child.clone());
+
+    // child --(weak)--> root
+    *child.parent.borrow_mut() = Rc::downgrade(&root);
+
+    println!("root strong_count = {}", Rc::strong_count(&root));   // at least 1 (root) + maybe others
+    println!("child strong_count = {}", Rc::strong_count(&child)); // at least 1 (child)
+
+    // Upgrade weak parent pointer (if alive)
+    if let Some(parent_rc) = child.parent.borrow().upgrade() {
+        println!("child's parent = {}", parent_rc.name);
+    } else {
+        println!("child's parent already dropped");
+    }
+
+    // Dropping root would not leak because child's parent is only a Weak reference
+    // (no strong cycle). After drop(root), child.parent.upgrade() would be None.
+}
+
+
+/*
+Docs-style notes:
+
+Rc<T> — Single-threaded shared ownership
+- Rc::new(value) -> Rc<T>
+- Rc::clone(&rc) or rc.clone() -> increments strong refcount
+- Rc::strong_count(&rc) -> current strong refs
+- Rc::downgrade(&rc) -> Weak<T> (weak ref does NOT keep value alive)
+- Weak::upgrade(&weak) -> Option<Rc<T>> (Some if value still alive)
+
+Rc vs Box:
+- Box<T>: single owner, no refcount overhead, drops immediately when owner drops
+- Rc<T>: multiple owners, small overhead for refcount, drops when count hits zero
+
+Mutation pattern:
+- Rc<T> only gives shared immutable access by default
+- For mutation, wrap inner value: Rc<RefCell<T>>
+  - .borrow_mut() / .borrow() have runtime-checked borrowing (can panic if overlapped)
+  - Keep borrows short; prefer try_borrow* if you want to avoid panics
+
+Avoiding cycles:
+- Graphs/trees with parent <-> child links can create Rc cycles -> memory leak
+- Use Weak<T> for back-edges (parents) to break cycles
+
+Threading:
+- Rc<T> is !Send and !Sync (not thread-safe)
+- For multi-threaded shared ownership, use Arc<T> instead
+*/
diff --git a/rc-doc/src/main.rs b/rc-doc/src/main.rs
index b58385d626d9074c3fc0df08e69299e4eda13525..7cd0c282f784f3b5d520b504ec32a4244eede793 100644
--- a/rc-doc/src/main.rs
+++ b/rc-doc/src/main.rs
@@ -1,144 +1,13 @@
-//! Rc<T> mini-docs + runnable examples in one file
-//!
-//! What is Rc<T>?
-//! - Single-threaded reference-counted smart pointer.
-//! - Enables multiple owners of the same heap value.
-//! - Cloning is cheap (increments strong refcount).
-//! - Not thread-safe (use Arc<T> for multi-threading).
-//!
-//! Common combos:
-//! - Rc<T> alone -> shared immutable ownership
-//! - Rc<RefCell<T>> -> shared + interior-mutable (single-thread)
-//! - Rc<Something> + Weak<Something> -> shared graphs without cycles
-
-use std::cell::RefCell;
-use std::rc::{Rc, Weak};
-
-fn example_basic() {
-    println!("== Example 1: Basic Rc usage ==");
-    let a = Rc::new("hello".to_string());
-
-    let b = Rc::clone(&a); // same as a.clone()
-    let c = a.clone();
-
-    println!("a = {a}, b = {b}, c = {c}");
-    println!("strong_count(a) = {}", Rc::strong_count(&a)); // 3
-
-    drop(b);
-    println!("after drop(b), strong_count(a) = {}", Rc::strong_count(&a)); // 2
-
-    drop(c);
-    println!("after drop(c), strong_count(a) = {}", Rc::strong_count(&a)); // 1
-}
-
-#[derive(Debug)]
-struct Node {
-    value: i32,
-    next: Option<Rc<Node>>, // many parents can point to the same child
-}
-
-fn example_tree_like_sharing() {
-    println!("\n== Example 2: Tree-like sharing with Rc ==");
-    let leaf = Rc::new(Node { value: 1, next: None });
-
-    let branch1 = Rc::new(Node { value: 2, next: Some(leaf.clone()) });
-    let branch2 = Rc::new(Node { value: 3, next: Some(leaf.clone()) });
-
-    println!("branch1 -> {:?}", branch1.next.as_ref().unwrap());
-    println!("branch2 -> {:?}", branch2.next.as_ref().unwrap());
-    println!("leaf strong_count = {}", Rc::strong_count(&leaf)); // 3 (leaf, branch1, branch2)
-}
-
-fn example_mutation_with_refcell() {
-    println!("\n== Example 3: Shared + mutable with Rc<RefCell<T>> ==");
-    let numbers: Rc<RefCell<Vec<i32>>> = Rc::new(RefCell::new(vec![1, 2, 3]));
-
-    let a = numbers.clone();
-    let b = numbers.clone();
-
-    // mutate via one owner
-    a.borrow_mut().push(4);
-
-    // observe via another owner
-    println!("b sees {:?}", b.borrow()); // [1, 2, 3, 4]
-    println!("strong_count(numbers) = {}", Rc::strong_count(&numbers)); // 3
-}
-
-#[derive(Debug)]
-struct GraphNode {
-    name: String,
-    // Strong edges to children:
-    children: RefCell<Vec<Rc<GraphNode>>>,
-    // Weak edge to parent to avoid reference cycle:
-    parent: RefCell<Weak<GraphNode>>,
-}
-
-fn example_weak_to_avoid_cycles() {
-    println!("\n== Example 4: Avoid cycles with Weak ==");
-    let root = Rc::new(GraphNode {
-        name: "root".into(),
-        children: RefCell::new(Vec::new()),
-        parent: RefCell::new(Weak::new()),
-    });
-
-    let child = Rc::new(GraphNode {
-        name: "child".into(),
-        children: RefCell::new(Vec::new()),
-        parent: RefCell::new(Weak::new()),
-    });
-
-    // root --(strong)--> child
-    root.children.borrow_mut().push(child.clone());
-
-    // child --(weak)--> root
-    *child.parent.borrow_mut() = Rc::downgrade(&root);
-
-    println!("root strong_count = {}", Rc::strong_count(&root));   // at least 1 (root) + maybe others
-    println!("child strong_count = {}", Rc::strong_count(&child)); // at least 1 (child)
-
-    // Upgrade weak parent pointer (if alive)
-    if let Some(parent_rc) = child.parent.borrow().upgrade() {
-        println!("child's parent = {}", parent_rc.name);
-    } else {
-        println!("child's parent already dropped");
-    }
-
-    // Dropping root would not leak because child's parent is only a Weak reference
-    // (no strong cycle). After drop(root), child.parent.upgrade() would be None.
-}
+use rc::{
+    example_basic,
+    example_tree_like_sharing,
+    example_mutation_with_refcell,
+    example_weak_to_avoid_cycles,
+};
 
 fn main() {
     example_basic();
     example_tree_like_sharing();
     example_mutation_with_refcell();
     example_weak_to_avoid_cycles();
 }
-
-/*
-Docs-style notes:
-
-Rc<T> — Single-threaded shared ownership
-- Rc::new(value) -> Rc<T>
-- Rc::clone(&rc) or rc.clone() -> increments strong refcount
-- Rc::strong_count(&rc) -> current strong refs
-- Rc::downgrade(&rc) -> Weak<T> (weak ref does NOT keep value alive)
-- Weak::upgrade(&weak) -> Option<Rc<T>> (Some if value still alive)
-
-Rc vs Box:
-- Box<T>: single owner, no refcount overhead, drops immediately when owner drops
-- Rc<T>: multiple owners, small overhead for refcount, drops when count hits zero
-
-Mutation pattern:
-- Rc<T> only gives shared immutable access by default
-- For mutation, wrap inner value: Rc<RefCell<T>>
-  - .borrow_mut() / .borrow() have runtime-checked borrowing (can panic if overlapped)
-  - Keep borrows short; prefer try_borrow* if you want to avoid panics
-
-Avoiding cycles:
-- Graphs/trees with parent <-> child links can create Rc cycles -> memory leak
-- Use Weak<T> for back-edges (parents) to break cycles
-
-Threading:
-- Rc<T> is !Send and !Sync (not thread-safe)
-- For multi-threaded shared ownership, use Arc<T> instead
-*/
diff --git a/threading-doc/src/lib.rs b/threading-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..d7e09afe0de35aa34273487978dcea3ba486008e
--- /dev/null
+++ b/threading-doc/src/lib.rs
@@ -0,0 +1,3 @@
+pub fn run() {
+    println!("Hello, world!");
+}
diff --git a/threading-doc/src/main.rs b/threading-doc/src/main.rs
index e7a11a969c037e00a796aafeff6258501ec15e9a..3530141d019964f5167e28527633bfa3bebe62d7 100644
--- a/threading-doc/src/main.rs
+++ b/threading-doc/src/main.rs
@@ -1,3 +1,3 @@
 fn main() {
-    println!("Hello, world!");
+    threading_doc::run();
 }
diff --git a/vec-doc/src/lib.rs b/vec-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..b63036810a5a278a8c390e9b950203f80780648e
--- /dev/null
+++ b/vec-doc/src/lib.rs
@@ -0,0 +1,358 @@
+//! Vectors & Slices in Rust — mini-docs + runnable examples
+//!
+//! TL;DR
+//! - `Vec<T>`: growable, owned, contiguous buffer on the heap.
+//! - `&[T]` / `&mut [T]`: non-owning *views* (slices) into contiguous memory.
+//! - Prefer passing `&[T]` (read-only) or `&mut [T]` (in-place edit) to functions;
+//!   pass `Vec<T>` only when the callee must own/resize it.
+//! - Indexing panics OOB; prefer `.get()`/`.get_mut()` to avoid panics.
+//!
+//! ─────────────────────────────────────────────────────────────────────────────
+//! INTERNAL REPRESENTATION (mental model)
+//!
+//! Vec<T> (roughly; generics elided):
+//!   pub struct Vec<T> {
+//!       ptr: NonNull<T>,  // pointer to heap buffer (may be dangling when cap=0)
+//!       len: usize,       // number of initialized elements
+//!       cap: usize,       // allocated capacity (in elements)
+//!   }
+//! - The *control block* (ptr/len/cap) lives on the stack; the *elements* live on the heap.
+//! - Growing (push beyond capacity / reserve) may *reallocate* → moves the buffer.
+//!   That invalidates raw pointers and any outstanding borrows/iters of the elements.
+//!
+//! Slice (&[T] / &mut [T]) — "fat" pointers:
+//!   - A slice reference is (data_ptr: *const T, len: usize).
+//!   - `&[T]` allows shared/read-only access; `&mut [T]` is exclusive and allows mutation.
+//!   - Slices never own, never grow/shrink. Think “window into contiguous memory”.
+//!
+//! Coercions (automatic):
+//!   &Vec<T>      → &[T]
+//!   &mut Vec<T>  → &mut [T]
+//!   Box<[T]>     → &[T]
+//! - This is why function params should prefer `&[T]` / `&mut [T]`: callers can pass many
+//!   container types without extra copies.
+//!
+//! Passing to functions (guidelines):
+//!   - Read-only view         → fn f(xs: &[T])            // zero-copy, flexible
+//!   - In-place modification  → fn f(xs: &mut [T])        // no reallocation
+//!   - Take ownership/resize  → fn f(xs: Vec<T>)          // may reallocate / retain
+//!   - Generic accept-many    → fn f<A: AsRef<[T]>>(a: A) // Vec, &[T], arrays, etc.
+//!
+//! Returning from functions:
+//!   - Own the results        → Vec<T>
+//!   - Exact-fit owned slice  → Box<[T]> (no spare capacity; use when you won’t grow)
+//!
+//! Size facts (on a 64-bit target):
+//!   - size_of::<Vec<T>>()     == 3 * usize (ptr,len,cap)
+//!   - size_of::<&[T]>()       == 2 * usize (ptr,len)     (same for &mut [T])
+//!   - The elements’ size is *not* inside those control blocks.
+//!
+//! Memory/ABI notes:
+//!   - Reallocation may move the buffer; keep borrows short around `push`/`reserve`.
+//!   - Zero-sized types (ZSTs) like `()` have special handling (ptr may be dangling, len counts).
+//!   - `into_boxed_slice()` can trim spare capacity and store tightly (good for long-lived data).
+
+use std::mem::{size_of, size_of_val};
+
+pub fn example_vec_basics() {
+    println!("== Vec basics ==");
+    let mut v1: Vec<i32> = Vec::new();
+    v1.push(10);
+    v1.push(20);
+
+    let mut v2 = vec![1, 2, 3];    // literal macro
+    let v3 = vec![0; 5];           // five zeros
+    v2.extend([4, 5]);             // from array/iterator
+
+    println!("v1 = {:?}", v1);
+    println!("v2 = {:?}", v2);
+    println!("v3 = {:?}", v3);
+
+    println!("v2[0] = {}", v2[0]);                 // may panic if OOB
+    println!("v2.get(100) = {:?}", v2.get(100));   // safe Option<&T>
+
+    v2.insert(0, 99);              // O(n) shift right
+    let popped = v2.pop();         // Option<T>, pop back (amortized O(1))
+    v2.remove(1);                  // O(n) shift left
+    v2.truncate(3);
+    println!("v2 after edits = {:?}, popped = {:?}", v2, popped);
+}
+
+pub fn example_vec_capacity() {
+    println!("\n== Capacity, reserve, shrink ==");
+    let mut v = Vec::with_capacity(2);
+    println!("start: len={}, cap={}", v.len(), v.capacity());
+
+    v.extend([1, 2]);
+    println!("after extend: len={}, cap={}", v.len(), v.capacity());
+
+    v.reserve(100); // ensure extra space; may reallocate
+    println!("after reserve: len={}, cap={}", v.len(), v.capacity());
+
+    v.shrink_to_fit(); // may reduce capacity toward len
+    println!("after shrink_to_fit: len={}, cap={}", v.len(), v.capacity());
+}
+
+pub fn example_vec_iterate() {
+    println!("\n== Iterating Vec ==");
+    let mut v = vec![10, 20, 30];
+
+    for x in v.iter() {
+        println!("iter saw {x}");  // &i32
+    }
+
+    for x in v.iter_mut() {
+        *x += 1;                   // &mut i32
+    }
+    println!("after iter_mut: {:?}", v);
+
+    for x in v.clone().into_iter() {
+        println!("into_iter moved {x}"); // i32 by value
+    }
+}
+
+pub fn example_vec_slice_views() {
+    println!("\n== Slices from Vec ==");
+    let mut v = vec![1, 2, 3, 4, 5, 6];
+
+    let whole: &[i32] = &v;        // &Vec<T> → &[T] (coerce)
+    let mid: &[i32]   = &v[2..4];  // half-open slice [2,4)
+    println!("whole={:?}, mid={:?}", whole, mid);
+
+    let tail: &mut [i32] = &mut v[3..];
+    tail[0] = 99;                  // edits underlying Vec
+    println!("after mut slice edit v={:?}", v);
+
+    let owned_again: Vec<i32> = mid.to_vec(); // clone slice to owned
+    println!("owned_again = {:?}", owned_again);
+}
+
+pub fn example_vec_batch_ops() {
+    println!("\n== Batch ops: drain / retain / dedup / splice / split_off ==");
+    let mut v = vec![1, 2, 2, 3, 3, 3, 4, 5];
+
+    v.retain(|&x| x != 5);
+    println!("retain !=5: {:?}", v);
+
+    v.dedup();
+    println!("dedup adjacent: {:?}", v);
+
+    let drained: Vec<_> = v.splice(1..3, [20, 21, 22]).collect();
+    println!("splice -> v={:?}, drained={:?}", v, drained);
+
+    let mut w = vec![9, 8, 7, 6, 5];
+    let d: Vec<_> = w.drain(1..4).collect();
+    println!("drain 1..4 -> d={:?}, w now={:?}", d, w);
+
+    let mut a = vec![1, 2, 3, 4, 5];
+    let b = a.split_off(3); // a=[1,2,3], b=[4,5]
+    println!("split_off -> a={:?}, b={:?}", a, b);
+}
+
+pub fn example_vec_sort_search() {
+    println!("\n== Sort & binary_search ==");
+    let mut v = vec![5, 1, 4, 2, 3];
+    v.sort(); // stable
+    println!("sorted = {:?}", v);
+
+    let mut pairs = vec![("aa", 10), ("b", 2), ("ccc", 3)];
+    pairs.sort_by_key(|&(s, _)| s.len());
+    println!("sort_by_key(len) = {:?}", pairs);
+
+    match v.binary_search(&4) {
+        Ok(idx) => println!("found 4 at {idx}"),
+        Err(ins) => println!("not found; insert at {ins}"),
+    }
+}
+
+pub fn example_slice_basics() {
+    println!("\n== Slice basics (&[T], &mut [T]) ==");
+    let arr = [10, 20, 30, 40, 50];
+    let s: &[i32] = &arr[1..4];
+    println!("slice s = {:?}, len={}, first={}", s, s.len(), s[0]);
+
+    println!("first()={:?}, last()={:?}", s.first(), s.last());
+    println!("is_empty? {}", s.is_empty());
+
+    let (left, right) = s.split_at(1);
+    println!("split_at(1): left={:?}, right={:?}", left, right);
+
+    let chunks: Vec<&[i32]> = arr.chunks(2).collect();
+    let wins:   Vec<&[i32]> = arr.windows(3).collect();
+    println!("chunks(2)={:?}", chunks);
+    println!("windows(3)={:?}", wins);
+
+    let mut arr2 = [3, 1, 2, 4];
+    let s2: &mut [i32] = &mut arr2[..];
+    s2.sort();
+    println!("sorted slice -> arr2={:?}", arr2);
+
+    let src = [9, 9, 9, 9];
+    let dst = &mut arr2[..];
+    dst.copy_from_slice(&src);
+    println!("after copy_from_slice -> arr2={:?}", arr2);
+}
+
+pub fn example_slice_pattern_matching() {
+    println!("\n== Slice pattern matching ==");
+    let v = vec![1, 2, 3, 4, 5];
+
+    match v.as_slice() {
+        [] => println!("empty"),
+        [x] => println!("one elem: {x}"),
+        [x, y] => println!("two elems: {x},{y}"),
+        [head, mid @ .., tail] => {
+            println!("head={head}, tail={tail}, mid={:?}", mid);
+        }
+    }
+
+    let mut w = vec![10, 20, 30, 40];
+    match w.as_mut_slice() {
+        [first, .., last] => {
+            *first += 1;
+            *last  += 1;
+        }
+        _ => {}
+    }
+    println!("after match-mutate: {:?}", w);
+}
+
+pub fn example_sizes_and_ptrs() {
+    println!("\n== Sizes & pointers (64-bit targets) ==");
+    let v = vec![1u64, 2, 3];
+    let s: &[u64] = &v;
+
+    println!("size_of::<Vec<u64>>()   = {}", size_of::<Vec<u64>>());
+    println!("size_of::<&[u64]>()    = {}", size_of::<&[u64]>());
+    println!("size_of_val(&v)        = {}", size_of_val(&v));
+    println!("size_of_val(&s)        = {}", size_of_val(&s));
+
+    println!("len={}, cap={}", v.len(), v.capacity());
+    println!("vec.as_ptr() = {:p}", v.as_ptr());
+    println!("slice.as_ptr() = {:p}", s.as_ptr()); // same data pointer
+}
+
+pub fn example_passing_to_functions() {
+    println!("\n== Passing Vec/Slice to functions (ownership vs borrowing) ==");
+
+    // Read-only: accept &[T]
+    fn sum(xs: &[i32]) -> i32 {
+        xs.iter().sum()
+    }
+
+    // In-place edit: accept &mut [T] (cannot grow)
+    fn bump_all(xs: &mut [i32]) {
+        for x in xs { *x += 1; }
+    }
+
+    // Take ownership: accept Vec<T> (may grow/shrink/keep)
+    fn into_even_only(mut xs: Vec<i32>) -> Vec<i32> {
+        xs.retain(|x| x % 2 == 0);
+        xs
+    }
+
+    // Generic accept-many: AsRef<[T]> (Vec, &[T], arrays, Box<[T]>, etc.)
+    fn print_all<A: AsRef<[i32]>>(a: A) {
+        for x in a.as_ref() {
+            print!("{x} ");
+        }
+        println!();
+    }
+
+    // — demo —
+    let mut v = vec![1, 2, 3, 4, 5];
+    println!("sum(&v) = {}", sum(&v)); // &Vec<T> → &[T]
+
+    bump_all(&mut v); // &mut Vec<T> → &mut [T]
+    println!("after bump_all: {:?}", v);
+
+    let evens = into_even_only(v.clone()); // moves (clones to keep original here)
+    println!("evens from into_even_only: {:?}", evens);
+
+    print!("print_all(Vec): ");
+    print_all(v.clone());
+    print!("print_all(slice): ");
+    print_all(&v[..]);
+    print!("print_all(array): ");
+    print_all([7, 8, 9]);
+}
+
+pub fn example_boxed_slice_return() {
+    println!("\n== Returning Box<[T]> (tight, no spare capacity) ==");
+    fn to_boxed(mut xs: Vec<i32>) -> Box<[i32]> {
+        xs.shrink_to_fit();          // try to remove spare capacity
+        xs.into_boxed_slice()        // owned slice (exact len)
+    }
+
+    let b = to_boxed(vec![1, 2, 3, 4]);
+    println!("boxed slice len={}, first={}", b.len(), b[0]);
+}
+
+pub fn example_safety_and_panic_free() {
+    println!("\n== Safety tips: indexing vs get, reallocation ==");
+    let mut v = vec![1, 2, 3];
+
+    if let Some(x) = v.get(100) {
+        println!("unexpected: {x}");
+    } else {
+        println!("safe: index 100 is out of bounds");
+    }
+
+    let (left, right) = v.split_at_mut(1);
+    left[0] += 10;
+    if let Some(r0) = right.get_mut(0) {
+        *r0 += 20;
+    }
+    println!("after split_at_mut edits: {:?}", v);
+
+    // Reallocation demo (raw pointer invalidation)
+    let p = v.as_ptr();
+    let old_cap = v.capacity();
+    v.reserve(10_000); // likely reallocate
+    println!("ptr changed? {} -> {}", format!("{:p}", p), format!("{:p}", v.as_ptr()));
+    println!("cap {} -> {}", old_cap, v.capacity());
+}
+
+
+/*
+Docs-style notes (expanded):
+
+INTERNALS
+- Vec<T> is a tiny stack object with three words: (ptr, len, cap). Elements live on the heap.
+- Slices &[T]/&mut [T] are *fat* references: (data_ptr, len). They never own and can’t resize.
+- Reallocation moves the heap buffer. Keep borrows/iterators short around push/reserve.
+
+PASSING TO FUNCTIONS (choose the lightest that fits)
+- Read-only, most flexible:              fn f(xs: &[T])
+  Callers can pass &Vec<T>, arrays, Box<[T]>, other slices, without copies.
+- In-place edit, fixed-size window:      fn f(xs: &mut [T])
+  Callee may mutate, but cannot grow/shrink the buffer.
+- Needs ownership or resizing:           fn f(xs: Vec<T>)
+  Callee can reserve/push/pop/retain and keep or return it.
+- Accept “anything slice-like”:          fn f<A: AsRef<[T]>>(a: A)
+  Great for libraries; supports Vec, &[T], Box<[T]>, arrays, Cow<[T]>, etc.
+
+RETURN TYPES
+- Return `Vec<T>` when you’re handing back *owned growable data*.
+- Return `Box<[T]>` when you want *owned, exact-sized* data with no spare capacity
+  (smaller footprint, can be more cache-friendly for read-only blobs).
+
+COERCIONS
+- &Vec<T>      → &[T]
+- &mut Vec<T>  → &mut [T]
+- Box<[T]>     → &[T]
+- Many std APIs accept slices for maximum flexibility and zero-copy interop.
+
+SAFETY/PERF TIPS
+- Prefer `get()`/`get_mut()` when indices may be invalid; indexing panics on OOB.
+- Use iterators (`iter`, `iter_mut`, adapters) for clarity and bounds-checked, fused loops.
+- Sorting/search: `sort`, `sort_by_key`, `binary_search` (requires sorted input).
+- Batch transforms: `retain`, `drain`, `splice`, `split_off` avoid repeated reallocations.
+- Avoid holding references across potential reallocation points (`push`, `reserve`, `append`).
+
+ADVANCED
+- `into_boxed_slice()` trims spare capacity (Vec → Box<[T]>) for tight storage.
+- Zero-sized types (ZSTs) are supported; ptr may be “dangling”, length still meaningful.
+- FFI often prefers slices as (ptr,len) pairs; `as_ptr()` and `len()` provide those.
+
+*/
diff --git a/vec-doc/src/main.rs b/vec-doc/src/main.rs
index 97d82b1587377f441bbc451115cb27a2b9cf1eef..181b22a404bb58986fbe54cb982103b88bd9ee2d 100644
--- a/vec-doc/src/main.rs
+++ b/vec-doc/src/main.rs
@@ -1,372 +1,29 @@
-//! Vectors & Slices in Rust — mini-docs + runnable examples
-//!
-//! TL;DR
-//! - `Vec<T>`: growable, owned, contiguous buffer on the heap.
-//! - `&[T]` / `&mut [T]`: non-owning *views* (slices) into contiguous memory.
-//! - Prefer passing `&[T]` (read-only) or `&mut [T]` (in-place edit) to functions;
-//!   pass `Vec<T>` only when the callee must own/resize it.
-//! - Indexing panics OOB; prefer `.get()`/`.get_mut()` to avoid panics.
-//!
-//! ─────────────────────────────────────────────────────────────────────────────
-//! INTERNAL REPRESENTATION (mental model)
-//!
-//! Vec<T> (roughly; generics elided):
-//!   pub struct Vec<T> {
-//!       ptr: NonNull<T>,  // pointer to heap buffer (may be dangling when cap=0)
-//!       len: usize,       // number of initialized elements
-//!       cap: usize,       // allocated capacity (in elements)
-//!   }
-//! - The *control block* (ptr/len/cap) lives on the stack; the *elements* live on the heap.
-//! - Growing (push beyond capacity / reserve) may *reallocate* → moves the buffer.
-//!   That invalidates raw pointers and any outstanding borrows/iters of the elements.
-//!
-//! Slice (&[T] / &mut [T]) — "fat" pointers:
-//!   - A slice reference is (data_ptr: *const T, len: usize).
-//!   - `&[T]` allows shared/read-only access; `&mut [T]` is exclusive and allows mutation.
-//!   - Slices never own, never grow/shrink. Think “window into contiguous memory”.
-//!
-//! Coercions (automatic):
-//!   &Vec<T>      → &[T]
-//!   &mut Vec<T>  → &mut [T]
-//!   Box<[T]>     → &[T]
-//! - This is why function params should prefer `&[T]` / `&mut [T]`: callers can pass many
-//!   container types without extra copies.
-//!
-//! Passing to functions (guidelines):
-//!   - Read-only view         → fn f(xs: &[T])            // zero-copy, flexible
-//!   - In-place modification  → fn f(xs: &mut [T])        // no reallocation
-//!   - Take ownership/resize  → fn f(xs: Vec<T>)          // may reallocate / retain
-//!   - Generic accept-many    → fn f<A: AsRef<[T]>>(a: A) // Vec, &[T], arrays, etc.
-//!
-//! Returning from functions:
-//!   - Own the results        → Vec<T>
-//!   - Exact-fit owned slice  → Box<[T]> (no spare capacity; use when you won’t grow)
-//!
-//! Size facts (on a 64-bit target):
-//!   - size_of::<Vec<T>>()     == 3 * usize (ptr,len,cap)
-//!   - size_of::<&[T]>()       == 2 * usize (ptr,len)     (same for &mut [T])
-//!   - The elements’ size is *not* inside those control blocks.
-//!
-//! Memory/ABI notes:
-//!   - Reallocation may move the buffer; keep borrows short around `push`/`reserve`.
-//!   - Zero-sized types (ZSTs) like `()` have special handling (ptr may be dangling, len counts).
-//!   - `into_boxed_slice()` can trim spare capacity and store tightly (good for long-lived data).
-
-use std::mem::{size_of, size_of_val};
-
-fn example_vec_basics() {
-    println!("== Vec basics ==");
-    let mut v1: Vec<i32> = Vec::new();
-    v1.push(10);
-    v1.push(20);
-
-    let mut v2 = vec![1, 2, 3];    // literal macro
-    let v3 = vec![0; 5];           // five zeros
-    v2.extend([4, 5]);             // from array/iterator
-
-    println!("v1 = {:?}", v1);
-    println!("v2 = {:?}", v2);
-    println!("v3 = {:?}", v3);
-
-    println!("v2[0] = {}", v2[0]);                 // may panic if OOB
-    println!("v2.get(100) = {:?}", v2.get(100));   // safe Option<&T>
-
-    v2.insert(0, 99);              // O(n) shift right
-    let popped = v2.pop();         // Option<T>, pop back (amortized O(1))
-    v2.remove(1);                  // O(n) shift left
-    v2.truncate(3);
-    println!("v2 after edits = {:?}, popped = {:?}", v2, popped);
-}
-
-fn example_vec_capacity() {
-    println!("\n== Capacity, reserve, shrink ==");
-    let mut v = Vec::with_capacity(2);
-    println!("start: len={}, cap={}", v.len(), v.capacity());
-
-    v.extend([1, 2]);
-    println!("after extend: len={}, cap={}", v.len(), v.capacity());
-
-    v.reserve(100); // ensure extra space; may reallocate
-    println!("after reserve: len={}, cap={}", v.len(), v.capacity());
-
-    v.shrink_to_fit(); // may reduce capacity toward len
-    println!("after shrink_to_fit: len={}, cap={}", v.len(), v.capacity());
-}
-
-fn example_vec_iterate() {
-    println!("\n== Iterating Vec ==");
-    let mut v = vec![10, 20, 30];
-
-    for x in v.iter() {
-        println!("iter saw {x}");  // &i32
-    }
-
-    for x in v.iter_mut() {
-        *x += 1;                   // &mut i32
-    }
-    println!("after iter_mut: {:?}", v);
-
-    for x in v.clone().into_iter() {
-        println!("into_iter moved {x}"); // i32 by value
-    }
-}
-
-fn example_vec_slice_views() {
-    println!("\n== Slices from Vec ==");
-    let mut v = vec![1, 2, 3, 4, 5, 6];
-
-    let whole: &[i32] = &v;        // &Vec<T> → &[T] (coerce)
-    let mid: &[i32]   = &v[2..4];  // half-open slice [2,4)
-    println!("whole={:?}, mid={:?}", whole, mid);
-
-    let tail: &mut [i32] = &mut v[3..];
-    tail[0] = 99;                  // edits underlying Vec
-    println!("after mut slice edit v={:?}", v);
-
-    let owned_again: Vec<i32> = mid.to_vec(); // clone slice to owned
-    println!("owned_again = {:?}", owned_again);
-}
-
-fn example_vec_batch_ops() {
-    println!("\n== Batch ops: drain / retain / dedup / splice / split_off ==");
-    let mut v = vec![1, 2, 2, 3, 3, 3, 4, 5];
-
-    v.retain(|&x| x != 5);
-    println!("retain !=5: {:?}", v);
-
-    v.dedup();
-    println!("dedup adjacent: {:?}", v);
-
-    let drained: Vec<_> = v.splice(1..3, [20, 21, 22]).collect();
-    println!("splice -> v={:?}, drained={:?}", v, drained);
-
-    let mut w = vec![9, 8, 7, 6, 5];
-    let d: Vec<_> = w.drain(1..4).collect();
-    println!("drain 1..4 -> d={:?}, w now={:?}", d, w);
-
-    let mut a = vec![1, 2, 3, 4, 5];
-    let b = a.split_off(3); // a=[1,2,3], b=[4,5]
-    println!("split_off -> a={:?}, b={:?}", a, b);
-}
-
-fn example_vec_sort_search() {
-    println!("\n== Sort & binary_search ==");
-    let mut v = vec![5, 1, 4, 2, 3];
-    v.sort(); // stable
-    println!("sorted = {:?}", v);
-
-    let mut pairs = vec![("aa", 10), ("b", 2), ("ccc", 3)];
-    pairs.sort_by_key(|&(s, _)| s.len());
-    println!("sort_by_key(len) = {:?}", pairs);
-
-    match v.binary_search(&4) {
-        Ok(idx) => println!("found 4 at {idx}"),
-        Err(ins) => println!("not found; insert at {ins}"),
-    }
-}
-
-fn example_slice_basics() {
-    println!("\n== Slice basics (&[T], &mut [T]) ==");
-    let arr = [10, 20, 30, 40, 50];
-    let s: &[i32] = &arr[1..4];
-    println!("slice s = {:?}, len={}, first={}", s, s.len(), s[0]);
-
-    println!("first()={:?}, last()={:?}", s.first(), s.last());
-    println!("is_empty? {}", s.is_empty());
-
-    let (left, right) = s.split_at(1);
-    println!("split_at(1): left={:?}, right={:?}", left, right);
-
-    let chunks: Vec<&[i32]> = arr.chunks(2).collect();
-    let wins:   Vec<&[i32]> = arr.windows(3).collect();
-    println!("chunks(2)={:?}", chunks);
-    println!("windows(3)={:?}", wins);
-
-    let mut arr2 = [3, 1, 2, 4];
-    let s2: &mut [i32] = &mut arr2[..];
-    s2.sort();
-    println!("sorted slice -> arr2={:?}", arr2);
-
-    let src = [9, 9, 9, 9];
-    let dst = &mut arr2[..];
-    dst.copy_from_slice(&src);
-    println!("after copy_from_slice -> arr2={:?}", arr2);
-}
-
-fn example_slice_pattern_matching() {
-    println!("\n== Slice pattern matching ==");
-    let v = vec![1, 2, 3, 4, 5];
-
-    match v.as_slice() {
-        [] => println!("empty"),
-        [x] => println!("one elem: {x}"),
-        [x, y] => println!("two elems: {x},{y}"),
-        [head, mid @ .., tail] => {
-            println!("head={head}, tail={tail}, mid={:?}", mid);
-        }
-    }
-
-    let mut w = vec![10, 20, 30, 40];
-    match w.as_mut_slice() {
-        [first, .., last] => {
-            *first += 1;
-            *last  += 1;
-        }
-        _ => {}
-    }
-    println!("after match-mutate: {:?}", w);
-}
-
-fn example_sizes_and_ptrs() {
-    println!("\n== Sizes & pointers (64-bit targets) ==");
-    let v = vec![1u64, 2, 3];
-    let s: &[u64] = &v;
-
-    println!("size_of::<Vec<u64>>()   = {}", size_of::<Vec<u64>>());
-    println!("size_of::<&[u64]>()    = {}", size_of::<&[u64]>());
-    println!("size_of_val(&v)        = {}", size_of_val(&v));
-    println!("size_of_val(&s)        = {}", size_of_val(&s));
-
-    println!("len={}, cap={}", v.len(), v.capacity());
-    println!("vec.as_ptr() = {:p}", v.as_ptr());
-    println!("slice.as_ptr() = {:p}", s.as_ptr()); // same data pointer
-}
-
-fn example_passing_to_functions() {
-    println!("\n== Passing Vec/Slice to functions (ownership vs borrowing) ==");
-
-    // Read-only: accept &[T]
-    fn sum(xs: &[i32]) -> i32 {
-        xs.iter().sum()
-    }
-
-    // In-place edit: accept &mut [T] (cannot grow)
-    fn bump_all(xs: &mut [i32]) {
-        for x in xs { *x += 1; }
-    }
-
-    // Take ownership: accept Vec<T> (may grow/shrink/keep)
-    fn into_even_only(mut xs: Vec<i32>) -> Vec<i32> {
-        xs.retain(|x| x % 2 == 0);
-        xs
-    }
-
-    // Generic accept-many: AsRef<[T]> (Vec, &[T], arrays, Box<[T]>, etc.)
-    fn print_all<A: AsRef<[i32]>>(a: A) {
-        for x in a.asRef() {
-            print!("{x} ");
-        }
-        println!();
-    }
-
-    // — demo —
-    let mut v = vec![1, 2, 3, 4, 5];
-    println!("sum(&v) = {}", sum(&v)); // &Vec<T> → &[T]
-
-    bump_all(&mut v); // &mut Vec<T> → &mut [T]
-    println!("after bump_all: {:?}", v);
-
-    let evens = into_even_only(v.clone()); // moves (clones to keep original here)
-    println!("evens from into_even_only: {:?}", evens);
-
-    print!("print_all(Vec): ");
-    print_all(v.clone());
-    print!("print_all(slice): ");
-    print_all(&v[..]);
-    print!("print_all(array): ");
-    print_all([7, 8, 9]);
-}
-
-fn example_boxed_slice_return() {
-    println!("\n== Returning Box<[T]> (tight, no spare capacity) ==");
-    fn to_boxed(mut xs: Vec<i32>) -> Box<[i32]> {
-        xs.shrink_to_fit();          // try to remove spare capacity
-        xs.into_boxed_slice()        // owned slice (exact len)
-    }
-
-    let b = to_boxed(vec![1, 2, 3, 4]);
-    println!("boxed slice len={}, first={}", b.len(), b[0]);
-}
-
-fn example_safety_and_panic_free() {
-    println!("\n== Safety tips: indexing vs get, reallocation ==");
-    let mut v = vec![1, 2, 3];
-
-    if let Some(x) = v.get(100) {
-        println!("unexpected: {x}");
-    } else {
-        println!("safe: index 100 is out of bounds");
-    }
-
-    let (left, right) = v.split_at_mut(1);
-    left[0] += 10;
-    if let Some(r0) = right.get_mut(0) {
-        *r0 += 20;
-    }
-    println!("after split_at_mut edits: {:?}", v);
-
-    // Reallocation demo (raw pointer invalidation)
-    let p = v.as_ptr();
-    let old_cap = v.capacity();
-    v.reserve(10_000); // likely reallocate
-    println!("ptr changed? {} -> {}", format!("{:p}", p), format!("{:p}", v.as_ptr()));
-    println!("cap {} -> {}", old_cap, v.capacity());
-}
+use vec_doc::{
+    example_vec_basics,
+    example_vec_capacity,
+    example_vec_iterate,
+    example_vec_slice_views,
+    example_vec_batch_ops,
+    example_vec_sort_search,
+    example_slice_basics,
+    example_slice_pattern_matching,
+    example_sizes_and_ptrs,
+    example_passing_to_functions,
+    example_boxed_slice_return,
+    example_safety_and_panic_free,
+};
 
 fn main() {
     example_vec_basics();
     example_vec_capacity();
     example_vec_iterate();
     example_vec_slice_views();
     example_vec_batch_ops();
     example_vec_sort_search();
     example_slice_basics();
     example_slice_pattern_matching();
     example_sizes_and_ptrs();
     example_passing_to_functions();
     example_boxed_slice_return();
     example_safety_and_panic_free();
 }
-
-/*
-Docs-style notes (expanded):
-
-INTERNALS
-- Vec<T> is a tiny stack object with three words: (ptr, len, cap). Elements live on the heap.
-- Slices &[T]/&mut [T] are *fat* references: (data_ptr, len). They never own and can’t resize.
-- Reallocation moves the heap buffer. Keep borrows/iterators short around push/reserve.
-
-PASSING TO FUNCTIONS (choose the lightest that fits)
-- Read-only, most flexible:              fn f(xs: &[T])
-  Callers can pass &Vec<T>, arrays, Box<[T]>, other slices, without copies.
-- In-place edit, fixed-size window:      fn f(xs: &mut [T])
-  Callee may mutate, but cannot grow/shrink the buffer.
-- Needs ownership or resizing:           fn f(xs: Vec<T>)
-  Callee can reserve/push/pop/retain and keep or return it.
-- Accept “anything slice-like”:          fn f<A: AsRef<[T]>>(a: A)
-  Great for libraries; supports Vec, &[T], Box<[T]>, arrays, Cow<[T]>, etc.
-
-RETURN TYPES
-- Return `Vec<T>` when you’re handing back *owned growable data*.
-- Return `Box<[T]>` when you want *owned, exact-sized* data with no spare capacity
-  (smaller footprint, can be more cache-friendly for read-only blobs).
-
-COERCIONS
-- &Vec<T>      → &[T]
-- &mut Vec<T>  → &mut [T]
-- Box<[T]>     → &[T]
-- Many std APIs accept slices for maximum flexibility and zero-copy interop.
-
-SAFETY/PERF TIPS
-- Prefer `get()`/`get_mut()` when indices may be invalid; indexing panics on OOB.
-- Use iterators (`iter`, `iter_mut`, adapters) for clarity and bounds-checked, fused loops.
-- Sorting/search: `sort`, `sort_by_key`, `binary_search` (requires sorted input).
-- Batch transforms: `retain`, `drain`, `splice`, `split_off` avoid repeated reallocations.
-- Avoid holding references across potential reallocation points (`push`, `reserve`, `append`).
-
-ADVANCED
-- `into_boxed_slice()` trims spare capacity (Vec → Box<[T]>) for tight storage.
-- Zero-sized types (ZSTs) are supported; ptr may be “dangling”, length still meaningful.
-- FFI often prefers slices as (ptr,len) pairs; `as_ptr()` and `len()` provide those.
-
-*/
diff --git a/weak-doc/src/lib.rs b/weak-doc/src/lib.rs
new file mode 100644
index 0000000000000000000000000000000000000000..e5115d220ea979686b99641a5c24980792d7b503
--- /dev/null
+++ b/weak-doc/src/lib.rs
@@ -0,0 +1,309 @@
+//! Weak<T> in Rust — mini-docs + runnable examples
+//!
+//! TL;DR
+//! - `Weak<T>` is a **non-owning** pointer to the allocation behind `Rc<T>` or `Arc<T>`.
+//! - It **does not** keep the value alive (doesn’t affect drop timing).
+//! - Use `Weak` to **break reference cycles** (e.g., parent↔child graphs).
+//! - To access the value, call `.upgrade()` → `Option<Rc<T>>` / `Option<Arc<T>>`.
+//! - When the last strong (`Rc`/`Arc`) is dropped, the value is dropped; the allocation
+//!   is freed when **both** strong and weak counts reach zero.
+
+use std::{
+    cell::RefCell,
+    rc::{Rc, Weak as RcWeak},
+    sync::{Arc, Weak as ArcWeak, Mutex},
+    thread,
+    time::Duration,
+};
+
+/* ───────────────────────── 1) Basics: Rc::Weak (single-threaded) ───────────────────────── */
+
+pub fn ex_rc_weak_basics() {
+    println!("== 1) Rc::Weak basics ==");
+
+    let strong = Rc::new(String::from("hello"));
+    let weak: RcWeak<String> = Rc::downgrade(&strong);
+
+    println!("strong_count = {}", Rc::strong_count(&strong)); // 1
+    println!("weak_count    = {}", Rc::weak_count(&strong));  // 1 (the `weak` above)
+
+    // Access via upgrade
+    if let Some(s) = weak.upgrade() {
+        println!("upgrade -> {}", s); // "hello"
+        // `s` is an Rc clone; keeps the value alive while in scope
+    }
+
+    // Drop the last strong owner
+    drop(strong);
+
+    // Now the value is dropped; upgrade fails (allocation may still exist until weak_count==0)
+    assert!(weak.upgrade().is_none());
+    println!("after drop: upgrade -> None");
+}
+
+/* ─────────────── 2) Breaking cycles in graphs: Rc<RefCell<T>> + Rc::Weak ───────────────
+   Problem: cycles of Rc cause leaks (values never dropped) because refcount never hits zero.
+   Solution: use Weak for back-edges (e.g., child -> parent).
+*/
+
+#[derive(Debug)]
+struct NodeRc {
+    name: String,
+    parent: RefCell<RcWeak<NodeRc>>,     // weak back-edge
+    children: RefCell<Vec<Rc<NodeRc>>>,  // strong edges to children
+}
+
+pub fn ex_rc_cycle_vs_weak() {
+    println!("\n== 2) Breaking cycles with Rc::Weak ==");
+
+    // Make a parent and a child
+    let parent = Rc::new(NodeRc {
+        name: "root".into(),
+        parent: RefCell::new(RcWeak::new()),
+        children: RefCell::new(vec![]),
+    });
+    let child = Rc::new(NodeRc {
+        name: "leaf".into(),
+        parent: RefCell::new(RcWeak::new()),
+        children: RefCell::new(vec![]),
+    });
+
+    // root -> child (strong)
+    parent.children.borrow_mut().push(child.clone());
+    // child -> root (WEAK)
+    *child.parent.borrow_mut() = Rc::downgrade(&parent);
+
+    println!(
+        "counts (parent): strong={}, weak={}",
+        Rc::strong_count(&parent),
+        Rc::weak_count(&parent)
+    );
+    println!(
+        "counts (child) : strong={}, weak={}",
+        Rc::strong_count(&child),
+        Rc::weak_count(&child)
+    );
+
+    // Drop the strong parent; child only holds a WEAK back-edge, so no cycle leak.
+    drop(parent);
+
+    // Child's weak parent pointer cannot keep parent alive:
+    if child.parent.borrow().upgrade().is_none() {
+        println!("parent has been dropped; weak back-edge is now None");
+    }
+}
+
+/* ───────────────────── 3) Arc::Weak in multi-threaded graphs ───────────────────── */
+
+#[derive(Debug)]
+struct NodeArc {
+    name: String,
+    parent: Mutex<ArcWeak<NodeArc>>,       // weak back-edge
+    children: Mutex<Vec<Arc<NodeArc>>>,    // strong edges
+}
+
+pub fn ex_arc_weak_multithread() {
+    println!("\n== 3) Arc::Weak in multi-threaded graphs ==");
+
+    let root = Arc::new(NodeArc {
+        name: "root".into(),
+        parent: Mutex::new(ArcWeak::new()),
+        children: Mutex::new(vec![]),
+    });
+    let leaf = Arc::new(NodeArc {
+        name: "leaf".into(),
+        parent: Mutex::new(ArcWeak::new()),
+        children: Mutex::new(vec![]),
+    });
+
+    // root -> leaf (strong)
+    root.children.lock().unwrap().push(leaf.clone());
+    // leaf -> root (WEAK)
+    *leaf.parent.lock().unwrap() = Arc::downgrade(&root);
+
+    println!(
+        "counts (root): strong={}, weak={}",
+        Arc::strong_count(&root),
+        Arc::weak_count(&root)
+    );
+    println!(
+        "counts (leaf): strong={}, weak={}",
+        Arc::strong_count(&leaf),
+        Arc::weak_count(&leaf)
+    );
+
+    // Move leaf to another thread, observe parent after dropping root
+    let handle = {
+        let leaf = leaf.clone();
+        thread::spawn(move || {
+            thread::sleep(Duration::from_millis(10));
+            if leaf.parent.lock().unwrap().upgrade().is_none() {
+                println!("[thread] root dropped; weak back-edge is None");
+            }
+        })
+    };
+
+    drop(root); // drop strong owner
+    handle.join().unwrap();
+}
+
+/* ───────────────────── 4) Cache pattern with Weak (auto-expiring) ─────────────────────
+   Store Weak pointers in a map so entries auto-expire when values are no longer strongly owned.
+*/
+
+use std::collections::HashMap;
+
+#[derive(Debug)]
+struct BigThing(&'static str);
+
+pub fn ex_cache_with_weak() {
+    println!("\n== 4) Cache with Weak (auto-expiring) ==");
+    let mut cache: HashMap<&'static str, RcWeak<BigThing>> = HashMap::new();
+
+    // Insert an object and a weak handle in the cache
+    let key = "itemA";
+    let strong = Rc::new(BigThing("payload"));
+    cache.insert(key, Rc::downgrade(&strong));
+
+    // Later: try to fetch from cache
+    match cache.get(key).and_then(|w| w.upgrade()) {
+        Some(rc) => println!("cache hit (alive): {:?}", rc),
+        None => println!("cache miss / expired"),
+    }
+
+    // Drop the only strong owner; cache now holds only a Weak
+    drop(strong);
+
+    // Try again: upgrade fails, so evict
+    match cache.get(key).and_then(|w| w.upgrade()) {
+        Some(_) => {}
+        None => {
+            println!("cache entry expired; pruning");
+            cache.remove(key);
+        }
+    }
+    println!("cache len = {}", cache.len());
+}
+
+/* ──────────────────────── 5) Leak demo: strong back-edge (DON'T) ────────────────────────
+   This shows how a strong parent<->child reference leaks (cycle). We then fix it with Weak.
+*/
+
+#[derive(Debug)]
+struct BadNode {
+    name: String,
+    parent: RefCell<Option<Rc<BadNode>>>,     // ❌ strong back-edge (causes leak)
+    children: RefCell<Vec<Rc<BadNode>>>,
+}
+
+pub fn ex_leak_then_fix() {
+    println!("\n== 5) Cycle leak demo (Rc strong back-edge) vs Weak fix ==");
+
+    // Strong back-edge → leak (we'll observe counts).
+    let a = Rc::new(BadNode {
+        name: "A".into(),
+        parent: RefCell::new(None),
+        children: RefCell::new(vec![]),
+    });
+    let b = Rc::new(BadNode {
+        name: "B".into(),
+        parent: RefCell::new(None),
+        children: RefCell::new(vec![]),
+    });
+
+    a.children.borrow_mut().push(b.clone());
+    *b.parent.borrow_mut() = Some(a.clone()); // ❌ strong cycle A <-> B
+
+    println!(
+        "[bad] A counts: strong={}, weak={}",
+        Rc::strong_count(&a),
+        Rc::weak_count(&a)
+    );
+    println!(
+        "[bad] B counts: strong={}, weak={}",
+        Rc::strong_count(&b),
+        Rc::weak_count(&b)
+    );
+
+    // Dropping a/b won't drop the inner values because strong counts never hit 0 (cycle).
+    // (We won't actually cause a process leak in this demo since it ends here.)
+
+    // ✅ Fix: use Weak for back-edge
+    #[derive(Debug)]
+    struct GoodNode {
+        name: String,
+        parent: RefCell<RcWeak<GoodNode>>,   // weak back-edge
+        children: RefCell<Vec<Rc<GoodNode>>>,
+    }
+
+    let p = Rc::new(GoodNode {
+        name: "P".into(),
+        parent: RefCell::new(RcWeak::new()),
+        children: RefCell::new(vec![]),
+    });
+    let c = Rc::new(GoodNode {
+        name: "C".into(),
+        parent: RefCell::new(RcWeak::new()),
+        children: RefCell::new(vec![]),
+    });
+    p.children.borrow_mut().push(c.clone());
+    *c.parent.borrow_mut() = Rc::downgrade(&p);
+
+    println!(
+        "[good] P counts: strong={}, weak={}",
+        Rc::strong_count(&p),
+        Rc::weak_count(&p)
+    );
+    println!(
+        "[good] C counts: strong={}, weak={}",
+        Rc::strong_count(&c),
+        Rc::weak_count(&c)
+    );
+    // Now dropping P will not be kept alive by C's weak parent reference.
+}
+
+/* ───────────────────────────────────────── main ───────────────────────────────────────── */
+
+
+/* ───────────────────────────── Docs-style notes ─────────────────────────────
+
+WHAT `Weak<T>` IS
+- A pointer associated with an `Rc<T>` or `Arc<T>` allocation that **does not own** the value.
+- Created with `Rc::downgrade(&rc)` / `Arc::downgrade(&arc)`.
+- Upgrade with `.upgrade()` → `Option<Rc<T>>` / `Option<Arc<T>>`.
+  - `Some(...)` if at least one **strong** ref exists; `None` if value already dropped.
+
+COUNTS & DROP ORDER
+- **strong_count**: number of owning references (`Rc`/`Arc`). When this hits 0 -> **value is dropped**.
+- **weak_count**: number of `Weak` pointers (does **not** include the internal, hidden “allocation guard”).
+- The **allocation** itself is freed when both counts are 0 (i.e., no strong owners and no weaks left).
+- Holding `Weak` does **not** prolong the lifetime of `T`; it only keeps the allocation metadata alive.
+
+WHY USE `Weak`
+- Break cycles in graphs (parent↔child). Make back-edges weak so strong counts can reach 0.
+- Caches/registries: store `Weak` handles so entries auto-expire when not strongly owned elsewhere.
+- Observers: non-owning subscribers that may disappear without coordination (upgrade to check).
+
+SINGLE-THREAD vs MULTI-THREAD
+- `Rc<T>`/`Rc::Weak<T>`: single-threaded; not `Send`/`Sync`.
+- `Arc<T>`/`Arc::Weak<T>`: thread-safe refcounts; ok to share across threads.
+- For mutation with Arc, combine with `Mutex`/`RwLock`/atomics.
+
+PATTERNS / APIS
+- Create: `let w = Rc::downgrade(&rc);`
+- Upgrade: `if let Some(rc) = w.upgrade() { /* use rc */ }`
+- Counts: `Rc::strong_count(&rc)`, `Rc::weak_count(&rc)` (same for Arc).
+- Evict dead weaks: filter a list/map of `Weak` by `w.upgrade().is_some()`.
+
+PITFALLS
+- Don’t forget to make **exactly the back-edges** weak; two-way strong links leak.
+- Be careful not to hold temporary strong clones (from `upgrade()`) longer than necessary if you expect a drop.
+- `weak_count` doesn’t include the internal guard; seeing `0` for weak_count doesn’t mean the allocation can be freed if strong_count > 0.
+
+MENTAL MODEL
+- Think of `Weak` as a “peekable address book entry” for an `Rc/Arc` allocation:
+  - You can look up whether the person still lives there (`upgrade()`).
+  - If they’ve moved out (no strong refs), the address card is useless (`None`).
+  - The card itself doesn’t keep them living there.
+
+*/ 
diff --git a/weak-doc/src/main.rs b/weak-doc/src/main.rs
index 539352ebb0051ae73641336a035d2f1c7446e1d3..c713d6df9f4ca49ae5d3b5b7d581afe146d9ab1e 100644
--- a/weak-doc/src/main.rs
+++ b/weak-doc/src/main.rs
@@ -1,316 +1,15 @@
-//! Weak<T> in Rust — mini-docs + runnable examples
-//!
-//! TL;DR
-//! - `Weak<T>` is a **non-owning** pointer to the allocation behind `Rc<T>` or `Arc<T>`.
-//! - It **does not** keep the value alive (doesn’t affect drop timing).
-//! - Use `Weak` to **break reference cycles** (e.g., parent↔child graphs).
-//! - To access the value, call `.upgrade()` → `Option<Rc<T>>` / `Option<Arc<T>>`.
-//! - When the last strong (`Rc`/`Arc`) is dropped, the value is dropped; the allocation
-//!   is freed when **both** strong and weak counts reach zero.
-
-use std::{
-    cell::RefCell,
-    rc::{Rc, Weak as RcWeak},
-    sync::{Arc, Weak as ArcWeak, Mutex},
-    thread,
-    time::Duration,
+use weak_doc::{
+    ex_rc_weak_basics,
+    ex_rc_cycle_vs_weak,
+    ex_arc_weak_multithread,
+    ex_cache_with_weak,
+    ex_leak_then_fix,
 };
 
-/* ───────────────────────── 1) Basics: Rc::Weak (single-threaded) ───────────────────────── */
-
-fn ex_rc_weak_basics() {
-    println!("== 1) Rc::Weak basics ==");
-
-    let strong = Rc::new(String::from("hello"));
-    let weak: RcWeak<String> = Rc::downgrade(&strong);
-
-    println!("strong_count = {}", Rc::strong_count(&strong)); // 1
-    println!("weak_count    = {}", Rc::weak_count(&strong));  // 1 (the `weak` above)
-
-    // Access via upgrade
-    if let Some(s) = weak.upgrade() {
-        println!("upgrade -> {}", s); // "hello"
-        // `s` is an Rc clone; keeps the value alive while in scope
-    }
-
-    // Drop the last strong owner
-    drop(strong);
-
-    // Now the value is dropped; upgrade fails (allocation may still exist until weak_count==0)
-    assert!(weak.upgrade().is_none());
-    println!("after drop: upgrade -> None");
-}
-
-/* ─────────────── 2) Breaking cycles in graphs: Rc<RefCell<T>> + Rc::Weak ───────────────
-   Problem: cycles of Rc cause leaks (values never dropped) because refcount never hits zero.
-   Solution: use Weak for back-edges (e.g., child -> parent).
-*/
-
-#[derive(Debug)]
-struct NodeRc {
-    name: String,
-    parent: RefCell<RcWeak<NodeRc>>,     // weak back-edge
-    children: RefCell<Vec<Rc<NodeRc>>>,  // strong edges to children
-}
-
-fn ex_rc_cycle_vs_weak() {
-    println!("\n== 2) Breaking cycles with Rc::Weak ==");
-
-    // Make a parent and a child
-    let parent = Rc::new(NodeRc {
-        name: "root".into(),
-        parent: RefCell::new(RcWeak::new()),
-        children: RefCell::new(vec![]),
-    });
-    let child = Rc::new(NodeRc {
-        name: "leaf".into(),
-        parent: RefCell::new(RcWeak::new()),
-        children: RefCell::new(vec![]),
-    });
-
-    // root -> child (strong)
-    parent.children.borrow_mut().push(child.clone());
-    // child -> root (WEAK)
-    *child.parent.borrow_mut() = Rc::downgrade(&parent);
-
-    println!(
-        "counts (parent): strong={}, weak={}",
-        Rc::strong_count(&parent),
-        Rc::weak_count(&parent)
-    );
-    println!(
-        "counts (child) : strong={}, weak={}",
-        Rc::strong_count(&child),
-        Rc::weak_count(&child)
-    );
-
-    // Drop the strong parent; child only holds a WEAK back-edge, so no cycle leak.
-    drop(parent);
-
-    // Child's weak parent pointer cannot keep parent alive:
-    if child.parent.borrow().upgrade().is_none() {
-        println!("parent has been dropped; weak back-edge is now None");
-    }
-}
-
-/* ───────────────────── 3) Arc::Weak in multi-threaded graphs ───────────────────── */
-
-#[derive(Debug)]
-struct NodeArc {
-    name: String,
-    parent: Mutex<ArcWeak<NodeArc>>,       // weak back-edge
-    children: Mutex<Vec<Arc<NodeArc>>>,    // strong edges
-}
-
-fn ex_arc_weak_multithread() {
-    println!("\n== 3) Arc::Weak in multi-threaded graphs ==");
-
-    let root = Arc::new(NodeArc {
-        name: "root".into(),
-        parent: Mutex::new(ArcWeak::new()),
-        children: Mutex::new(vec![]),
-    });
-    let leaf = Arc::new(NodeArc {
-        name: "leaf".into(),
-        parent: Mutex::new(ArcWeak::new()),
-        children: Mutex::new(vec![]),
-    });
-
-    // root -> leaf (strong)
-    root.children.lock().unwrap().push(leaf.clone());
-    // leaf -> root (WEAK)
-    *leaf.parent.lock().unwrap() = Arc::downgrade(&root);
-
-    println!(
-        "counts (root): strong={}, weak={}",
-        Arc::strong_count(&root),
-        Arc::weak_count(&root)
-    );
-    println!(
-        "counts (leaf): strong={}, weak={}",
-        Arc::strong_count(&leaf),
-        Arc::weak_count(&leaf)
-    );
-
-    // Move leaf to another thread, observe parent after dropping root
-    let handle = {
-        let leaf = leaf.clone();
-        thread::spawn(move || {
-            thread::sleep(Duration::from_millis(10));
-            if leaf.parent.lock().unwrap().upgrade().is_none() {
-                println!("[thread] root dropped; weak back-edge is None");
-            }
-        })
-    };
-
-    drop(root); // drop strong owner
-    handle.join().unwrap();
-}
-
-/* ───────────────────── 4) Cache pattern with Weak (auto-expiring) ─────────────────────
-   Store Weak pointers in a map so entries auto-expire when values are no longer strongly owned.
-*/
-
-use std::collections::HashMap;
-
-#[derive(Debug)]
-struct BigThing(&'static str);
-
-fn ex_cache_with_weak() {
-    println!("\n== 4) Cache with Weak (auto-expiring) ==");
-    let mut cache: HashMap<&'static str, RcWeak<BigThing>> = HashMap::new();
-
-    // Insert an object and a weak handle in the cache
-    let key = "itemA";
-    let strong = Rc::new(BigThing("payload"));
-    cache.insert(key, Rc::downgrade(&strong));
-
-    // Later: try to fetch from cache
-    match cache.get(key).and_then(|w| w.upgrade()) {
-        Some(rc) => println!("cache hit (alive): {:?}", rc),
-        None => println!("cache miss / expired"),
-    }
-
-    // Drop the only strong owner; cache now holds only a Weak
-    drop(strong);
-
-    // Try again: upgrade fails, so evict
-    match cache.get(key).and_then(|w| w.upgrade()) {
-        Some(_) => {}
-        None => {
-            println!("cache entry expired; pruning");
-            cache.remove(key);
-        }
-    }
-    println!("cache len = {}", cache.len());
-}
-
-/* ──────────────────────── 5) Leak demo: strong back-edge (DON'T) ────────────────────────
-   This shows how a strong parent<->child reference leaks (cycle). We then fix it with Weak.
-*/
-
-#[derive(Debug)]
-struct BadNode {
-    name: String,
-    parent: RefCell<Option<Rc<BadNode>>>,     // ❌ strong back-edge (causes leak)
-    children: RefCell<Vec<Rc<BadNode>>>,
-}
-
-fn ex_leak_then_fix() {
-    println!("\n== 5) Cycle leak demo (Rc strong back-edge) vs Weak fix ==");
-
-    // Strong back-edge → leak (we'll observe counts).
-    let a = Rc::new(BadNode {
-        name: "A".into(),
-        parent: RefCell::new(None),
-        children: RefCell::new(vec![]),
-    });
-    let b = Rc::new(BadNode {
-        name: "B".into(),
-        parent: RefCell::new(None),
-        children: RefCell::new(vec![]),
-    });
-
-    a.children.borrow_mut().push(b.clone());
-    *b.parent.borrow_mut() = Some(a.clone()); // ❌ strong cycle A <-> B
-
-    println!(
-        "[bad] A counts: strong={}, weak={}",
-        Rc::strong_count(&a),
-        Rc::weak_count(&a)
-    );
-    println!(
-        "[bad] B counts: strong={}, weak={}",
-        Rc::strong_count(&b),
-        Rc::weak_count(&b)
-    );
-
-    // Dropping a/b won't drop the inner values because strong counts never hit 0 (cycle).
-    // (We won't actually cause a process leak in this demo since it ends here.)
-
-    // ✅ Fix: use Weak for back-edge
-    #[derive(Debug)]
-    struct GoodNode {
-        name: String,
-        parent: RefCell<RcWeak<GoodNode>>,   // weak back-edge
-        children: RefCell<Vec<Rc<GoodNode>>>,
-    }
-
-    let p = Rc::new(GoodNode {
-        name: "P".into(),
-        parent: RefCell::new(RcWeak::new()),
-        children: RefCell::new(vec![]),
-    });
-    let c = Rc::new(GoodNode {
-        name: "C".into(),
-        parent: RefCell::new(RcWeak::new()),
-        children: RefCell::new(vec![]),
-    });
-    p.children.borrow_mut().push(c.clone());
-    *c.parent.borrow_mut() = Rc::downgrade(&p);
-
-    println!(
-        "[good] P counts: strong={}, weak={}",
-        Rc::strong_count(&p),
-        Rc::weak_count(&p)
-    );
-    println!(
-        "[good] C counts: strong={}, weak={}",
-        Rc::strong_count(&c),
-        Rc::weak_count(&c)
-    );
-    // Now dropping P will not be kept alive by C's weak parent reference.
-}
-
-/* ───────────────────────────────────────── main ───────────────────────────────────────── */
-
 fn main() {
     ex_rc_weak_basics();
     ex_rc_cycle_vs_weak();
     ex_arc_weak_multithread();
     ex_cache_with_weak();
     ex_leak_then_fix();
 }
-
-/* ───────────────────────────── Docs-style notes ─────────────────────────────
-
-WHAT `Weak<T>` IS
-- A pointer associated with an `Rc<T>` or `Arc<T>` allocation that **does not own** the value.
-- Created with `Rc::downgrade(&rc)` / `Arc::downgrade(&arc)`.
-- Upgrade with `.upgrade()` → `Option<Rc<T>>` / `Option<Arc<T>>`.
-  - `Some(...)` if at least one **strong** ref exists; `None` if value already dropped.
-
-COUNTS & DROP ORDER
-- **strong_count**: number of owning references (`Rc`/`Arc`). When this hits 0 -> **value is dropped**.
-- **weak_count**: number of `Weak` pointers (does **not** include the internal, hidden “allocation guard”).
-- The **allocation** itself is freed when both counts are 0 (i.e., no strong owners and no weaks left).
-- Holding `Weak` does **not** prolong the lifetime of `T`; it only keeps the allocation metadata alive.
-
-WHY USE `Weak`
-- Break cycles in graphs (parent↔child). Make back-edges weak so strong counts can reach 0.
-- Caches/registries: store `Weak` handles so entries auto-expire when not strongly owned elsewhere.
-- Observers: non-owning subscribers that may disappear without coordination (upgrade to check).
-
-SINGLE-THREAD vs MULTI-THREAD
-- `Rc<T>`/`Rc::Weak<T>`: single-threaded; not `Send`/`Sync`.
-- `Arc<T>`/`Arc::Weak<T>`: thread-safe refcounts; ok to share across threads.
-- For mutation with Arc, combine with `Mutex`/`RwLock`/atomics.
-
-PATTERNS / APIS
-- Create: `let w = Rc::downgrade(&rc);`
-- Upgrade: `if let Some(rc) = w.upgrade() { /* use rc */ }`
-- Counts: `Rc::strong_count(&rc)`, `Rc::weak_count(&rc)` (same for Arc).
-- Evict dead weaks: filter a list/map of `Weak` by `w.upgrade().is_some()`.
-
-PITFALLS
-- Don’t forget to make **exactly the back-edges** weak; two-way strong links leak.
-- Be careful not to hold temporary strong clones (from `upgrade()`) longer than necessary if you expect a drop.
-- `weak_count` doesn’t include the internal guard; seeing `0` for weak_count doesn’t mean the allocation can be freed if strong_count > 0.
-
-MENTAL MODEL
-- Think of `Weak` as a “peekable address book entry” for an `Rc/Arc` allocation:
-  - You can look up whether the person still lives there (`upgrade()`).
-  - If they’ve moved out (no strong refs), the address card is useless (`None`).
-  - The card itself doesn’t keep them living there.
-
-*/ 
 
EOF
)